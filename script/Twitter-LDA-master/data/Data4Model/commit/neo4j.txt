import revision new new utile project wind repository git san
import revision new new utile project wind repository git san
import revision new new utile project wind repository git san
add property support array primitive type string implementation use new dynamic store dynamical store store array new property type call array add property request type get forward dynamical store git san
add property support array primitive type string implementation use new dynamic store dynamical store store array new property type call array add property request type get forward dynamical store git san
add property support array primitive type string implementation use new dynamic store dynamical store store array new property type call array add property request type get forward dynamical store git san
general code cleanup remove old stuff longer use fix eclipse warn fix lot stuff use find bug actually find real bug logically leak map read recovery git san
general code cleanup remove old stuff longer use fix eclipse warn fix lot stuff use find bug actually find real bug logically leak map read recovery git san
general code cleanup remove old stuff longer use fix eclipse warn fix lot stuff use find bug actually find real bug logically leak map read recovery git san
open new optimization branch kiwi include lot performance speed memory improvements list change create fast set map implementations small data set implementation find say faster smaller data set data grow certain threshold implementation switch use implementations instead replace lot map set code use implementation instead result less memory usage better performance switch concurrent concurrent map create property index cache underlie persistence store result key value write lot less previously key write every property boost add property lot also result less memory use remove memory command implementation none instance abstract record create event generation write prepare rollback use create method abstract record free ids less memory use better performance commit memory map window exist transfer use logical log store instead plain byte buffer load dynamic record change include light state actual data load block header information data write logical log optimize record delete write byte dynamic record light write block header update record method store also write less data record delete light store string write underlie char array instead use get bytes unnecessary validation code either remove completely change assert statements optimization change way lot work verify correctness property index implementation complete key remove mature concurrent issue result change fix lot stuff change lot test bug fix beta kiwi release git san
open new optimization branch kiwi include lot performance speed memory improvements list change create fast set map implementations small data set implementation find say faster smaller data set data grow certain threshold implementation switch use implementations instead replace lot map set code use implementation instead result less memory usage better performance switch concurrent concurrent map create property index cache underlie persistence store result key value write lot less previously key write every property boost add property lot also result less memory use remove memory command implementation none instance abstract record create event generation write prepare rollback use create method abstract record free ids less memory use better performance commit memory map window exist transfer use logical log store instead plain byte buffer load dynamic record change include light state actual data load block header information data write logical log optimize record delete write byte dynamic record light write block header update record method store also write less data record delete light store string write underlie char array instead use get bytes unnecessary validation code either remove completely change assert statements optimization change way lot work verify correctness property index implementation complete key remove mature concurrent issue result change fix lot stuff change lot test bug fix beta kiwi release git san
open new optimization branch kiwi include lot performance speed memory improvements list change create fast set map implementations small data set implementation find say faster smaller data set data grow certain threshold implementation switch use implementations instead replace lot map set code use implementation instead result less memory usage better performance switch concurrent concurrent map create property index cache underlie persistence store result key value write lot less previously key write every property boost add property lot also result less memory use remove memory command implementation none instance abstract record create event generation write prepare rollback use create method abstract record free ids less memory use better performance commit memory map window exist transfer use logical log store instead plain byte buffer load dynamic record change include light state actual data load block header information data write logical log optimize record delete write byte dynamic record light write block header update record method store also write less data record delete light store string write underlie char array instead use get bytes unnecessary validation code either remove completely change assert statements optimization change way lot work verify correctness property index implementation complete key remove mature concurrent issue result change fix lot stuff change lot test bug fix beta kiwi release git san
optimization change remove connection bundle persistence package currently make use different persistence source general cleanup code make stuff final change map array map make logical log use memory map buffer fall back direct buffer unable map remove command package transaction cache longer need remove command none package longer need add possibility dynamic record hold char data make allocate string record dynamic store faster transaction isolation level possible read commit allow optimizations since never use isolation level application think note one still get higher isolation level synchronize acquire lock application layer git san
optimization change remove connection bundle persistence package currently make use different persistence source general cleanup code make stuff final change map array map make logical log use memory map buffer fall back direct buffer unable map remove command package transaction cache longer need remove command none package longer need add possibility dynamic record hold char data make allocate string record dynamic store faster transaction isolation level possible read commit allow optimizations since never use isolation level application think note one still get higher isolation level synchronize acquire lock application layer git san
optimization change remove connection bundle persistence package currently make use different persistence source general cleanup code make stuff final change map array map make logical log use memory map buffer fall back direct buffer unable map remove command package transaction cache longer need remove command none package longer need add possibility dynamic record hold char data make allocate string record dynamic store faster transaction isolation level possible read commit allow optimizations since never use isolation level application think note one still get higher isolation level synchronize acquire lock application layer git san
try fix file separator problem path new store git san
try fix file separator problem path new store git san
try fix file separator problem path new store git san
add valid rollback status transaction manager rollback call git san
add valid rollback status transaction manager rollback call git san
add valid rollback status transaction manager rollback call git san
start move optimization phase fix bug phase general cleanup optimization change lot bug fix summary change add lazy write record resources mean resource wait write record logical log certain amount wait record reach limit reach resource tell flush change connect record record write logical log result lot less flush resource recovery make everything case crash add flush method none store since efficient flush many transactions add fuck utility new store property index fix problem set property property type change previously record store release properly since information previous type also old new implementation allow type change property fix synchronization issue delete insert relationship previously relationships modify double link list relationship store could modify without proper write lock fix write read command bug none logical log find recovery test fix problem property index get create one transaction use another concurrent transaction create transaction roll back fix non thread safe issue thread safe implementation array map change type safe end persistence operations end move generic command implementation none abstract class make unit test delete nod relationships properties create modify unit test throw exception change perform operation delete node relationship git san
start move optimization phase fix bug phase general cleanup optimization change lot bug fix summary change add lazy write record resources mean resource wait write record logical log certain amount wait record reach limit reach resource tell flush change connect record record write logical log result lot less flush resource recovery make everything case crash add flush method none store since efficient flush many transactions add fuck utility new store property index fix problem set property property type change previously record store release properly since information previous type also old new implementation allow type change property fix synchronization issue delete insert relationship previously relationships modify double link list relationship store could modify without proper write lock fix write read command bug none logical log find recovery test fix problem property index get create one transaction use another concurrent transaction create transaction roll back fix non thread safe issue thread safe implementation array map change type safe end persistence operations end move generic command implementation none abstract class make unit test delete nod relationships properties create modify unit test throw exception change perform operation delete node relationship git san
start move optimization phase fix bug phase general cleanup optimization change lot bug fix summary change add lazy write record resources mean resource wait write record logical log certain amount wait record reach limit reach resource tell flush change connect record record write logical log result lot less flush resource recovery make everything case crash add flush method none store since efficient flush many transactions add fuck utility new store property index fix problem set property property type change previously record store release properly since information previous type also old new implementation allow type change property fix synchronization issue delete insert relationship previously relationships modify double link list relationship store could modify without proper write lock fix write read command bug none logical log find recovery test fix problem property index get create one transaction use another concurrent transaction create transaction roll back fix non thread safe issue thread safe implementation array map change type safe end persistence operations end move generic command implementation none abstract class make unit test delete nod relationships properties create modify unit test throw exception change perform operation delete node relationship git san
add load exist property index startup try load index load limit normal apps full property index cache merge bug fix trunk modify array store store string array char instead use get bytes method write converter convert beta store beta store create property index key git san
add load exist property index startup try load index load limit normal apps full property index cache merge bug fix trunk modify array store store string array char instead use get bytes method write converter convert beta store beta store create property index key git san
add load exist property index startup try load index load limit normal apps full property index cache merge bug fix trunk modify array store store string array char instead use get bytes method write converter convert beta store beta store create property index key git san
prepare release clean code fix bug property index could cause index see create read git san
prepare release clean code fix bug property index could cause index see create read git san
prepare release clean code fix bug property index could cause index see create read git san
fix bug cause transfer logical log store transfer correct number bytes dynamic record char data cause relationship type name store since memory map involve store also add utility admin store dump relationship type git san
fix bug cause transfer logical log store transfer correct number bytes dynamic record char data cause relationship type name store since memory map involve store also add utility admin store dump relationship type git san
fix bug cause transfer logical log store transfer correct number bytes dynamic record char data cause relationship type name store since memory map involve store also add utility admin store dump relationship type git san
modify node relationship code implementations return fix int multiplications node relationship property store implementations result value cause everything illegal position wrong record access modify persistence window pool allocate memory map windows startup instead first refresh bricks allocate better huge store refresh bricks expand bricks implementation persistence window pool tweak perform better large store git san
modify node relationship code implementations return fix int multiplications node relationship property store implementations result value cause everything illegal position wrong record access modify persistence window pool allocate memory map windows startup instead first refresh bricks allocate better huge store refresh bricks expand bricks implementation persistence window pool tweak perform better large store git san
modify node relationship code implementations return fix int multiplications node relationship property store implementations result value cause everything illegal position wrong record access modify persistence window pool allocate memory map windows startup instead first refresh bricks allocate better huge store refresh bricks expand bricks implementation persistence window pool tweak perform better large store git san
move testtxarraypropertyproblem test fix problem command anymore problem occur property change take place node relationship get enlist transaction therefore rollback invoke node relationship get remove cache read git san
move testtxarraypropertyproblem test fix problem command anymore problem occur property change take place node relationship get enlist transaction therefore rollback invoke node relationship get remove cache read git san
move testtxarraypropertyproblem test fix problem command anymore problem occur property change take place node relationship get enlist transaction therefore rollback invoke node relationship get remove cache read git san
fix windows problem transfer update fail fall back normal buffer update modify close logical log try parry windows problem map byte buffer file git san
fix windows problem transfer update fail fall back normal buffer update modify close logical log try parry windows problem map byte buffer file git san
fix windows problem transfer update fail fall back normal buffer update modify close logical log try parry windows problem map byte buffer file git san
fix exception handle run time exceptions wrap persistence exception throw none package modify get relationships methods use iterator check next relationship exist relationship find iterator silent next relationship git san
fix exception handle run time exceptions wrap persistence exception throw none package modify get relationships methods use iterator check next relationship exist relationship find iterator silent next relationship git san
fix exception handle run time exceptions wrap persistence exception throw none package modify get relationships methods use iterator check next relationship exist relationship find iterator silent next relationship git san
fix infinite loop rebuild generator record size git san
fix infinite loop rebuild generator record size git san
fix infinite loop rebuild generator record size git san
write converter convert relationship type name byte encode new store use underlie character git san
write converter convert relationship type name byte encode new store use underlie character git san
write converter convert relationship type name byte encode new store use underlie character git san
misc utility stuff need convert old none store fix bug fuck stop check store record illegal use flag find git san
misc utility stuff need convert old none store fix bug fuck stop check store record illegal use flag find git san
misc utility stuff need convert old none store fix bug fuck stop check store record illegal use flag find git san
windows session new fix problems often problems relate file channel memory map release properly file channel close properly file operation fail memory map region yet system invoke file operation try find one nasty bug regard file channel position apparently use memory map buffer modify underlie file channel position windows way unix fix log buffer file channel position track implementation also take opportunity fix warn latest vanilla eclipse version complain git san
windows session new fix problems often problems relate file channel memory map release properly file channel close properly file operation fail memory map region yet system invoke file operation try find one nasty bug regard file channel position apparently use memory map buffer modify underlie file channel position windows way unix fix log buffer file channel position track implementation also take opportunity fix warn latest vanilla eclipse version complain git san
windows session new fix problems often problems relate file channel memory map release properly file channel close properly file operation fail memory map region yet system invoke file operation try find one nasty bug regard file channel position apparently use memory map buffer modify underlie file channel position windows way unix fix log buffer file channel position track implementation also take opportunity fix warn latest vanilla eclipse version complain git san
update version store add method get call store load version find relationship type store automatically rewrite encode relationship type new store beta older git san
update version store add method get call store load version find relationship type store automatically rewrite encode relationship type new store beta older git san
update version store add method get call store load version find relationship type store automatically rewrite encode relationship type new store beta older git san
open temporary branch test notification new git san
open temporary branch test notification new git san
open temporary branch test notification new git san
rename project components fit new infrastructure
replace event generation use persist change make node space plain method call modify none throw exception make use illegal argument illegal state store failure run time exceptions general cleanup remove old code fix exceptions handle git san
replace event generation use persist change make node space plain method call modify none throw exception make use illegal argument illegal state store failure run time exceptions general cleanup remove old code fix exceptions handle git san
replace event generation use persist change make node space plain method call modify none throw exception make use illegal argument illegal state store failure run time exceptions general cleanup remove old code fix exceptions handle git san
add first implementation macc like behaviour lock read fix two reset bug thread interrupt status git san
add first implementation macc like behaviour lock read fix two reset bug thread interrupt status git san
add first implementation macc like behaviour lock read fix two reset bug thread interrupt status git san
fix bug property store string array cause nod relationships yet commit throw exception request add property string array type make git san
fix bug property store string array cause nod relationships yet commit throw exception request add property string array type make git san
fix bug property store string array cause nod relationships yet commit throw exception request add property string array type make git san
add property match relationships nod make possible define node via relationship another node relationships extract match way nod extract
merge fix branch trunk update versions trunk versions follow components new snapshot shell snapshot new utile snapshot graph match snapshot index snapshot new meta snapshot new ref snapshot new ref sail snapshot tag previous version exist tag directory component name version date follow components point new trunks event framework eclipse new meta import new query apr owner spare engine new spare ser let git san
merge fix branch trunk update versions trunk versions follow components new snapshot shell snapshot new utile snapshot graph match snapshot index snapshot new meta snapshot new ref snapshot new ref sail snapshot tag previous version exist tag directory component name version date follow components point new trunks event framework eclipse new meta import new query apr owner spare engine new spare ser let git san
merge fix branch trunk update versions trunk versions follow components new snapshot shell snapshot new utile snapshot graph match snapshot index snapshot new meta snapshot new ref snapshot new ref sail snapshot tag previous version exist tag directory component name version date follow components point new trunks event framework eclipse new meta import new query apr owner spare engine new spare ser let git san
fix illegal check getrelationshipbyid format git san
fix illegal check getrelationshipbyid format git san
fix illegal check getrelationshipbyid format git san
fix problem add relationship would case relationships load current node whenever new transaction create git san
fix problem add relationship would case relationships load current node whenever new transaction create git san
fix problem add relationship would case relationships load current node whenever new transaction create git san
rewrite property handle copy write fix possible memory starvation bug memory cache get clear would possible memory allocate time clean already free memory also modify adaptive cache settings work better small heap much heap memory use could however impact normal production settings need investigate git san
rewrite property handle copy write fix possible memory starvation bug memory cache get clear would possible memory allocate time clean already free memory also modify adaptive cache settings work better small heap much heap memory use could however impact normal production settings need investigate git san
rewrite property handle copy write fix possible memory starvation bug memory cache get clear would possible memory allocate time clean already free memory also modify adaptive cache settings work better small heap much heap memory use could however impact normal production settings need investigate git san
code cleanup remove non use old code convert tabs space fix minor issue git san
code cleanup remove non use old code convert tabs space fix minor issue git san
code cleanup remove non use old code convert tabs space fix minor issue git san
temporary fix concurrency issue git san
temporary fix concurrency issue git san
temporary fix concurrency issue git san
clean copy write stuff optimize apply diff remove field primitive favor memory footprint performance gain big add entry set array map git san
clean copy write stuff optimize apply diff remove field primitive favor memory footprint performance gain big add entry set array map git san
clean copy write stuff optimize apply diff remove field primitive favor memory footprint performance gain big add entry set array map git san
update copyright notice modify parent pom copyright notice file always include meta inf directory produce jar file git san
update copyright notice modify parent pom copyright notice file always include meta inf directory produce jar file git san
update copyright notice modify parent pom copyright notice file always include meta inf directory produce jar file git san
move graph also code component git san
move graph also code component git san
move graph also code component git san
another package rename shortest path shortest path git san
another package rename shortest path shortest path git san
another package rename shortest path shortest path git san
add information exceptions see ticket git san
add information exceptions see ticket git san
add information exceptions see ticket git san
remove neoconstraintsliestener move constraint check one layer reduce memory footprint nod relationships remove boolean delete flag phase flag git san
remove neoconstraintsliestener move constraint check one layer reduce memory footprint nod relationships remove boolean delete flag phase flag git san
remove neoconstraintsliestener move constraint check one layer reduce memory footprint nod relationships remove boolean delete flag phase flag git san
merge branch trunk add logical log rotation core feature need online backup default logical log auto rotate log save apply previous snapshot data source synchronize backup log rotate git san
merge branch trunk add logical log rotation core feature need online backup default logical log auto rotate log save apply previous snapshot data source synchronize backup log rotate git san
merge branch trunk add logical log rotation core feature need online backup default logical log auto rotate log save apply previous snapshot data source synchronize backup log rotate git san
make rel node get property methods make use property block long value string array type previously null always pass value already present git san
make rel node get property methods make use property block long value string array type previously null always pass value already present git san
make rel node get property methods make use property block long value string array type previously null always pass value already present git san
fix problem active transactions larger logical log target rotate size git san
fix problem active transactions larger logical log target rotate size git san
fix problem active transactions larger logical log target rotate size git san
fix issue could cause non commit properties relationships modifications see git san
fix issue could cause non commit properties relationships modifications see git san
fix issue could cause non commit properties relationships modifications see git san
first version simple batch insert git san
first version simple batch insert git san
first version simple batch insert git san
merge bug fix batch insert unsigned branch trunk git san
merge bug fix batch insert unsigned branch trunk git san
merge bug fix batch insert unsigned branch trunk git san
change implementation add remove get relationships node cache layer previous implementation work set performance problem small modifications node create add remove relationships could notice node many relationships copy write larger set slow replace array implementation use array copy add set combine array swap remove also improve get relationship performance write smarter iterator try sort set binary search implementation merge sort slow larger array git san
change implementation add remove get relationships node cache layer previous implementation work set performance problem small modifications node create add remove relationships could notice node many relationships copy write larger set slow replace array implementation use array copy add set combine array swap remove also improve get relationship performance write smarter iterator try sort set binary search implementation merge sort slow larger array git san
change implementation add remove get relationships node cache layer previous implementation work set performance problem small modifications node create add remove relationships could notice node many relationships copy write larger set slow replace array implementation use array copy add set combine array swap remove also improve get relationship performance write smarter iterator try sort set binary search implementation merge sort slow larger array git san
merge change perform unsigned branch trunk git san
merge change perform unsigned branch trunk git san
merge change perform unsigned branch trunk git san
add get set method add fig memory map plain persistence windows logically use memory map buffer direct buffer batch insert use plain persistence windows instead memory map store old generator format get convert tweak brick count persistencewindowpool increase store versions memory map buffer use default windows git san
add get set method add fig memory map plain persistence windows logically use memory map buffer direct buffer batch insert use plain persistence windows instead memory map store old generator format get convert tweak brick count persistencewindowpool increase store versions memory map buffer use default windows git san
add get set method add fig memory map plain persistence windows logically use memory map buffer direct buffer batch insert use plain persistence windows instead memory map store old generator format get convert tweak brick count persistencewindowpool increase store versions memory map buffer use default windows git san
add interface batch insert git san
add interface batch insert git san
add interface batch insert git san
optimize read transactions open new transaction fix problem persistence row clear buffer write git san
optimize read transactions open new transaction fix problem persistence row clear buffer write git san
optimize read transactions open new transaction fix problem persistence row clear buffer write git san
fix iterator get relationships methods native store layer previously relationships get load native store get load demand configurable grab size git san
fix iterator get relationships methods native store layer previously relationships get load native store get load demand configurable grab size git san
fix iterator get relationships methods native store layer previously relationships get load native store get load demand configurable grab size git san
implement read new service git san
implement read new service git san
implement read new service git san
create kernel component neon kernel contain refactored version new component component refactored per git san
create kernel component neon kernel contain refactored version new component component refactored per git san
create kernel component neon kernel contain refactored version new component component refactored per git san
new service new cleanup git san
new service new cleanup git san
new service new cleanup git san
find bug eclipse warn fix git san
find bug eclipse warn fix git san
find bug eclipse warn fix git san
add shortest path finder stop first shortest path find git san
add shortest path finder stop first shortest path find git san
add shortest path finder stop first shortest path find git san
add index app use use index service choice specify index use via environment variable index class name default easy instantiate index service run local shell server connect remote server use moderately ugly hack reflection via module reach already instantiate index service object git san
fix problem break command entry identifier command type write byte zero could read result exception throw git san
fix problem break command entry identifier command type write byte zero could read result exception throw git san
fix problem break command entry identifier command type write byte zero could read result exception throw git san
remove new name replace better name git san
remove new name replace better name git san
san add git san
san add git san
san add git san
merge old branch git san
merge old branch git san
merge old branch git san
clarify java doc regard regard persistence git san
clarify java doc regard regard persistence git san
clarify java doc regard regard persistence git san
merge change trunks kernel online backup branch git san
merge change trunks kernel online backup branch git san
merge change trunks kernel online backup branch git san
fix bug logical log could case bufferoverflowexception write large array string properties git san
fix bug logical log could case bufferoverflowexception write large array string properties git san
fix bug logical log could case bufferoverflowexception write large array string properties git san
merge change trunk add skeleton code apply transaction logically add node rel property command get write logical log fix cache invalidation properties git san
merge change trunk add skeleton code apply transaction logically add node rel property command get write logical log fix cache invalidation properties git san
merge change trunk add skeleton code apply transaction logically add node rel property command get write logical log fix cache invalidation properties git san
justify test result shorter execution time due fewer graph database instance instantiate git san
justify test result shorter execution time due fewer graph database instance instantiate git san
justify test result shorter execution time due fewer graph database instance instantiate git san
rename test package capital letter git san
rename test package capital letter git san
rename test package capital letter git san
test create file target somewhere git san
test create file target somewhere git san
test create file target somewhere git san
merge change tank git san
merge change tank git san
merge change tank git san
refactored implementation logically still need work move code logout start implement recommit transaction git san
refactored implementation logically still need work move code logout start implement recommit transaction git san
refactored implementation logically still need work move code logout start implement recommit transaction git san
assembly instructions move package git san
assembly instructions move package git san
assembly instructions move package git san
fix problem delete semantics consistent regardless node relationship cache git san
fix problem delete semantics consistent regardless node relationship cache git san
fix problem delete semantics consistent regardless node relationship cache git san
use testable code snippets site documentation git san
use testable code snippets site documentation git san
use testable code snippets site documentation git san
fix problem clean shutdown fail due crash active log set clean git san
fix problem clean shutdown fail due crash active log set clean git san
fix problem clean shutdown fail due crash active log set clean git san
add method get graphdatabaseservice node relationship git san
add method get graphdatabaseservice node relationship git san
add method get graphdatabaseservice node relationship git san
introduce new event framework consist transactioneventhandler register graphdatabaseservice thereafter receive diffs modifications make transaction commit transaction still modify commit method also throw exception prevent transaction commit cause transactionfailureexception throw finish kerneleventhandler register graphdatabaseservice receive notifications shutdown occur graphhdatabaseservice instance also receive notifications kernel panic state kernel come continue without need restart example error would hard drive breakdown space leave device graph database run git san
introduce new event framework consist transactioneventhandler register graphdatabaseservice thereafter receive diffs modifications make transaction commit transaction still modify commit method also throw exception prevent transaction commit cause transactionfailureexception throw finish kerneleventhandler register graphdatabaseservice receive notifications shutdown occur graphhdatabaseservice instance also receive notifications kernel panic state kernel come continue without need restart example error would hard drive breakdown space leave device graph database run git san
introduce new event framework consist transactioneventhandler register graphdatabaseservice thereafter receive diffs modifications make transaction commit transaction still modify commit method also throw exception prevent transaction commit cause transactionfailureexception throw finish kerneleventhandler register graphdatabaseservice receive notifications shutdown occur graphhdatabaseservice instance also receive notifications kernel panic state kernel come continue without need restart example error would hard drive breakdown space leave device graph database run git san
introduce new traversal framework current new framework everything current traverse start call traversal factory createtraversaldescription eventually follow traversal description traverse oppose node traverse git san
introduce new traversal framework current new framework everything current traverse start call traversal factory createtraversaldescription eventually follow traversal description traverse oppose node traverse git san
introduce new traversal framework current new framework everything current traverse start call traversal factory createtraversaldescription eventually follow traversal description traverse oppose node traverse git san
add status monitor information transactions git san
add status monitor information transactions git san
add status monitor information transactions git san
merge change trunk branch git san
merge change trunk branch git san
merge change trunk branch git san
bring kernel back java compatibility thing java support mean git san
bring kernel back java compatibility thing java support mean git san
bring kernel back java compatibility thing java support mean git san
start refactor cleanup component stuff keep whereas remove rather soon git san
start refactor cleanup component stuff keep whereas remove rather soon git san
start refactor cleanup component stuff keep whereas remove rather soon git san
add work progress new implementation dijkstra git san
add work progress new implementation dijkstra git san
add work progress new implementation dijkstra git san
fix bug event framework cause node relationship delete return incorrect property remove event data git san
fix bug event framework cause node relationship delete return incorrect property remove event data git san
fix bug event framework cause node relationship delete return incorrect property remove event data git san
fix bug auto configuration result wrong configuration memory map buffer turn git san
fix bug auto configuration result wrong configuration memory map buffer turn git san
fix bug auto configuration result wrong configuration memory map buffer turn git san
make block size string array store configurable store create git san
make block size string array store configurable store create git san
make block size string array store configurable store create git san
add keep scallop fig parameter git san
add keep scallop fig parameter git san
add keep scallop fig parameter git san
move also implementations imply package add graphic factory easy access good common argos git san
move also implementations imply package add graphic factory easy access good common argos git san
move also implementations imply package add graphic factory easy access good common argos git san
add test fix two issue process git san
add test fix two issue process git san
add test fix two issue process git san
java doc transaction result class hold information commit git san
java doc transaction result class hold information commit git san
java doc transaction result class hold information commit git san
merge change trunk branch git san
merge change trunk branch git san
merge change trunk branch git san
modify master slave contract interfaces little basically remove unused stuff ability inject factory low level generator use store git san
modify master slave contract interfaces little basically remove unused stuff ability inject factory low level generator use store git san
fix problem package check git san
fix problem package check git san
fix problem package check git san
add new feature query make additional parameters currently sort use lucent sort class relevance index order options index provider relationship index return relationship index extend index add get query methods arguments relationships efficiently query regard give start end node arguments git san
add new feature query make additional parameters currently sort use lucent sort class relevance index order options index provider relationship index return relationship index extend index add get query methods arguments relationships efficiently query regard give start end node arguments git san
add new feature query make additional parameters currently sort use lucent sort class relevance index order options index provider relationship index return relationship index extend index add get query methods arguments relationships efficiently query regard give start end node arguments git san
start implement master fake master reasonable become actual implementation eventually git san
start implement master fake master reasonable become actual implementation eventually git san
start implement master fake master reasonable become actual implementation eventually git san
add taxi factory hook generate good hook git san
add taxi factory hook generate good hook git san
add taxi factory hook generate good hook git san
apply transaction transform identifier new local one git san
apply transaction transform identifier new local one git san
use taxi generator add factory get next write logical log git san
use taxi generator add factory get next write logical log git san
fix issue read transactions git san
fix issue read transactions git san
fix issue read transactions git san
implement slavetxrollbackhook git san
implement slavetxrollbackhook git san
implement slavetxrollbackhook git san
fix single instance factories generator factory lock manager etc run single jim git san
fix single instance factories generator factory lock manager etc run single jim git san
fix single instance factories generator factory lock manager etc run single jim git san
first imply cluster manager git san
first imply cluster manager git san
first imply cluster manager git san
add error handle example thereof git san
add error handle example thereof git san
add error handle example thereof git san
temporary fix recovery need fix properly later state normal remote apply recovery state git san
temporary fix recovery need fix properly later state normal remote apply recovery state git san
add log dump utility git san
add log dump utility git san
add log dump utility git san
add code print zookeeper machine git san
add code print zookeeper machine git san
add code print zookeeper machine git san
throw better exception error reevaluate better get master git san
throw better exception error reevaluate better get master git san
throw better exception error reevaluate better get master git san
refactor logically read apply write entry separate code section git san
refactor logically read apply write entry separate code section git san
refactor logically read apply write entry separate code section git san
open uniqueness interface custom uniqueness implementation supply traversal description git san
open uniqueness interface custom uniqueness implementation supply traversal description git san
open uniqueness interface custom uniqueness implementation supply traversal description git san
move shell index command two index component git san
move shell index command two index component git san
move shell index command two index component git san
add message log git san
add message log git san
add message log git san
merge latest change trunk git san
merge latest change trunk git san
merge latest change trunk git san
test store information zoo keeper auto discovery feature backup cluster git san
test store information zoo keeper auto discovery feature backup cluster git san
test store information zoo keeper auto discovery feature backup cluster git san
rollback master release look call finally block git san
rollback master release look call finally block git san
rollback master release look call finally block git san
fix problem apply log git san
internal flush record fix problem crash global log recover git san
internal flush record fix problem crash global log recover git san
internal flush record fix problem crash global log recover git san
merge bug fix trunk git san
merge bug fix trunk git san
merge bug fix trunk git san
remove git san
remove git san
remove git san
intermediate commit git san
intermediate commit git san
intermediate commit git san
code spike change communication protocol code commit since time box spike end code interest review exist code unaffected change main reason behind spike allow large transactions many transactions send instance convenient easy manage easy extend protocol git san
code spike change communication protocol code commit since time box spike end code interest review exist code unaffected change main reason behind spike allow large transactions many transactions send instance convenient easy manage easy extend protocol git san
code spike change communication protocol code commit since time box spike end code interest review exist code unaffected change main reason behind spike allow large transactions many transactions send instance convenient easy manage easy extend protocol git san
start move code test code git san
start move code test code git san
start move code test code git san
start move code test code git san
make node mph longer implement node relationship mph implement relationship allow require node manager store field node mph relationship mph node manager instead pass argument methods need bring size instance two class byte bite jim byte reduction memory usage class lock still work since lock ever take object thus able equal change enforce fact lock ever take subclasses primitive git san
make node mph longer implement node relationship mph implement relationship allow require node manager store field node mph relationship mph node manager instead pass argument methods need bring size instance two class byte bite jim byte reduction memory usage class lock still work since lock ever take object thus able equal change enforce fact lock ever take subclasses primitive git san
make node mph longer implement node relationship mph implement relationship allow require node manager store field node mph relationship mph node manager instead pass argument methods need bring size instance two class byte bite jim byte reduction memory usage class lock still work since lock ever take object thus able equal change enforce fact lock ever take subclasses primitive git san
merge branch well fix trunk everything branch except lucent transaction commit use make happy git san
merge branch well fix trunk everything branch except lucent transaction commit use make happy git san
merge branch well fix trunk everything branch except lucent transaction commit use make happy git san
fix test fail rel grab size set test write properly git san
fix test fail rel grab size set test write properly git san
fix test fail rel grab size set test write properly git san
fix recovery issue bug git san
fix recovery issue bug git san
fix recovery issue bug git san
add license headers git san
add license headers git san
add license headers git san
fix problem event change read non commit value extract change transaction commit git san
fix problem event change read non commit value extract change transaction commit git san
fix problem event change read non commit value extract change transaction commit git san
java doc test git san
java doc test git san
java doc test git san
merge latest trunk change branch kernel index lucent index also update component new change branch new trunk test quality assurance git san
merge latest trunk change branch kernel index lucent index also update component new change branch new trunk test quality assurance git san
merge latest trunk change branch kernel index lucent index also update component new change branch new trunk test quality assurance git san
add base unit test example add example use new index apr git san
add base unit test example add example use new index apr git san
add base unit test example add example use new index apr git san
add base unit test example add example use new index apr git san
add one assertion git san
add one assertion git san
add one assertion git san
rename example use term integrate index git san
rename example use term integrate index git san
rename example use term integrate index git san
rename example use term integrate index git san
fix issue convert range wildcard term lower case request configuration analyser git san
merge server together number ignore test pertain admin resolve git san
merge server together number ignore test pertain admin resolve git san
merge server together number ignore test pertain admin resolve git san
merge server together number ignore test pertain admin resolve git san
add miss headers git san
add miss headers git san
add miss headers git san
add miss headers git san
create common base class function test move lot stuff git san
create common base class function test move lot stuff git san
create common base class function test move lot stuff git san
create common base class function test move lot stuff git san
add test monitor service dummy representation without red better stub tomorrow git san
add test monitor service dummy representation without red better stub tomorrow git san
add test monitor service dummy representation without red better stub tomorrow git san
add test monitor service dummy representation without red better stub tomorrow git san
add tiny bundle org container test cause throw exception start return error code server startup fail git san
add tiny bundle org container test cause throw exception start return error code server startup fail git san
add tiny bundle org container test cause throw exception start return error code server startup fail git san
add tiny bundle org container test cause throw exception start return error code server startup fail git san
add index current score expose recently fetch index item score search lucent index support move index shell app shell component kernel apps misplace lucent index add query context docs int specify retrieve top hit search may improve performance even retrieve hit iteration way lucent lazily performance improvements regard iterator stack make return index instance query get methods previously could nest iterators add configuration parameter similarity control lucent index writer set similarity similarity index point class name git san
much refactoring rest index apis use new index apr git san
much refactoring rest index apis use new index apr git san
much refactoring rest index apis use new index apr git san
much refactoring rest index apis use new index apr git san
merge server extension branch back trunk git san
merge server extension branch back trunk git san
merge server extension branch back trunk git san
merge server extension branch back trunk git san
add license headers git san
add license headers git san
add license headers git san
add license headers git san
remove test code use git san
remove test code use git san
remove test code use git san
remove test code use git san
mods functional test relationship index start extract urls form pattern candidates either parent class helpers git san
mods functional test relationship index start extract urls form pattern candidates either parent class helpers git san
mods functional test relationship index start extract urls form pattern candidates either parent class helpers git san
mods functional test relationship index start extract urls form pattern candidates either parent class helpers git san
enable test new rest implementation also port update index stuff git san
enable test new rest implementation also port update index stuff git san
enable test new rest implementation also port update index stuff git san
enable test new rest implementation also port update index stuff git san
paths git san
paths git san
paths git san
paths git san
rest index apr return list index nod relationships git san
rest index apr return list index nod relationships git san
rest index apr return list index nod relationships git san
rest index apr return list index nod relationships git san
happy smile green face functional test git san
happy smile green face functional test git san
happy smile green face functional test git san
happy smile green face functional test git san
deprecate merge cause check exception propagate enjoy git san
deprecate merge cause check exception propagate enjoy git san
deprecate merge cause check exception propagate enjoy git san
deprecate merge cause check exception propagate enjoy git san
fix home functionalist git san
fix home functionalist git san
fix home functionalist git san
fix home functionalist git san
remove last old representation class git san
remove last old representation class git san
remove last old representation class git san
remove last old representation class git san
incremental extension plugin rename change package name git san
incremental extension plugin rename change package name git san
incremental extension plugin rename change package name git san
incremental extension plugin rename change package name git san
generate uris fewer place git san
recreate fail custom index lookup problem git san
recreate fail custom index lookup problem git san
recreate fail custom index lookup problem git san
recreate fail custom index lookup problem git san
merge kernel component
merge kernel component
merge kernel component
merge graph also component
merge graph also component
merge graph also component
merge management component
merge online backup component
merge management component
merge udo component
merge server component
merge server component
merge server component
merge server component
add functionality change source identification udo database fig
stab memory layer int long node rel prop ids still fix array store layer
stab memory layer int long node rel prop ids still fix array store layer
stab memory layer int long node rel prop ids still fix array store layer
refactored property type lookup type identifier type object one place
refactored property type lookup type identifier type object one place
refactored property type lookup type identifier type object one place
patch node store use extend bits space res prop
patch node store use extend bits space res prop
patch node store use extend bits space res prop
fix make management component build windows
fix make management component build windows
fix make management component build windows
patch property store dynamic store allow higher order bits
patch property store dynamic store allow higher order bits
patch property store dynamic store allow higher order bits
put windows java home property
put windows java home property
put windows java home property
remove hard cod favor supply store dir minimal change possible order get work windows also hopefully
remove hard cod favor supply store dir minimal change possible order get work windows also hopefully
remove hard cod favor supply store dir minimal change possible order get work windows also hopefully
add bin git ignore seed driver test write driver test hit return create relationships admin
add bin git ignore seed driver test write driver test hit return create relationships admin
add bin git ignore seed driver test write driver test hit return create relationships admin
add bin git ignore seed driver test write driver test hit return create relationships admin
add creation entities node rel prop ids around fix bug along way
add creation entities node rel prop ids around fix bug along way
add creation entities node rel prop ids around fix bug along way
merge branch
remove
add index remove string index remove methods convenience remove stuff index
test create store batch insert
add ability run server reference node functional driver test prove
add ability run server reference node functional driver test prove
add ability run server reference node functional driver test prove
add ability run server reference node functional driver test prove
minor name refactoring
minor name refactoring
minor name refactoring
minor name refactoring
incremented log format version make sure log old format start newer log format version non clean shutdown fail also incremented store version configuration parameter explicitly allow auto upgrade previous version
merge branch
merge branch
add ability define full urls return discovery service specify absolute urls
rename server extensions server apr remove server apr dependency commons configuration
update change log reflect change
update change log reflect change
update change log reflect change
update change log reflect change
fix way current transaction pick completion hook work even transaction managers forget current transaction commit update test match
test adapt rewrite windows run also test disable since operations full backup support current implementation windows
merge branch
remove angle bracket default version version make urls friendly
add cucumber goodies cucumber data browse
add cucumber goodies cucumber data browse
add cucumber goodies cucumber data browse
add cucumber goodies cucumber data browse
try trigger windows failures
move test around start cleanup cuke duke pom
move test around start cleanup cuke duke pom
move test around start cleanup cuke duke pom
move test around start cleanup cuke duke pom
fix fail driver test
fix fail driver test
fix fail driver test
fix fail driver test
add dijkstra algorithm choice query paths two nod
add dijkstra algorithm choice query paths two nod
add dijkstra algorithm choice query paths two nod
add dijkstra algorithm choice query paths two nod
clean test remove redundancy
clean test remove redundancy
clean test remove redundancy
clean test remove redundancy
turn old driver test turn cucumber base test
merge branch
merge branch
merge branch
merge branch
add index query rest apr unit test index query small refactoring helper build testable domain model
make get compilation work maven
web test resilient
update change log
add index remove string index remove rest
movement nod limit canvas
movement nod limit canvas
movement nod limit canvas
movement nod limit canvas
create script include snippets source code manual
basic doc comment
basic doc comment
basic doc comment
basic doc comment
merge branch
merge branch
merge branch
merge branch
fix default configuration value issue
add basic label choose visualization add local storage back settings visualization
add filter dialog split group nod visualization
fix code dependencies test pass get vertices
add new class represent edge pipeline also correct test get edge return list edge
merge change peter
remove two layer call stack load store data remove even consumer class remnant past serve purpose anymore nothing one extra layer graphdatabaseservice persistence layer remove resource connection wrappers instead let implement resource connection interface directly remove one layer call stack
relationships cache addition type direction allow less need filter get relationships
fix problem get connection call per
cosmetic change tool read
better test case static engine script
add fig manual
add convenience methods create numeric range query well sort
add test implementation load spinner show slow operations run
fix bug introduce
include generate rest docs docs jar functional test execute tweak rest apr output
add moore doc test
work generate rest docs
update list rest apr entries start refactoring code bite
reduce necessarily high buffer size still serve purpose speed small transactions free memory cache
merge branch
fix indentation complex mean
add cause exceptions cause actually cause also update log always log exceptions log instead plain std err
add content new rest apr docs fix bug description make docs case
exact node index query available data browser
add node get relationships direction relationship type able take advantage direction aware cache traversals standard expander use new get relationships method compress memory representation relationship mph lowrelationshipimpl shave bytes per instance compress memory representation array map shave bytes per instance
add chair glyph
add batch operation lab project
use one client instance instead client create every request seem expensive also close client responses may solve server test hang bug observe another set resolve two change summarize faster better yes
add first version compact son representation expand upon
expand need profile server drop time start integration test significantly
fix make bean space name work chrome
add remove index update girl
final polish first iteration index manager plus update read relate admin development
fix loader make sure test pass
add embed server let users wrap server around embed databases
add java docs wrappingneoserverbootstrapper add test implementation make sure stop inject shutdown
update batch apr ensure proper rollback failures strip help specific ness response list
downgrade gremlin opinionated dependencies remove check start node end node server since kernel support loop correspond exception class
add plugin foo allow pop style para list process
extend functionality shortest path maximum result count give make stop traverse reach also remove debug thing block
add script able graph work properly yet
merge graph match community
move functional test new pattern use single jetty instance clean database test run
specify test data rule attempt use first sentence title multi line like java doc
add batch operation documentation modify batch apr return job result string son
merge branch
remove memory overhead impose loop take space nod loop
fix batchoperationfunctionaltest add content type internal request fix request path resolution set internal jetty call
documentation test
make sure server builder create good server unless adjust methods use
work refer earlier insert within batch operation
merge branch
add license notice file minor edit documentation
work different docs tutorial part make docs build
add tutorial docs
add ability default index everything ignore properties test pass test separation activation default nod res fail fix
add graphic bracket identify section batch request
change apr two auto indexers one nod one relationships change fig control separately change test comply
abstract common functionality auto indexers common superclass
change exception throw invalid configuration illegals exception illegalargumentexception add relevant section manual correspond test case documentation code snapshot generation
update conform new apr index manager namely get indexer methods aka commit shame
add last pipe column filter provision
add dijkstra test add docs
change sort order
change time base approach separate directories per test case counter base one actually work
upgrade gremlin
kodak dark
add test code ensure restful graph database respond traverse exist away otherwise page result even content length
add scala docs order work well null value
rename test class disambiguate
modify symbol table depend code take care unbind symbols
fix fail test
order write record creations modifications delete order solve issue change would see thread invalid manner
sort aggregate function nicer error message compare items different type min max comparable number execution time add text output
set default set monitor properties none make ignore set obsolete remove correspond methods fig auto indexer interface update implementations auto indexer interface change test match
try solve sort aggregation properties yet
add feature test explicitly delete page traverse order free server resources
make change documentation reflect apr change add mutations section manual clearly demonstrate dangers keep consistent configurations mutations work add mutations test build run test
use single jersey client possible since expensive construct
rid last extra client creations
make parentheses around nod optional match clause
throw syntax error try match node without identifier parenthesis
add ability auto indexer track change index properties happen transaction create callback hook node manager via property tracker inform listeners events primitive properties change signatures add remove change property methods node manager pass around property data object cost one less lookup change way auto index work abstracautoindexerimpl events node manager capture index update enable disable via listeners start auto indexers require access node manager startup sequence change bite add start method index managerial abstractautoindexerimpl test assume change auto index would visible transaction stupid remove since also cause failures
add distinct
change text output execution result fix little documentation
ass change
add support query auto index relationships
add correct status cod show attempt illegally modify automatic index via rest
fix ape commit relationships node mph
server return correct status cod attempt perform illegal operations auto index add rest documentation auto index query
remove unused import
try fix index node functional test server
add test fix break guard red timer thread postal
fix data visibility issue properties newly create primitives
add ignore test allow empty array properties make batch apr better explain wrong errors
use set removals instead rely array misuse rely array along rely array set conversion skip get relationships
add writeable method readable index provide mean distinguish read read write implementations two simple test one case
add getrepresentationtype representation
add clear instructions log configuration
clean symbol table bite
miss throw front new illegalargumentexception
remove previous field dynamic store record update test take change consideration
start longer short string short array implementations
test fix
add hit miss counter monitor information cache management bean
fix bug bits property store load record
implementation longer shoestring
test longer short string come
remove auto index test move test class
move relationship auto index test test class
intermediary commit
docs
close shutdown
make index traversal lazy
remove long urls text
adjust rest test start
remove light boolean field property record substitute value record size
first wave change introduce property block structure make possible store multiple properties property record stage practically nothing work
use bite pack short array long array dynamic array store reduce number dynamic record need non string string also get redo
fix test failures
update change log
refactoring common functionality retrieve store property record
properties type long may store one block altogether value short array string properties take many block need instead whole record
intercept hierarchy record primitive record make extend write transaction use primitive record factor methods less error prone change functionality implement property value change different size property block test testpropertyblocks
make server catch plugin exceptions return correct responses
fix property command bug add strict integrity check change respect enforce new test
fix size calculation bug longer shoestring test match work around similar bug short array need work fix size calculation bug write transaction determine property record suitability change property test match assertions certain sensitive paths test minor format change
optionally relate work simplest case
add documentation single none function
factor plugin relate test profile
remove scout
maven release plugin prepare release
initial work get sol work
store string dynamic record either latin one byte per char uhf less two bytes per char
store string dynamic record either latin one byte per char uhf less two bytes per char
begin implement store migration tool example database create use legacy store creator project
read property record
try use sensible version number manual build ant
read string dynamic store
fix dynamic record command alignment fix write transaction pointers property chain would get update add extensive instrumentation check log sanity comment add two test case sanity check property record command rotation
fix dynamic record command alignment fix write transaction pointers property chain would get update add extensive instrumentation check log sanity comment add two test case sanity check property record command rotation
merge branch
solve inconsistency use flag property record remove print statements
solve inconsistency use flag property record remove print statements
intermediate commit fail test case must fix inconsistencies use property record fix comment add command read write size make debug easier remove property command read clear read flip cycle always happen change test makesurerecordsarecreated test case fail scenario since previous really test anything anymore
intermediate commit fail test case must fix inconsistencies use property record fix comment add command read write size make debug easier remove property command read clear read flip cycle always happen change test makesurerecordsarecreated test case fail scenario since previous really test anything anymore
better syntax
solve bug generator rebuild happen wrong far cause problems luck new property store dynamic store however work pending test temporary fix weird condition light dynamic record append end dynamic store file must revisit remove whole lot comment debug message make code hard read add many assertions help track stuff probably remove beautify point minor white space
solve bug generator rebuild happen wrong far cause problems luck new property store dynamic store however work pending test temporary fix weird condition light dynamic record append end dynamic store file must revisit remove whole lot comment debug message make code hard read add many assertions help track stuff probably remove beautify point minor white space
parameters clauses literals
revert bad merge
add error state manager signal manager put state accept transactions anymore kernelpaniceventhandler listen events log extractor happen attempt extract log non sequential order clear cache workaround bug find apply transaction fully apply remove transaction resource manager next attempt may succeed
add median value time take usage sample every second
add drop menu choose visualization profile
read array dynamic store
various performance relate change property block remove property record soon set use make use field property block useless remove dynamic record delete block move contain property record add log property record position chain change write whole log pointers remove bunch iterators unroll loop store operations
various performance relate change property block remove property record soon set use make use field property block useless remove dynamic record delete block move contain property record add log property record position chain change write whole log pointers remove bunch iterators unroll loop store operations
remove use bits simple place could well save cup cycle
remove use bits simple place could well save cup cycle
change way property record load give option write transaction store reduce workload prepare fix bug property type encode property store remove hardwired short array
start work write properties
merge branch
write chain property record many block single record
work visualization profile add help texts
merge branch
fix functional test
add read flag load property record set false cause write transaction store first record chain save property store get call property block remove property block belong property record always use consider always change property store update record fold back one method writepropertyblock readpropertyblock command store number dynamic record property block int instead byte short circuit circumstances read transaction load properties work two step one load list property record one convert list usual array map write transaction process list write transaction ask load property chain cache first record chain add change property try store new property block first record chain otherwise new record add change break test testpropertyblocks assume whole chain scan find fit
add read flag load property record set false cause write transaction store first record chain save property store get call property block remove property block belong property record always use consider always change property store update record fold back one method writepropertyblock readpropertyblock command store number dynamic record property block int instead byte short circuit circumstances read transaction load properties work two step one load list property record one convert list usual array map write transaction process list write transaction ask load property chain cache first record chain add change property try store new property block first record chain otherwise new record add change break test testpropertyblocks assume whole chain scan find fit
compact string like dynamic string namely latin uhf instead two bytes per char
organize import
always use uhf encode long string well string string internally see one byte per char enough
merge branch ignore test migration test lucent pass bundle store incompatible test generator need aggressive reuse flag constructor generator imply conflict
allow snippet name
add roles domain example
migrate property index well properties
read relationships
property value change write transaction move block new property record return property data object different change test take consideration
fix severe bug property chain handle add extensive assertions comment
ass fix visualization filter
remove unused import
copy property chain creation storage code batchinserterimpl change property interest depend somewhat less hardwired constants remove unused import
fix right graph layout
fix test errors test custom reference node
add son table representation
make possible execution engine find symbols part pattern matcher match
cleanup examples move example class
logical log write dynamic record reason write property store enable lazy load dynamic record data unroll loop write content property block
fishhook take successful argument outcome
check store versions attempt upgrade
minor package rename
add new store set version modify version log version new store file also use constant default new store name
fix bug read properties batch insert primitives properties change mark prop successfully delete chain add new one try keep integrity store specific case
add parameter index lookup example
disable force internal
upgrade store shut cleanly
fix dynamical store via fix short array properly handle length array even though currently store slightly refactored correspond test testdynamicstore add another test length string array good measure
touch exist upgrade backup one already exist
better tolerate run time exceptions commit
expose maid legacyrelationshipstorereader
give progress indication standalone migration
add standalone program use upgrade database version start main server process
add leu cache lucent index writers index searchers
add test trigger cache bug see ticket
add timestamps start prepare commit record incremented log format version
update security docs make fact security rule plugins consistent regular advice run proxy server front
add test case protocol version mismatch implement correct failure response server mismatch
fix issue deprecate configuration parameters support
create performance test
add two test store upgrade embeddedgraphdatabase check proper failure upgrade non cleanly shutdown databases single corrupt file add utility method create store expose set file legacy store upgradable database
add record new store store current store version string encode long latin info store store rest field update match new store use field detect old version uncleanly shutdown store test functionality remove unused import
add startup log store store version high better memory info
docs format
test case property persistence batch insert via end imply
intermediate commit improve node property code
translate admin cucumber test unit test
refactored record store allow create diff store implementation verify commit transaction
fix problem prepare transactions present global log always invoke recover know resources check ownership transaction follow rollback transaction need
merge branch
set pom allow run new unit base driver test properly
update allow run driver different browsers
force record able read break record
add methods record store get information record size
force record return empty record record exist request higher high
add relationship example close
add remain miss functionality set remove properties add test add java docs
merge branch
update version snapshot
fix script format resolve nod
fix depth edge case close
documentation text change
flexible creation multiple lbs time
get rid file update coffee script build plugin mini aggregate file cut build time sec
comment
make several test class share one server
change parse regular expressions lazy eager fix issue
fix bug parameters regex pattern match
update brew plugin fix problem break admin
add support graph properties
fix filter issue relationship filter
change word documentation
get site java doc generation work man
add cypher query support data browser
comment
make entire rep man compatible moment need install goal work properly workaround unpack dependencies add
fix malformed cml
literals real type
prepare move execution result execution plan
revert accidental deprecation getreferencenode
refactored fig distribution part make unfinished transaction cleanup threshold use client lock timeout resolve hack fig
use lock read timeout old channel checker addition old transaction checker
add logic use order aggregation possible
correct expire event handle instead restart zookeeper client whole broker restart new master call lead proper reconnect quorum parse possibly update cluster state
expose
basic functionality index put absent
fix issue dual start entry roll back
add format
tighter test expose problem reveal getorcreatetest testoptimisticcreation
use provide give cache entities issue heavy transaction load clear cache right middle infrastructure still value provide initialize update instead load demand first request use
refactored matrix example capture output
add progress indicator end unknown
update shell accept cypher query start cypher
update
add possible registration udo ping
broker completely shutdown store copy master elections interrupt worse start new parallel copy store copy temporarily store sandboxes directory move main successful copy test case
restructure use configuration interfaces less remove necessary life cycle class add proper life cycle support service lot lot cleanups main driver richard berg
restructure use configuration interfaces less remove necessary life cycle class add proper life cycle support service lot lot cleanups main driver richard berg
fix
security rule implementations use simple wildcards allow whole sub paths uris cover rule
big refactoring execution plan build
add recovery verifier verify recover transaction
make source code link examples obvious remove unused test
add logic stop execution animal run forever shortest builder solve one shortest path per invocation
add two nod two graph ancestors state plus new test
incremental backups litter stale log file keep latest one
add new field result order lucent query name score hold score result resolve refactored slightly make current couple order score inclusion explicit readable test
fix array properties serialize son correctly
make sure filesystemabstraction use place file system access still place file use directly believe notably filesystemabstraction use generators also fix minor issue ephemeralfilesystemabstraction order use generators ephemeral rechannel read byte buffer follow contract readable rechannel try lock use internal lock code directly avoid leak actual
introduce graphdatabasefactory graphdatabasebuilder graphdatabasesetting reference embeddedgraphdatabase impermanentgraphdatabase etc replace factory code
fix better assertion
implement graphdatabasefactory graphdatabasebuilder settings use everywhere
merge branch
use legacy unit apr work older versions unit
extract cluster receiver interface response receiver interface deal cluster events refactored around cherry pick commit deaeeaefbbbcad
update change log
remove use common factories defaulylogbufferfactory direct instantiation defaultlogbufferfactory
rename graph databases graphdatabaseapi reflect usage better make methods deprecate instead interface add proper apr methods
add simple matcher
add lock free atomic array cache avoid trigger full gas add monitor keep track much jim block application thread
make things compile
add test expose match problem
move fig relate stuff separate package udo graphdatabasesetting base settings
add java doc fig move life cycle package
replace array map chm
fix guard implementation limit operations count run time set insert guard true enable node relationship access call guard check guard start use link maxoperationstoperform guard stop timeout ops count reach guard exception throw
refactored test introduce clear entry point manipulate ems allow better control errors occur also make test resilient failures
merge remote track branch
create settings class extensions allow kernel extensions specify settings class add size duration accessory fig use graphdatabasefactory settings many place possible add embeddeddatabaserule handle graph database test add graphtransactionrule handle graph transactions test update processor panhandler easier use remove ancient standalone shell update settings name conventions
create settings class extensions allow kernel extensions specify settings class add size duration accessory fig use graphdatabasefactory settings many place possible add embeddeddatabaserule handle graph database test add graphtransactionrule handle graph transactions test update processor panhandler easier use remove ancient standalone shell update settings name conventions
merge remote track branch
refactored easier read test assert
license headers
load system properties part configuration log service classic log back implementations move udo use new fig style much possible
load system properties part configuration log service classic log back implementations move udo use new fig style much possible
fix issue generators aggressive reuse enable read batch write session
skip stream transactions update back originate slave
delete non exist index return close
semicolons use mark end cypher query shell treat create start query
server disallow create index empty name close
add test case make sure use unique nod work batch apr
merge branch
merge pull request remove old ski stuff
follow name change
merge branch
byte properties handle differently analyse bite pack due unlikely ness deflate also cost analyse size array big store format change write performance time higher read performance time higher test machine get close byte property performance versions
add rest support manage auto index fix
add live console cypher docs
follow manual change
terrible terrible things look
add set windows test well
fix boss class load compatibility service loader
remove unused fig node manager add test systempropertiesconfiguration add descriptions settings clean fig even add unit rule run impermanentgraphdatabase
graph shut one test could cause others fail sometimes windows
revert revert merge pull request revert commit
modify multiple cluster single zoo cluster test leak run databases failure
disable unsuitable log directory test windows since apparently create unsuitable directory windows add test invalid log directory also
clean cleanup
add stream result help batch operations
change methods relationship expander use
typo
update change log
fix
second attempt previous attempt abeabcfddbadefecc break build get revert efecaaededfffcdcab sessions live server mean hold type object serial table need come feature hold result cypher query one drawback clients session variables lose reconnect server however initial session variables give start client set new session reconnect
add new kind cache clock cache try mimic leu less synchronization test case use implement index searcher index writer cache tend behave like current leu base ones better synchronization behavior use lucinda source place exist solution base remove synchronization make common get paths index readers write lock free
console admin disable
improve pattern error message
expand configuration graphdatabasesetting instance responsible convert raw string properties higher level type fig single get method specialize get methods deprecate migration old configuration specify settings class pick apply fig class default handle fig class fig instantiate constructor allow act single source truth store directory center
configuration validation time new configuration change apply
boss class loader remove content meta inf service thread current thread getcontextclassloader default time neon class use load class service class call try find service descriptions use context class loader therefore application create instance graph database deploy separate boss module find custom service define module affect neon connector spring well propose patch try load service use context class loader first break exist code rely current behavior service find use class loader load neon kernel
test case property assert stuff add assertions test case depend throw exception failure change support method return extra info need
enable fig asci doc generator part main build
use eng version illustration home output
configurable amount logical log keep example number days size disk keep logical log configuration extend support value days size regardless configuration always least latest non empty logical log leave
fix miss dependencies report correctly query relate set delete
add rest support get conflict unique index
clean code
mostly log improvement make easier tell wrong something wrong
make attribute open server builder allow sub class make enterpriseserverbuilder
enterprise server use new preflight task startup check override default startup timeout set infinite server mode
commit pom versions snapshot
turn enough impermanentgraphdatabase test
two fix add workaround cause set rollback exception multiple failures occur synchronizations run commit aggregate multiplecauseexception
add test verify jota transaction manager work neon fix rollbacks work specifically change lock use give transaction whenever possible rather discard trust manager keep track
add test verify jota transaction manager work neon fix rollbacks work specifically change lock use give transaction whenever possible rather discard trust manager keep track
add graph viz option support java well use one place
include server startup log message
bump application protocol version since new call push transactions add need increase application protocol arise commit also introduce compatibility layer cluster
revert abstractgraphdatabase new common super type abstractgraphdatabase highlyavailablegraphdatabase motivation users build neon depend internal abstractgraphdatabase type since highlyavailablegraphdatabase stop extend abstractgraphdatabase need new type avoid break backwards compatibility users old abstractgraphdatabase rename internalabstractgraphdatabase new abstractgraphdatabase fully qualify name old abstractgraphdatabase make binary compatible consume class abstractgraphdatabase define public methods internalabstractgraphdatabase ensure exist consumer abstractgraphdatabase work without change highlyavailablegraphdatabase delegate transaction run local database instance transaction run deprecate preparation removal later version revert type abstractgraphdatabase type field previously change graphdatabaseapi revert type name signature previous type preserve backwards compatibility also change usages field use get graph access recommend deprecation comment
placebo transaction behavior longer cache internalabstractgraphdatabase unique factory cypher transaction commit failure handle commit pipe
tidy transaction rollback
change transaction take around unique index open transaction late possible check entity exist index
possible use log extractor things none
make possible hardwired ability halt operation master would downgrade cluster elect introduce downgrade barrier masterclientresolver enable make downgrade master client factory impossible enable barrier startup complete compatibility mode work upgrade possible downgrade halt cluster test internal rename masterclientresolver protocol combo protocolversioncombo
land mia ski index apr get create semantics work batch apr close
cleanup configuration apr configuration stuff backwards compatible short three small items risk cost ratio three favor keep way
new consistency checker extract backup promote module decompose number smaller class verify large number new unit test detect wider range possible store inconsistencies commit also include new window pool implementation design perform better default implementation store subject linear scan occur consistency check develop test tobias linda alistair jones
add information disk space store partition local time zone store file modification date address interfaces
fix break windows build remove race condition startup timeout test
add travis info
enable polo map server add test
add percentile aggregation function
support code new consistency checker improve progress report helpers interfaces allow alternative window pool implementations settings concern new window pool implementation
make get write public
pass tune configuration consistency check make command line tool accept new option fig make tool throw exceptions instead immediate system exit move consistency check settings class correctly apply default extract consistencycheckservice consistencychecktool testable follow pattern backup tool review lapse west nielsen
import
refactored log error handle handle run disk errors throw appropriate exception run disk write logical log exception end get handle elaborate error handle mechanism manager also refactored logically strategy copy transactions new log rotation handle class cover unit test let remove one breakpoints base test neon sub project commit follow second refactoring later next week usages receive protection add logical log implementation
refactoring
refactoring expressions work expressions use function give map string object return value lead problems parameters encode use magic string map expression take execution context instead allow parameters store side side result refactoring name paths treat query object pattern duplicate name path declare pattern items contain place name path field also pattern field name paths come multiple place days match
bring docs date life without cherry pick commit aeefacbdfbfdcaeb
consistency checker memory awareness multi pass execution order take account available map memory ensure pass check record could load map regions store much larger ram pass require total check time reduce fix cache replacement algorithm pointers correctly update remove page head list
introduce naxos state machine new version high availability depend master election introduce cluster component encapsulate cluster relate functionality create run connect state machine implement naxos timeouts heartbeats deliver events around drastically change design use remove zookeeper completely highly available graph database break smaller components listen events cluster layer react accordingly take master slave roles mode switch master slave perform state machine allow intermediate state exist broadcast events happen backup update work change bean update provide information relevant new state things author sanders haworth john venison matthias person richard berg chris gibran
add master election bare bone test
accurate progress report multi pass check
update javascript engine incorporate improve level san box
commit pom versions release
ensure loggers use consistency check flush
move share logic commonly refer cluster client cluster client class reduce code graphic well backup tool also use properly expose correct information build stand alone cluster client jar author chris gibran
previous class cluster slave instead full member list status also implement change bean cluster member rename highavailabilitymember similar confuse cluster cluster term separate aspects
use testgraphdatabasefactory create impermanent
fix learner catch issue clean log log log class category
fix build issue relate test dir delete impermanent graph database
add test ensure auto index configuration persist across master switch
merge branch
couple optimizations regard read performance cache refer relationship type instead string binary search sort array find properties relationship type cache less object instantiate get iterate relationships reduce number map lookup significantly get property call especially outside transaction transactions without change previously lookup whereof synchronize low use thread local mapper thread transaction refactored lock releaser transaction state associate transaction instead
fix build
update set apr accessible settings old graphdatabasesetting class wrappers settings instance settings file file internal use overhaul use file instead string many place possible settings introduce separate gds udo settings reintroduce appropriate check usage whether class path host report introduce domain value host port host port port range functional program use appropriate function function helpers function specification remove favor predicate specifications rename predicate
fix concurrency problems fig class add concurrent hammer test ensure property read write well listener read write thread safe
able pass initialbranchstate traversal star
preliminary fix get snapshot synchronization place
add jim compatibility check embed use
change initial feedback remove old conflict code comment use array binary search instead temporary solution copy code modify change name inter iterator something appropriate rename method remove necessary manager init code
merge branch also implement snapshot synchronization
fix problems use pattern multiple unnamed nod use unnamed number parser versions pattern class custom equal method ignore unnamed number lead bug pattern multiple unnamed pattern relationships drop user get connect pattern exception fix ignore unnamed number equality check unfortunately lead test specific parsers many new test add cypher retest
fix listener addition removal try get listeners events register init remove shutdown make nasty bug away ensure events receive longer handle fix cluster client life add init miss allow cluster client add life soon create touch test
merge branch also implement snapshot synchronization update service
merge branch
unused import
make sure auto index remove graph elements index delete
revert revert performance test add recently build cleanly revert commit
pass log instance grab correct logger
remove performance framework build temporarily
instantiate generator get argument externally look high normally base store file size help high slave haidgeneratorfactory control directly highavailabilitymodeswitcher instead independent listener since order dependency two also simplify state logic switch master slave mode author chris gibran
hexadecimal short string encode decode implementation
rename smoke test robustness need run time
bug fix fail encode short string character greater
always output diagnostics
fix issue backup announce properly
cluster manager additions start standalone cluster clients test pad cluster cluster client make number members uneven break tie vote add standalone cluster client main class fit use together neon server general revive neon coordinator script start standalone cluster client consistent fig templates
refactoring pull gremlin shell separate plugin make session creators discoverable via service loaders move representation logic plugin move test adapt test documentation adjust non compile file add server fig enable gremlin shell
fix udo registration set name test
clean log fig bite make stuff verbose track cause errors better
fix cypher bug sub string length specify
rename message older process offer remind queue pretty much
clarify java requirement
use full bits keep type value
add license header
resurrect test temporarily remove fix issue new test discover cache content index store instance could become stale copy new store master solve invalidate index lock index lock silently ignore scenario make index put absent atomic
invoke unlock even error handle persistence row
make use target directory bootstrapped test
clean log
fix pattern produce unexpected traversal state cypher
fix custom similarity use query
explicitly mark start entry write avoid whole class bug regard duplicate start entries
property key create like relationship type unique transaction
docs format
merge pull request make sure text output return query documentation
add label clause cypher
move responsibility list root service offer root service module new server reason capabilities add server across versions change root service responsible advertise root service determine add get service new server provide default implementation community server remove list root service make community server init public test work update test white space
label
initial work connect bean apr kernel apr
flight commit
cypher retests green
make possible run parser concurrently
tell user snapshot build snapshot build convenient people test bug fix inherent risk people use bad commit look snapshot versions heroically warn user also pick stray snapshot versions release time
add label docs
remove synchronize array map favor thread local
improve flaw version regex test break
add support cluster discovery concurrently start instance instance try join cluster notify instance fig instead one time wait configuration request cluster join instance receive join request join fail configure instance ones make contact join try slightly edit commit richard berg
transaction manager forward original cause crash subsequent call add original error cause system exceptions throw
fix set basic bug use instead equal string comparison declare public static field final assume uhf default string encode
add ignore test case negative index size
revert revert kernel apr able remove label nod revert commit commit include fix problems revert ensure statements close place common toilet transaction finish transaction manager begin
fix incorrect cypher documentation link
success flag query context close honour
revert reactors jar dependencies correspond profile top level pom revert commit propose solution work peculiarities combo
transaction state stat context take account delegate whether label already return correct result add remove label node
add schema store dynamic store store arbitrary schema rule currently index rule full logical support integrate kernel
update community regard doc build point top level
add support set label via rest overwrite add miss docs page
introduce fix cache poison issue observe node next relationship load delete introduce method transaction state patchdeletedrelationshipnodes concrete implementation node manager fix reach disposition affect nod cache use method relationship delete namely command application write transaction prepare ignore previously introduce test reproduce bug
cypher use label specify match
expose problem introduce commit adfcaeaddfcbf
improve path expression support label
add test label
add ability add heartbeat listeners heartbeat state machine initialize author part
rename coordinatorincapablecredentialsprovider notelecteableelectioncredentialsprovider introduce notelectableelectioncredentials use new provider replace instance old class new introduce new utility method cluster manager start cluster arbiters small fix cluster manager author part
enable slave functionality cluster members introduce slave set set make use notelectableelectioncredentials cluster client implement election election expand perform elections correspond message add election message handle election state handle consist hold election currently know roles election state election longer back counter instead timeout set first instance list instance expect perform election timeout second one try etc add test slave functionality author part
disable test break manual
merge branch
label store node record integrate work solution store node label node record record space enough spill dynamic array store dedicate node label java docs store migration create node label store lazily allow bridge real migration place increments logical log format version also require migration support migrate previous store format right leave state current migration migrate next previous store format current bite odd
license header
merge pull request use git get git describe kernel version
remove old stuff temporary label properties solution
add first version index population service job create index
fix regression backup snapshots cluster state since slave functionality modifications request explicitly backup client
fix miss dependency mock
add store lock databases access set file sit time prevent corruptions lucent see customer use
change around shell variable handle export databases cypher result general shell improvements welcome message command mode also configurable quiet true shell variables pass cypher query parameters allow son shell variable value map array etc dump command export sub graph cypher statement reassign shell variables export export shell execute content file directly file faster pip via stout enforce shell variables name valid identifiers
change cypher merge type
merge pull request fix typo
merge change
add drop index kernel introduce diff set testate helper class
modify upgrade code give specific error unable upgrade
merge branch
multiple fix update cypher profile add support cypher profile rest introduce simple retype plan descriptions reactors plan description simple render add test add unit test profile make pipe explicit input iterators
write state property record logical log remove value infer command directly physical logical property change converter
merge master
merge branch
statement context refactoring index rule interaction use index rule object directly
fix test problem
add support forward host forward pro headers allow parameter use link data host behind proxy servers
merge commit bibb bibb merge merge branch
fix array value son object get properly convert java array store neon
move neon server jetty
upgrade lucent version
add index hint cypher
update contributor list
rewrite flaky test
schema index change remove scheme provider mutable state cancel index population job initiate cancel await completion happen outside flip lock resolve deadlock issue minor index popular interface change nice future latch utilities test happen index population job switch role add contract check index context
intermediate implementation index lookup cypher index hint lead label scan one index apply query use automatically without index hint two ignore test turn kernel apr expose index read capabilities
remove stack trace print
refactored recovery schema index make index recovery contract check compliant remove usages index rule index cake introduce index descriptor get descriptor index cake clean index service remove internal estate non existent yet logical difference populate
merge branch
implement index accessory back lucent fix race condition flippableindexcontext close compete flip close flip would result open flip target index context close
documentation cleanup
integrate read schema index kernel apr
change within transaction visible index query add getnodepropertyvalue kernel leave throw unsupported operation outsiders testate bridge old state outside behave transaction state leave old bridge transaction context remove favor state delegate instead
dependency resolver get overload method additional selection strategy argument customize selection strategy multiple candidates available
centralise lucent version
move success failure finish prepare commit rollback transaction context pave way road
fix integration test state index query
remove urls discovery mechanism cluster
upgrade store format format node store rewrite new format store copy new version trailer remove code test applicable older neon versions centralize legacy store file name version logic verify logical log back leave work directory
cypher errors show nicely admin data browser
add detection full incremental backup deprecate full incremental flag backup tool
recover miss brand soften color ass complete tour learn develop guide collapse participate read explore guide page community videos book change group photo tweak font size base media query typical projector size improve media query size guide still issue improve responsive layout revise connection lose use show hide instead add remove
prepare cypher new plan cache add legacy operations statement context operate legacy index refactored traversalmatcherbuilder legacy builder plan builder transactionboundplancontext get statement context outside implement ability query context upgrade lockingquerycontext transactionboundquerycontext take statement context transaction outside remove get transaction query context
add support
add schema state support kernel add transactionawareschemastateholder plug cake extract updateableschemastateholder polish test fix transactional flush handle add schema state handle test schemastateoperationstest defer schema state flush index come online make population job add leu eviction schema state remove class usage change concurrency schema state handle rename remove legacy index stuff kernel apr schema state interface refactoring context support
ensure dynamic properties load create nodepropertyupdates
cypher handle pattern without start clause start rewrite documentation use start handle type pattern without start
combine medics autocrat path file system abstraction
change error report mechanism store lock boolean exception remove print trace life support introduce mistake error startup show nest exception message without stack trace
make ephemeral system keep track directories
minor cypher kernel fix bring plan flush fix label function readonlystatementcontext work schema state cypher try use populate index
add internal support run transactions via rest apr introduce new transactional endpoint support cypher per design discussion ian tobias use stream son serialization serialization order support handle errors occur stream result start include configurable transaction timeout default second use new kernel apr create statement context statement transaction management latter wrap transaction context decorator necessary fiddle manager compare performance jetty jetty ser let jetty ser let jersey noticeable difference find high level jersey approach include documentation use apr design overview transactional service transactional action kernel execution engine transaction registry timeout ask transactional service handle help abstraction delegate incoming request appropriate transactional action methods include wrap incoming stream serialization serialization class transactional action handle domain logic create store commit roll back transactions well execute statements kernel actually wrap class call implement kernel interface add decorators hide current messiness transaction management rest implementation abstraction leak slightly transaction registry could find way around transaction registry store transactions currently open unused thread safe way call intermittently external task handle kernels job scheduler ask registry evict transactions idle longer user define threshold miss statement context yet pass cypher mechanism create place separate commit make appropriate change cypher provide inject statement context detail overview apr work please refer transaction functionalist integration test
change timestamp
introduce pseudo quorum write move synthetic instance ids fix concurrent instance startup move fri instance identification instance class base integer move server settings cluster settings network instance accept one listener need receive executor message processors form pipeline allow stop message via return boolean status flag cluster join change majority instance need reachable cluster form also lot bug fix around concurrent instance startup rename clustermemberlistener master select clustermemberlistener coordinator select add members live fix propose state patch pending instance correct set acceptors cluster configuration change happen stop time propose phase failures atomicbroadcaststate longer explicitly retry timeout simply wait propose complete cluster join explicitly deny via new join deny message use shut instance server use add heartbeatcontexttest slight fix heartbeat context reveal test hamm take care receive member fail members live events broadcast pending state election respectively quorum author richard berg chris gibran
ignore test
test cleanup fix remove robustness useful anymore simulate cronies rename testpaxosclusterevents testbasichaoperations descriptive testinstancejoin deletion test properly wait instance form cluster
fix issue batch insertion exist would delete index batch insertion exist database contain index index rather configuration well existence lbs nov would delete use second batch insertion index configuration would overwrite whatever second batch insertion problem exist index configuration read call index store start shut end write index configuration exist would lose fix
add log schema index startup
fix concurrency issue statementcontextowner kernel single statementcontextowner instance share among thread access read statement contexts yet statementcontextowner consider concurrency add test case show problem well fix kernel use instead single statementcontextowner
merge pull request fix issue around migration
remove mistakenly add module reference
remove high cluster join timeout cluster test
fix problem consistency check orphan properties incremental backup
check original log file exist try copy
store upgrade minor cleanup remove unused slog field constructor parameter use filesystemabstraction instead unsafe file
batch insert support label schema index create nod label add label remove label list label node create schema index schema index populate batch insert shutdown support except create new schema index batch database define constants error message avoid break test update batchinsertdoctest
merge branch
graphdatabasefactory isolate builder term factory state introduce graphdatabasefactorystate setters return subtype graphdatabasefactory call chain disable check graphdatabasefactory click break change
remove label choice syntax
fix uhf issue server integration test
merge branch
sort property key properties appear predictable order
fix pass array properties unique node creation make sure collections supply properties convert array like place rest apr
find bug fix
import
rest transactions improve result serialisation improve unit test executionresultserializer redesign executionresultserializer
extend shell support basic label index functionality list label set add label use option remove label use option schema list index also await index come online add schema command list await index
log serialisation errors instead print trace
rest transactions error handle serialize stack trace internal errors reorganise error cod rename new error subclasses match status code name rename status code stop new error extend explicit functional test response format cypher syntax errors
speed test auto configuration add proper unit test test auto configuration configure memory map much smaller test previous integration test make sure auto configure value make actual configuration
add xor predicate
merge pull request add parser version enumeration
merge remote track branch
initial peg parser cypher
code cleanup clean high pro find bug warn remove unnecessary modifiers field interfaces report
make possible return query cypher
fix issue property inconsistently light heavy write log load property record change linkage pointers value record also load make heavy trip assumption write record logical log commit would see property block heavy get data write null see writetransactiontest change linkage detail
import
add scala style plugin cypher scala style run default run explicitly man decal style scala style check run part verify man decal style verify fig need tweak
ensure read access persistence windows byte buffer interfere flush duplicate first ensure access logical log rotation synchronise resource manager remove direct call
ensure persistence windows change buffer flag state flush
induce cleanup
cleanup service register resources inside transaction methods return resource iterator still actual return iterator may register cleanup call make inside transaction transaction close statement contexts resource would unnecessary strain cleanup service
startup sequence change proper management errors node manager start node manager longer update state datasourceregistrationlistener start properly fail case recovery nioneodatasource complete properly iago startup sequence change node manager start kernel extensions register data source recover index providers kernel extensions days propertied manager life cycle control iago node manager change ham ensure correct life cycle management also ensure store always present instead wait one master start anything slight cleanup comment code redundant method override white space
test rule mute err test failure happen useful server test chatty console many test mute rule still line print might break back hunt give time spend pretty good coverage mute
add ability create drop uniqueness constraints via graphdatabaseservice add constraint creator schema add constraint definition well sub interfaces specific constraint type add createdeferreduniquenessconstraint batch insert reactors index creators use internals emanations well
merge pull request allow multiple parsers semantically test
merge pull request restructure interaction manager kernel
add rest apr constraint handle rest apr get post delete constraints add constraint type end constraint definition change create constraint twice constraint violation add cox get constraints test proper testate handle various get constrain methods
introduce work around remove orphan constraint index need improve since workaround
make graph database give helpful message shutdown remove throw exception neostorexadatasource constructor true make threadtostatementcontextbridge implement life cycle tell shutdown kernel keep track shutdown state throw appropriate exception use
minor work around list constraints awaitindexesonline add schemaacceptancetest get constraints add add constraint type filter favor expose predicate public apr
provide apply method collection type
merge branch
reduce garbage leave behind top red file location impermanent supply directory make open always fail create one extra red invalid file directory test clean generally make sure test create temp file delete
install cucumber gem run cucumber test build machine use rom prevent gem installation affect job
add process dump hang test move dumpprocessinformation robustness add dumpprocessinformationrule make easy use
add see available predicate use predicate haber nit
merge caefbaeaafdabdea
support chain certificate
property key migrate older format kernel apr assume single name map property key store prior might property key one attach prevent happen remove duplications migration process might upgrade store problem still guard property key token holder get functionality return tokens give name one commit also remove extra functionality way duplicate exist read anymore migration compact property key store since property store scan update property key deduce migration anyway also clean around token class holders add one token class represent name use almost everywhere instead separate duplicate token class also make token older manage token subclasses thereof simplify implementation reduce need sub class
add merge cypher command neon shell
increase guard timeout test way less flaky windows
enforce uniqueness constraints lucent index implementation still miss case rudimentary case work add check update still miss introduce infrastructure group together compatibility feature set test suit use index compatibility test suite allow index provider extend single test class order verify compatibility scheme provider apr
add label scan hint cypher
merge pull request spring clean
fix inconsistent behaviour use order limit update graph change priority order limit execute update graph change topic builder wait aggregation return expressions execution updateactionbuilder wait slice accept work slice builder wait update
document keep alive include new timeout response report new expire time refresh transaction timeout due stream result new expiry time set header update documentation ensure rollback suspend call minimum timeout add sleep two test due textual timestamp format second resolution use rec format similar establish help expire header
merge branch
throw better exception cypher fail create constraint change execution engine method signatures explicitly throw cypher exception instead syntax exception avoid throw kernel exceptions public apis add new schemamodificationexception super type several relate exceptions try match cypher syntax exception message restructure kernel exceptions express constraint violation semantics rename dataintegritykernelexception schemakernelexception break subclasses schemakernelexception file package move kernel exception class dedicate exceptions package introduce use message responsibility kernel exception kenya lookup safe subset korea operations suitable prepare user message
adhere name conventions statement context name convention introduce prominent entity method deal name first method name rationale behind group methods name facilitate tab completion add documentation explain name scheme statement context interface
ensure property methods proxy statement context also implement array properties
remove default message status code errors require exception exception include message avoid low value duplicate text message send user add new map couldnotcreateconstraintexception could create constraint
testate support property operations rename propertyoperationtranslation statehandlingstmctx inherit testate support track create remove relationship support track property update nod relationships relationship set remove property return previous property return previous value add add remove unused methods storestatementcontext move store translation store context
exception handle check exceptions get throw unsafe way
move primitive property operations kernel apr introduce aux store integration property data property merge two cache use cache even label close complete move make sure property data geoid use trust anymore lock acquire change whether testpropertycachepoisoning testpropertydatarace able tell ignore potentially rewrite plug legacy auto index kernel
merge remote track branch
fix break syntax docs
add simple benchmarks
fix race condition get relationship add test check duplicate entries iterator return get relationship iterator contain multiple identical entries silently swallow barf return first user expect note commit bite band aid since really need proper isolation kernel test code likely remove future state
check context aggregate function
ensure predicate apply match currently null check separately inconsistent normalize behaviour
allow use separator
token name allow empty
enable stream support page traversals seem stream page traversals work fact code never write enable look like bug outside actually simply miss implementation listen representation represent son list get return get run standard output matter
merge pull request add list comprehension syntax
change property equality semantics instead rely java definition equality commit change compare value long int short byte double float equal string char also comparable also contain necessary change make sure index follow semantics
make query context partially kernel apr make property use property eye make remove property use property eye make cypher delete entity operations kernel introduce token context share trait plan query context enhance token type key token provide geoid get pay get create functionality make delete action take key token argument support resolve property key plan build time make use key token property key make cypher set property operation kernel replace prior label resolution make closable iterator always return map materialize stream make cypher get property kernel apr make dump string reopen query context need rewrite mappropertysetaction
tag version
index population failures retrieve later confusion role say index fail state also sometimes cause failure keep index population fail index put fail state schema index provider responsible keep failure cause well able return later
merge remote track branch
make sub interfaces statement context speak let implementations previously compositestatementcontext one sub interfaces instead benefit cake deflate delegate delegate pure delegate delegations actual implementations moment incur higher cost create statement context much lower interact context next step probably reduce amount statement contexts create
consistency check node label add test exist label token store check rename exist class test infrastructure reduce confusion check inline label ids check duplicate label node check reference use label token record check dynamic label ids verify dynamic label record use cycle free encapsulate record allocation dynamicrecordallocator interface allow test reproduce array store layout without need real store restructure nodelabelrecordlogic use polymorphism remove repetitive conditional logic reduce couple field format node store extract label array manipulation label array utility
update test run assertions transaction better format property matcher description
write modify persistence windows abstractpersistencewindow
move creation failure storage luceneindexpopulator create avoid leave bad state fail constructor
make statement context stateless split operations state statement context previously consist operations well state due fact full statement context instance would create per statement see creation statement contexts expensive different approach need statement context rename statement operations state less methods accept statement state object first argument statement state instance pass contain state need participate layer underneath statement operations
remove operators cypher miss properties treat null
merge pull request deflation split statement context
couple performance improvements create use primitively iterator getpropertykeys use well use individual statement operation part remove tiny statement operations delegation top testate change cheaper statehandlingstatementoperations getpropertykeys get property delegate change
consistency check make store skip safer skip store ultimately cover simplify inheritance hierarchy remove implicit couple cache non cache implementations diffract access
make sergeant parser concern
follow new name convention kernel transaction instead transaction context
add consistency check schema rule verify rule desert liable verify rule use know valid kind verify reference label verify reference property key tokens introduce malformedschemaruleexception verify rule obligations match introduce schema content semantically compare schema rule verify schema contain rule content properly handle constrain rule without constraint
add support consistency check schema rule incremental checker check schema rule full check schema store introduce schema access interface load schema rule introduce abs abstract store descendants except new store add record get record record store getnextrecordreference
simple neon desktop app launch one neon server database inside jim point database choice build one user jar everything ability tweak heap size launch jim require restart ability tweak database properties use convention support server extensions look also add guy configure package contain resources mount server add system tray integration window close button press database stop neon desktop app shut fully database state app minimize tray click tray reveal simplest possible integration start author matthias person author alistair jones author lapse west nielsen
add create unique experimental parser
mandatory transactions server ensure test create transactions appropriate ensure restfulgraphdatabase batchoperationsservice cypher service wrap transaction filter ensure stream output write transaction filter finish transaction
delete deprecate code old consistency checker add consistency check label token label token name store rename old usages relationship label relationship type rename old usages name token
unused import
merge pull request update deprecation text
fix wrong content encode instead content type char set uhf
check server start start server test make error message bite explicit already neon instance run local host
check server start start server test make error message bite explicit already neon instance run local host
orphan check node dynamic label
cheaper statement state ref count cheaper ref count referencecountingstatementoperations add share statement state instance among potentially multiple consumers individually close statement state actually close ref count reach previously new reference statement state return share instance single reason prevent fast fail close give statement state instance multiple time check close keep mind kernel internal apr check merely exist debug purpose debug run time production see performance benchmarks statement state instance costly commit return reference statement state inc dec ref counter share instance gain performance statements owners move threadtostatementcontextbridge since functionality specific core apr threadtostatementcontextbridge specific core apr
make nodesgetforlabel return primitively iterator introduce helpers map filter primitively iterator add
add test clarify semantics filter add elements source
merge pull request fix wrong content encode instead content type
make nodesgetfromindexlookup return primitively iterator introduce neojmockitohelpers answer primitive answer make return primitively iterator introduce javaconversionsupport convert primitively iterator scala iterators delete unused primitiveiteratorutil replace use hit iterator primitively iterator hit
remove redundant relationship strip lock strip lock functionality move new class jockstrap cache logic load relationships change even cache get extend lock double lock every load relationship complete change remove code getrelationshipforproxy move jockstrap cache
merge remote track branch
make return primitively iterator
remove unused import file java find check style fix warn
heartbeat processor ignore message join cluster refresh snapshot join cluster
fix descriptive error message miss cache type
mandatory transactions call graphdatabaseservice still node relationship facades index schema
override store location avoid pollute work directory create ignore directory directory clean build cycle therefore cause store upgrade failures run test switch branch
ignore test expect rewrite
make row cypher result take form row preparation include graph structure information stream result element stream contain information contain stream contain heterogeneous set elements everything row conform column format
merge remote track branch
make indexpopulationjob log label name property key name instead ids hook tokennamelookupprovider formerly keynamelookupprovider index service construct iago pass via neostorexadatasource also make available kernel live eventually rename methods match kernel apr name scheme fix luceneindexrecoveryit clean error handle flippableindexproxy
serve static content war content make jetty extract content temporary directory eliminate linear scan synchronize regions slow load static file serve content within jar file
correct spell mistake comment
update docs reflect transactions mandatory everywhere
merge pull request fix
neon edition version server gather neon edition look type new server get start gather release number meter way deep kernel add test enterprise check name derive class abstract server change since version edition service use name compute neon version rename server builder communityserverbuilder add advancedserverbuilder enterpriseserverbuilder add integration test community advance enterprise version edition service match module
auto configuration handle case physical memory jim memory
fix issue slave generator introduce test introduce bunch test slave generator verify correct operation fix bug might lead loss data race transaction application allocation small touch code generator imply
rename current experimental parser
fix
fix
merge pull request fix
merge branch
neon backup exit status case foreign destination
introduce unbind value keep track miss optional nod convert unbind value null equality behave correctly compare unbind value
validate uniqueness constraints new data first attempt take lock consider one many potential violation scenarios
validate uniqueness constraints new data validate add label node
validate uniqueness constraints new data support concurrent update data affect constraints different instance cluster acquire distribute lock ensure mutual exclusion
use lenientobjectinputstream one place need call part code new cluster member first get snapshot detail member available message happen elsewhere cluster beforehand
avoid exceptions property object know value set property know property value use sub type safe properties avoid deal potential exceptions know throw
format
introduce label store label store one responsibility able quickly efficiently answer nod particular label update node label change transaction ally generally integrate neon similarly scheme provider kernel extension default implementation use lucent add rebuild recovery phase index back scan store miss corrupt main point integration read label scan store statement operations method nodesgetnodesforlabel entityreadoperastions precise piece code loop node store replace one line ask active label scan store instead also graph database configuration option load kernel extensions remove since many essential kernel extensions make sense run without prior remove scheme provider nothing fail try populate index return use provider load would start work make little sense instead path label scan store option remove exceptions throw startup directly instead fail arbitrary point time database use life cycle change get work rather clean life cycle management neostorexadatasource init previously life init start previously life init recovery life start instantiate new life support life init recovery life start stop previously life stop force force life shutdown shutdown previously life shutdown change work cleaner potentially multiple start stop sequence issue
make indexpopulationfailures print properly resolve label name property key ids
separate data transactions schema transactions also introduce facade layer apr kernel exist operations class statement state use implementation make previous decorator pattern base layer design implementation concern move towards kernel implementation layer different apis different layer layer group separate data transactions schema transactions separate data statement schema statement apr prevent single transaction mix two remove mean access operations outside transaction since transactions mandatory anyhow wire together operations class one place kernel class instead spread multiple implementations kernel transaction interface kernel transaction really one implementation handle transaction logic commit rollback initialize statement state separation data query schema query cypher initial step towards probably take readonlystatementoperations delegate korea operations label property key get ornate correspond get create methods leave caller handle constants assumption caller would deal instead make sure method accept label property eye input deal constants sensible way bite work direction read scenario things work already
update docs avoid call new index schema index
clean query context
transaction compatible try resource transaction interface extend auto loveable make transactions able participate try resource block like try transaction begin operations success finish method deprecate part code still use focus convert code document test code end manual
use one scala version
remove large set deprecate things core apr settings clean deprecate things remove graphdatbaseservice one deprecate method leave get reference
merge pull request transaction compatible try resource
small improvements grammar base rule profile
verbose check test
merge pull request property methods kernel apr
back port neon desktop
traversals execute one statement resources enable produce closable traverse iterators introduce resource extend auto loveable get close method throw check exceptions make sense since resource iterator close method like would like use closable aspect iterator argument previously pass closable auto loveable catch exception throw exception exception would occur course kernel apr statements also extend resource instead auto loveable since statements often use together iterator form resource iterator exception less close method see point information traverse reach end also automatically close rest traversals use single statement since use multiple transactions page result argument prime mechanism high performance traversals via server extensions via rest traversal apr seem worth effort right least implement single statement traversals rest apr
merge two clock interfaces remove unnecessary implementations
add filter allow neon browser license line end
allow cypher read data modify schema transaction achieve delay choice statement type data write schema write specific operations require remove concept query type cypher kernel operations access single statement apr turn expose narrower interface read data write schema write operations statement object need close individual operations object additional state need close
introduce nodegetuniquefromindexlookup introduce node label property key introduce uniqueindexgetforlabelandproperty take index lock nodegetuniquefromindex expose nodegetuniquefromindex cypher exactuniqueindexsearch rename safe property define property
remove property data old property representation move property handle kernel apr fully one aspect incompleteness get old property data class hierarchy use new similar property class hierarchy new code kernel apr property data one geoid method property use anywhere also represent tokens label prop key rel type ids instead long commit change memory representation store format reason long int switch end commit removal property data due hard conflict merge tumble two separate commit commit cleanly apply separately know store construct still store tokens long index rule property key outside look like int put get byte buffer use nodular enfield even outside look like long mostly due wat decide piggy back long label array put node long array first element convert int externally would incur array copy back forth int long protocol master acquireindexentrywritelock still use long change protocol might
disable memory map buffer correct windows
merge pull request neon backup exit status case foreign destination
rest core apis support list store property key
use multiple thread send message one faulty receive instance block message instance convert host name address startup internal logic work
make merge use uniqueness constraints correctly take lock acceptance test merge use constraints introduce schema index schema index start point extend plan context support lookup unique index add support test fail query dot base introduce referencenodeacceptancetest introduce deletereferencenode helper graphdatabasetestbase
enable schema change master cluster remove concept kernel replace schemachangeguard replace readonlystatementoperations guard upgrade transaction data write schema write
avoid index nod twice prior change possible get two index entries case add label set property transaction create node previous transaction would violate constraints silently make inconsistent would cause node return multiple time index lookup resolve gather set update apply index rather list
double elections cluster startup join make election need make explicit election create update log message update editions right format converters
correct result type label function collection string fix
constraint creation cluster protect race condition constraints come online master long enforce slave master reject transactions start constraint bring online initial implementation verify start transactions fail new constraint simply fail reason window milliseconds second occur admin manually bring constraint online felt necessary duplicate constraint validation code
merge pull request remove deprecate finish call
remove legacy parser
clean mostly silly useless comment mostly remove useless comment also remove circuit breaker circuit breaker remove use anywhere code everything private apr delete safe since clients depend peril leave finaltraversalbranch class stay even though really suspect place use obviously break might even use might research look see remove actually want use something also remove unused method node store come across
merge pull request fix full data bug analyse query
allow arguments start shell command take options
support wildcard cluster server
fix inability remove constraints add test verify database block write populate constraint index verify constraint deletion work cluster add test verify new slave join cluster properly initialize constraints add record schema command allow delete schema rule logical log
depend neon browser
fix bug two disconnect pattern
add documentation example merge parameters
change
make index accessory index popular use index updater make indexpopulationjob queue update individually
excpetionhandlingiterable longer use unsafe ugly hack still ugly hack ugly hack use unsafe small improvement really though something fact expect check exceptions miserable methods
allow optional match recognise cypher currently return unsupported semantic error
create new format lucent label store noderangedocumentlabelscanstore overcome document limitation lucent store information label multiple nod lucent document lucent document represent range configurable nod high order bits document contain field label node range value field bitmap bite set node range label present
performance optimizations best first selector mostly revolve around find single paths give good improvement call pathfinder find death graph algorithms use traversal framework specifically bestir selector currently benefit dijkstra although default implementation custom non traversal framework version support single paths anyways already get similar performance behaviour look traversal star version use traversal framework cherry pick commit
add test literals map contain array properties plus fix map representation serialize
make traversal matcher use query traversal matcher fastest matcher available cypher commit make possible matcher take query allow start node strategies use
make index creation idempotent nothing ask create index already exist instead throw assertion error make idempotent
optional match support rectifier
copy index copy store index include file list file copy backup refactored logic list store file class add test copy populate indices integration test multiple use case relate
add information unique index rest apr
work docs around match merge optional match start use
update include single node pattern clarify pattern use
merge remote track branch
introduce cypher commons module move apis
order shutdown properly introduce access guard check begin different reason start might possible database start set state grant deny access implement back atomic integer performance mainly
bump wait time master available second default test fail master available
refactoring
fix flaky shouldnotsnapshotpopulatingindexes test race population job start initially populate state change introduce latch prevent population job complete take snapshot thus ensure index indeed still populate take snapshot
uris volatile risk see correct value read
unused import
unused import
fix bug property record could get one property block key problem setpropertyblock properly remove exist block find correctly find exist block index try remove block understand index key fix use index index remove block index
textual error cod make error cod return transactional endpoint help apr string string error cod several benefit numeric error cod textual error cod descriptive easier search textual error cod also support classification categorization numerical error cod support either one classification would distinction transient permanent error condition example categorization would distinction different error source client side server side different type error syntax errors transaction errors
transactional service handle undeclared check exceptions gracefully
ignore cache dir
delete
cypher move modules community cypher parent
clean constraint definition apr slightly embrace fact good way describe arbitrary predicate definitions
merge branch
get snapshot update sense last deliver instance set test check list like parse able elections ask coordinator vote already vote misc format fix
ensure cluster rule create fresh directory per test method remove unused
make message people need get java bite clearer
cleanup internal class publicly document move publicly document internal class add internal package deprecate publicly document internal class add
remove deprecate methods graphdatabaseapi
fix bug log handle null bytes log file
format change file accord neon code style
fix dangle dynamic label issue give node single dynamic label record remove enough label grade use inline label correctly mark dynamic label record use however remove yet another label logic update node record take account unused dynamic label record would update node record list dynamic label record empty turn lead log command contain information dynamic record set use would subsequently lead dangle label record
consistency checker verify nod node store label scan store
add basic functionality test highavailabilitymemberstatemachine
remove deprecate things remove deprecate constructors embeddedreadonlygraphdatabase remove unused set online backup
read non recover store file recovery read store file safe since might inconsistent state store complete recovery phase transaction log contain information data change though rebuild index require read store file change defer read store file purpose rebuild index keep run set nod update command recovery process end recovery drop information nod index rebuild read current final consistent stable state change node store file
move ownership fig run neon server server rather iago introduce new constructors embed highly available impermanent graph databases allow pass fig directly add factory class since mean user face feature refactored new server database relate class take advantage allow inject fig database use overall move towards consolidate fig whole product eventually move use single fig file also move towards structure application share components assembly class case server new server
remove legacy set cypher parser
ensure remove index entries label properties node change transaction build remove nodepropertyupdates base node command read value store incorrect property label change transaction cause index service correctly remove index entries side step issue commit build lookup table node pay nodepropertyupdate change update write transaction update contain correct value lead proper index solution need lookup table would nice fix
set elect master null fail due available instance otherwise switch master next election happen
name space status code definitions declare separate end category error statuses
consistency checker check nod index directly use property store instead record access apr reduce code duplication expense defer check mechanism could prove expensive check need read whole property chain node add parameters turn label scan store index check check uniqueness unique index keep index accessory open duration entire consistency check extract task class
merge pull request textual error cod
revisit log election state cluster configuration commit add extra log election state cluster configuration order hunt bug turn log useful keep production commit set proper level clean bite clean superfluous cast appear
add documentation generation neon status cod
robust shutdown sub process make pipe ask correctly handle end input stream export rim callback rim reaper thread exit process
fix test would slow transaction leakage still test leak transactions way cause slow think
fix link list example query move graph gist format
change user neon service run debian file source new user variable discover default value neon user post install script assign ownership installation file user start stop daemon start process also refactoring init script removal duplicate copy init script fix refactoring init script refactoring remove duplicate init script
fix asci doc syntax psf table layout status cod add manual
remove ski example remove last year flaky fail incomprehensibly team city seem point spend lot time work wrong one unimportant
test fix fail start transaction master mph cherry pick commit
fix delete index replicate cluster nod
add second timeout master remove thunder herd
add store player abstraction
revert revert include browser regular build revert commit
initialize transactions master late possible remote transaction longer create enlist read transactions enlist well plummet performance instead slave track flag whether remote transaction initialize initialize two point either first lock grab right transaction push master part code refactored sta become orthogonal concern domain logic contain one data source hold fort intro conundrum see comment transaction state around methods track remote transaction initialize add monitor test slave pull update behavior
bower need run part build components check
fix
keep explicit state whether transaction remotely initialize instead rely lock information whether lock grab problem old transaction state check lock new one one kernel apr preferably check approach error prone explicit flag better safer also rename take remote hook name method name disguise slow reason around problems involve fix commit regression may also fix corner case remote transaction management also pull construct due differences data source enlist time cherry pick commit
prevent local slave lock acquisition wait grant master slave cluster acquire lock first acquire master grant acquire locally give master authoritative instance regard lock cluster expect acquire lock master grant await condition expect free acquire however apparently case since sometimes slave come back master acquire block await lock free since transactions hold presumably problem describe many case result lock stick forever master way release would restart database commit fix issue confusion master single authoritative entity lock fix prevent local lock acquisition master acquire wait lock free locally would happen wait instead throw deadlockdetectedexception actually subclass thereof contain diagnostics lock present local lock manager deadlock detect exceptions walk quack way real deadlock normal retry transaction put things right root cause fix deadlock detect exceptions throw client instead leave releasable lock master behind massive improvement reference issue cause many unexpected blockingreadtimeoutexceptions throw exceptions much less commit
back development version
close logical log file channel reference testrecoverylogtimingissues fetch file channel logical log verification phase need close manifest failure move log file rotate close windows
move primitive iterator package move kernel exceptions kernel exceptions package
add purge monitor ger cache pull richards monitor utility easier collect monitor components database also purge purge item position purge start since position recently put update position make sense directly purge put update
fix udo host resolution
fix issue availability message necessary broadcast previous attempt area leave open bug example master receive slave available event would make broadcast master available event refuel loop exchange make sure instance state incoming transition examine decide broadcast introduce test
patch race condition recovery add stack trace help debug
fix quote java path new installer super brittle string manipulation fail lead space
improve log failure rollback
improve log failure rollback
reactors state machine contexts interfaces commit need refactoring make state machine testable remove dependencies state machine contexts interconnect tangle require multiple level mock instead implement multiple context take care factor common need functionality diff large represent big change
reactors state machine contexts interfaces commit need refactoring make state machine testable remove dependencies state machine contexts interconnect tangle require multiple level mock instead implement multiple context take care factor common need functionality diff large represent big
merge pull request fix rep upload urls browser module
fix issue instance properly change pending lose quorum instance slave master state remain forever state quorum lose regain commit add test condition remove statement cause
update cypher introduction
complete change file lock throw exception return instance stop use null failure signal
complete change file lock throw exception return instance stop use null failure signal cherry pick commit
fix quorum check election state quorum check wrong lead instance proceed elections even enough instance leave cluster show symptoms split brain add test fix
fix quorum check election state quorum check wrong lead instance proceed elections even enough instance leave cluster show symptoms split brain add test fix issue
fix slave deadlock problem instance block access already state allow access first place way instance grab multiple lock database previously lead database block forever lock several time open refactored quorum check utility method replace incorrect majority check highavailabilitymemberstatemachine multiple context
fix slave deadlock problem instance block access already state allow access first place way instance grab multiple lock database previously lead database block forever lock several time open refactored quorum check utility method replace incorrect majority check highavailabilitymemberstatemachine
chain symbol table update action mergepatternbuilder
join denial include receive configuration state include clusterentrydeniedexception result denial one deny instance already send message payload change pick join
fix critical browser bug internet explorer update update code mirror fix overflow bug avg canvas add upgrade splash fix browser overflow hide avg elements make display visualisations better chore browser update angular animations still break fix browser use correct style directive legend fix problem show fix expand render frame full height fix animate frame enter fix nest animate trigger fix position frame action add upgrade splash internet explorer fix drag drop angular remove file upload directive fix editor upgrade code mirror fix multi line mode focus editor right way click editor area fix tip visibility put max height label color legend fix animations focus editor load initialize cursor properly fix drawer animations fix error bar animation fix problem inspector content load update angular
merge pull request fix merge work find multiple elements
use internal hierarchy type replace scala base hierarchy introduce static val type prefix cypher type reverse directionality hierarchy treat super type hierarchy align definition languages rename iterate type type legacyiteratedtype use inner type collection type
remove test complete ignore year cherry pick commit
fix fix issue replace property entity use batch insert property would bigger one overwrite would need new property record would null interception due remove property block property record two time cherry pick commit
merge pull request make possible profile query multiple null pip
pass along phase timeout payload place cherry pick commit
enable test event handlers test also commit issue expose also fix
enable test event handlers test also commit issue expose also fix cherry pick commit
rationalize example jim parameters add additional sensible example parameters printpromotionfailure printflagsfinal printflagsinitial explain default heap size dynamically calculate avoid confusion example hard cod size remove legacy parameters apply anymore
watch server offline reset database meta information come back online revise legend display label display graph
defer unique constraint verification better performance read index add new entry expensive delay verification end use index reader term iterate though index entries sort order verify total number unique term match expect number entries group together property encode logic end store number ordinary field make number encode explicit use normal term query instead range query
fix bug precision loss index large number problem always coerce number double encode value index mean loss precision could cause large long value sufficiently close together coerce index value happen index lookup would return incorrect result find much data constraints would overly restrictive fix double check actual value store filter non exact match could alternatively change way store number index however would introduce store format change decide solution since bunch store format change want burden users another one bug fix patch release index popular find collision index look actual value store double check value actually collide claim duplicate entry find uniqueinmemoryindex similar thing help index lookup store give call property accessory implement neostoreindexstoreview class provide indexpopulatingjob index operators give index descriptor index populate get property eye property lookup property accessory equality semantics booleanarrayproperty change similar array property type important empty array always equal empty array regardless component type list index memory index implementation type hash index default memory index implementation easier implement new verifydeferredconstraints method use hash index array encoder longer need ability decode index value read real value store schemaproviderapprovaltests already exist index duplicate modify also verify behaviour constraints index look mechanisms streamline throughout disk layer cache layer statehandlingstatementoperations constraintenforcingentityoperations virtually untouched change tons test update match verify new behaviours indexupdatersupport delete functionality inline test use
handle concurrent store copy logical log prune previously filenotfoundexception get throw logical log file get prune due log rotation half way store copy check logical log exist attempt copy exist matter old ones anyway split neostorefilelisting return logical log store file separately mean double pass file add benchmark check detrimental
move apr level usage internal class graphdatabaseapi internals cherry pick commit
move apr level usage internal class graphdatabaseapi internals
corelli get relationships delegate kernel apr get relationships node proxy use kernel get relationship node proxy use kernel apr relationships node proxy use kernel apr remain move node mph node manager code kernel
merge pull request back port master generate propagate epoch
split relationship chain type direction change relationships node store disk node relationship record virtually untouched new type record store sit node relationships act node centric index type direction relationships previously logical layout node one long chain relationships connect relationships type directions mix chain load relationships particular type direction could make efficiently since whole chain load simplify like node rel rel rel commit introduce relationship group store record sit node relationships like node group group group rel rel rel rel rel rel rel remove need load irrelevant relationships know type direction furthermore back pointers relationship record first chain use store number relationships chain allow count relationships even base type direction nod relationships bypass relationship group index instead switch certain number relationships remove overhead relationship group record small number relationships dense node threshold configurable default commit also bump store format require store migration happen automatically configuration settings allow place consistency checker lack check around relationship group record point fully cover areas
ensure input tokens affect equality also use option identifier indicate name anonymous nod res use boolean indicate distinct close clauses ensure stateless build legacy query
add multi host service neon server add configuration database server contain meta data host databases add database registry manage live host databases add run time reconfiguration databases drop create change fig mode contain several provision ensure full backwards compatibility previous database associate configuration legacy fig file exist override host fig commit contain new service plug mean incorporate piece meal first move new code plug follow
fix problem parser thread safe
move get relationships kernel apr still delegate old implementation correct call paths lock move kernel lock layer obviate need lock could pass getnodeforproxy remove delete relationships filter statehandlingstatementoperations use primitive iterator low level res swap lower level implementation use instead relationship type remain get degree still use old code paths swap follow kernel prepare commit get call outside synchronize block
back port dbfefacbcbeedaae shell print warn exit unterminated input
move monitor package add support monitor tag monitor part package move monitor monitor support tag add finer grain control listeners achieve monitor longer accept logger constructor argument functionality properly achieve add monitor instance
remove logoff factory default implementation one implementation logoff factory straightforward call del constructor call need factory abstraction since complicate upcoming work monitor remove
use try resources
merge branch
make kernel dependencies provide cypher compiler run kernel future
introduce monitor network operations block buffer update bytercountermonitor bytes write underlie buffer way operations serialize transactions network monitor master client instance make use block buffer stream result transactions introduce request monitor log request support request context via map set contain various information request log client server update request monitor request send receive respectively
also fix false index collisions online index story far index store number double mean large long value coerce double value cause collisions index fix index populate make read collide value property store double check collision real also add similar exact match filter index lookup operations statehandlingstatementoperations fix index lookup fix first round add new stuff index online bug matthias find specifically uniquepropertyindexupdater verify constraint still hold close method super bad close method call commit prepare transaction commit huge initially think put recovery risk turn case recovery use normal index updater instead unique one mean follow scenario possible add two nod similar distinct long value index constraintenforcingentityoperations fine value really different however uniquepropertyindexupdater trash transaction commit suppose entire database server crash whatever reason must recovery recover index use normal updater add value without check constraints actually totally fine filter exact match statehandlingstatementoperations index work advertise crash database order add valid value index except window crash transaction crash database transaction could retry exact value encounter exact crash recover transactions boom get duplicate unique index solution currently verify constraint method accept value give trust constraintenforcingentityoperations job implement solution make bite harder number test operate directly index update instead check publicly observable behaviour intend rephrase test term higher level apis mean time lot case cover ignore fail test see robustness suite say
merge branch
add support load csc clause
merge branch
add auto commit cypher
fix life cycle handle slave switch longer cause deadlock concurrent shutdown database add predicate wait instance join use arbiters
instance create cluster contact instance instance would create cluster discovery would contact least half instance configure initial host one numerically smallest instance among lead problems instance would ahead create different cluster startup order particular instance could respond two instance numerically lower instance ids two would manage contact would lead form cluster remain instance join one random commit change instance longer wait quorum number instance configure initial host ensure instance form cluster see possible see instance join cluster
implement replacements ignore index compatibility test
add support transaction event handle kernel move relationship state handle stat simple move property state handle stat simple introduce mechanism add commit hook kernel transaction use transactioneventhandlers user register listeners transactioneventhandlers take snapshot state commit time use present user add support list change label transactioneventhandler remain cache invalidation properties res command items remain remove legacy state stop pollute global cache
merge pull request get relationships get degree getrelationshiptypes kernel implementation
merge pull request fix
remove test fail team city obvious reason test fail since admin replace browser seem point try work
migrate read file markdown asci doc
factor nestor transaction relationship manipulation logic part build roll upgrade transition dense node store require dense node creation logic reusable outside nestor transaction also useful batch insert also need replicate functionality commit extract delete relationship create methods nestor transaction class reuse elsewhere also introduce flyweight context nestor transaction idea state nestor transaction consist object reuse include newly create relationship creator relationship delete allow pool object min peak target strategy pool implement flyweight pool reduce drastically amount garbage generate though measurements occur yet
clean deprecate methods old traversal apr
use cypher query cache find plan base cypher compiler recreate schema change ensure cache flush
consistency check relationship group record add follow check relationshipgrouprecord invalid rel type relationshipgrouprecord invalid next pointer relationshipgrouprecord chain unsorted relationshipgrouprecord refer relationship use relationshipgrouprecord refer relationship first chain relationshipgrouprecord refer relationship different relationship type group
merge pull request deadlock status code
merge pull request multi host
replace full backup copy store common implementation solve issue copy store full backup implement mechanism recovery rather allow data source run regular recovery cause problems two mechanisms risk diverge add log writer apr allow external tool write arbitrary log arbitrary data source reactors workaround backup ensure log file exist class
merge pull request add instance header outgo message processor use
fix null execute time
start transaction interceptor roll upgrade refactoring injection interceptor start interceptor decent test setup
merge pull request remove merge leftovers
widen recoverable failure scenarios schema index failures populate index include crash may leave index file inconsistent may lead index unable open recovery impossible proceed however scenario recover delete repopulating index failures far commit add two exceptions list recoverable errors filenotfoundexception exception throw open lucent index may come index close properly case crash
fix issue use periodic commit would swallow result transactional endpoint
merge pull request add test around backup tool
introduce new lock apr forest lock manager classic lock manager remain implementation new lock apr slightly improve contend global data structure take lock already hold class lock manager refer community lock manager forest new lock manager available enterprise faster community manager scale linearly execution thread add use new deadlock detection scheme well mean deadlock detection significantly faster require pessimistic synchronization
add systempropertytestsupport
return identity map identity map methods
file urls open path contain special char clean simplification code
add basic test slave transaction rewrite disable
manual typos
first wave refactoring disentangle command operations first series commit refactoring command read write execute transactions serialize rewrite immediate usability roll upgrade however complete still lack proper method name place wire hang must polish merge new store command longer carry responsibility read write execute instead move command reader command writer command executor class implement whichever way necessary task currently one command subclasses command longer need create usage although currently init call bind proper context allow future pool command object even single one pass around logically require use factories command reader command writer use since eventually provide outside roll upgrade work factory necessary since log extractor must use separate scratch buffer transaction read write logically happen pair accept different handlers abstract operations way allow random rewrite incoming outgo transactions way master slave operations practically except set different handler case
tentative fix loadcsvacceptancetest windows sanitize filenames
faster upgrade change strategy scan node store scan rel store lead much less random access upgrade require single sequential scan rel store plus random access node store one access node modify scan strategy use align scan buffer instead buffer improve scan speed one order magnitude remain memory usage still high need investigate performance ram run
introduce log entry read write versioning cursor abstraction remove logout instead separate class read write log entries reason need versioned log entries enable roll upgrade log format change logical log read iteration entries happen class log serialize class responsible recognize log entry versions use appropriate reader log reader return cursor accept consumer pattern allow control flow log entries caller leave responsibility iteration log reader change cause ripple code base since iteration hand use static methods logout log entry instance type field allow switch instead instance check log extractor also expose cursor extract transaction
merge branch
server dictate log kernel use server setup server kernel use log mechanisms commit also remove usages server favor console logger kernel
merge pull request
merge branch
fix byte count monitor add debug output bytecountermonitor implementations update wrongly many components use fix introduce monitoredreadablebytechannel wrapper around readable rechannel update read give monitor solve issue monitor buffer rechannel wrap bytecountermonitor monitor actual write block buffer also update bytes write
pull state kernel health also share logically rule panic respect kernel panic event also place apply external transactions
introduce function name use identifiers let function invocation use function name
merge branch
compile java fix
fix lock management introspection
introduce label retype distribution heuristics add heuristics method kernel heuristics persist shutdown sample random nod every second expand job scheduler allow cancel job
ability return paths diminish cost algorithm object accept parameter whether retain sufficient information able addition return best path continue return paths order diminish cost retention require memory performance impact well enable
remove catch block suppress failures test make test robust catch block httploggingdocit suppress failures remove become apparent test flaky specifically almost always fail run alone although pass run test file believe flakiness log file always flush disk assertion reach
include state command string methods applicable namely nod properties
add monitor log kernel extension add monitor plan
better error report recursive directory delete fail although throw exception delete fail get information delete file throw exception would like get better report help diagnose flaky test reluctant change file tip delete file throw exception instead return boolean widely
bump scala version patch release
merge pull request new lock manager
make easy test produce logical plan cardinality estimator cost model function introduce cache plan cardinality cost per plan run change astr writer optionally parameter extraction test
make udo user agent record testable get sporadic failures udo collectuseragentfilter integration test look like test logic integration test logic complicate sample record one hundred request add unit test cover logic remove sample record every request sample originally put reduce possible performance impact filter change implementation longer use regular expressions string split special case single char delimiters read jersey code call get hold request headers convince everything fast sample necessary order make whole thing testable avoid problems static state work way state store somewhat convolute satisfy various constraints put way code use see collectuseragentfilter detail interface collectuseragentfilter change need rework udo integration test integration test somewhat tricky way maven modules stitch together previously dummy implementation filter udo test mean easy interface get sync instead move integration test project depend server udo without introduce circular dependency
parallel data importer use techniques allow sequential accomplish record create stag pass record record get partly build stage also use batch level file channel since bind amount random access random access isolate cache satisfy size cache depend number nod import reside either heap heap ever room
merge pull request new output format manual
merge main
add support fallback full backup incremental fail online backup support new default backup behavior backup tool handle old backups incremental anymore
another round refactoring allow versioned command read lodge realize delegate version read versionawarelogentryreader log entries carry version field lodge realize longer require command reader require command factory know versions command factory must know versions lucenexacommandfactory longer depend lucinda source
merge branch
first set change need rewrite entries fly introduce command reader previous version command command factory aware entry version return appropriate command reader currently pool coventry consumer aware entry versions keep around previous versions translate densenodetransactioninterceptor work add remove relationships still work change add remove properties label work
add length expand logical plan
add owner field relationship group record also let consistency checker verify owner field
include optional match query graph add require ids query graph track expect scope
primitive hash collections map use hop scotch hash hop scotch hash algorithm deal conflict come hash value index really hash hash function use measure comparable lead libraries equal functionality substantially less also dry code algorithm pull class clock low whereas hash set map implementations call algorithm one liners state abstract table interface trivial implement example primitive long combination long int long int primitive map implementation drive iterative randomize test framework also add commit action define example add remove check action event check return execution stop reduce list action minimum brute force reduction one action time finally print java code test case reproduce problem confidence code high since test large combination value size set map preferable collections case key int long access single thread need multi thread version algorithm add later new set map interface depend kernel move primitive collections module kernel depend since everything else depend kernel change barely noticeable component apart class import change
fix cypher test depend list order set enough rename refactored densenodetransactiontranslator create lucent translator upgrade version number wire translators
fix issue state bookkeeping report instance role case instance switch master slave without broadcast master unavailable event case cobble state keep cluster members end report wrong role fix introduce knowledge mutual exclusion master slave roles cluster member ensure one receive properly remove
refine approach upgrade intermediary structure fit ram fall back multi pass approach make upgrade mostly free
fix name neon desktop artefacts
master switch fail demote instance
master switch fail demote instance
compilation problem
log performance optimizations fix custom jetty logger cache index enable change hogback service cache index enable add index enable check string resistant cache add security filter security rule
log performance optimizations add custom jetty logger cache index enable change hogback service cache index enable add index enable check string highperformancecache
make query graph handle
merge branch
fix issue role election cluster introduce test fix edge case role election may come vote receive actually delay responses previous election could lead wrong result guard versions mark elections vote request responses election result could reorder one would fail broadcaster guard election epoch allow election result ignore instance vote count could become wrong instance vote mark fail election finish could lead case role holder ask vote election context register heartbeat listener invalidate vote instance fail add backwards compatibility elections initiate previous version instance still receive proper responses
fix relationshipgroupcommand serialization add test
fix slave instance try win elections actively switch master case coordinators instance create cluster
fix slave instance try win elections actively switch master case coordinators instance create cluster
merge branch
normalize predicate plan build plan predicate selection well predicate rewrite conjunctive normal form plan start another difference expressions replace work collections instead tree
add unwind cypher unwind use transform collection individual row
add test slave instance elect coordinator
introduce documentation execution plan produce sonja also introduce page query tune
fix overhead midi allow equality midi instance interface reason code equal imply since standard get midi error since kid come manager manage kid copy branch global array every equality check
big profile refactoring
ensure update pull perform master instance update pull thread would listen instance state change could lead master instance pull update dangerous complicate things necessarily extra thread run necessary load create commit make update puller listen change instance state start stop require add test newly introduce behaviour
merge pull request query plan refactoring
plug file descriptor leak turn properly close index readers transaction contain relevant change wrap lookup iterators resources diff apply iterators fix
make election respect elector versions
change hash distribution also primitive collections
store copy join log file latest transaction try write test switch slave hard write test fix provide without one
merge pull request make single methods close iterators also resources
introduce line checker refactor abstractions
merge pull request fix issue role election cluster
merge branch
ensure get relationships return usable miserable stop relationship iterator pretend miserable
use batch importer store migrator
merge branch
minor touch translator function factory provide graph database implementation provide dense node translator store value store version long hardwired log file longer move upgrade masterclientresolver get reset protocol mismatch generator factory reset relationship group generator master run compatibility mode roll grade apply much sophisticate load
move relate file package
remove sta
move file module
label support astexpressiondocbuilder
add psf manual back fix image size upgrade code mirror
media res
merge pull request add psf manual back fix image size upgrade code mirror
merge pull request use index hint fix
new page cache apr abstractdynamicstore
use new page cache apr relationship outscore
work new standard geocache
update pom file version snapshot
add pinnacle page
implement page file
also print instance name instead leave closer
clear evict page secondary structure also throttle eviction diligently avoid evict page
pass page cache store compile store factory need page cache well
work page size number page cache
fix bunch test use new page cache apr
back development version
browser escape server response prevent ass fix
browser escape server response prevent ass fix
fix bug cause rock free entries block elemental mark flag use guard create multiple block resource nothing element entries element creation removal still safe since synchronize rock
fix bug cause rock free entries block elemental mark flag use guard create multiple block resource nothing element entries element creation removal still safe since synchronize rock
fix host report match new test
rename test clocksweeppagetable well
move kernel make basic start create node shut path work
merge pull request fix bug cause rock free entries block elemental
fix last remain compiler errors introduce new page cache apr
add additional protection exceptions flush page
fix update recovery
test cleanup logical latest test
fix bug flush page give page could race eviction
log truncation work expect
untangle relationship chain load thread map previously require piece code load relationships get node degrees bean apr transaction thread transaction map use fact encode hide deep within layer instead load functionality inject node mph load occur kernel transaction load relationships
give
test fix real main fix
bag gravel
merge pull request cypher raise precedence pow operator
test fix
merge pull request introduce new way write planner test
ensure transactional endpoint respond tip location tip call
community compile test compile pass
make sure always send versioned data ask proper vote request
refactoring use life cycle rename consistency various test fix
first draft new apr page cache pin methods away public apr eventually become internal presume idea new apr distinguish read single page scan range page also feature revise interpretation cursor concept closely align academic one
merge branch
test fix rename test test suffix rather test prefix use instead abstract test
visitor provide cursor creation rather usage
fix store recovery test
make sure hit parser every cypher query server
zip neostorexadatasource manage legacy index providers kernel stack call index providers
implement rearrange code lucinda source friends satisfy transactional spa create
remove shortest path res consideration uniqueness predicate
merge pull request pax split
introduce union query use
let legacyindexproxy implement put absent move node manager
fix around lucent index command
fix couple index index rule regressions
fix compile error java yet
second draft new page cache apr pin methods still away concept page consumer drop instead access page cursor facade similar things work plain pin next method may stay page page need reprocess reason therefore always page process loop similar useful try implement page cache use sequence lock
final change state refactoring earlier
one refactoring query projection query horizon
port node store new apr also fix bug page add file yet evict would accessible cursors grow specify
compile test still break
start work test
sanitize transaction propagator commit method correspond test compile
intermediate state test remove dependency backup currently break probably permanently remove anyway test compile
third draft new page cache apr
add monitor namedthreadfactory track component create thread
begin work stamp lock base page cache
merge branch
keep build java docs assembly modules standalone depend
fix around test metadata extraction work
store copy work
backup compile run fine kill server til favor small single responsibility class pack unpack responses stream accept store store copy also make lot life cycle handle clearer around cursors
introduce transactioncommitprocess interface split transactionrepresentationcommitprocess two process one append log apply store use slavetransactioncommitprocess apply incoming transactions revert return long instead void compilation fix
properly notify transactions store close transaction apply
correct usage log position include readaheadlogchannel implementation also introduce composition marker mutable get pass channel receive correct mark composition marker create immutable log position object request
merge pull request fix service loader
merge branch
large round change get dependencies place work transactionheaderinformation provide factory way inject master author information transactions commit process master slave versions provide factory commit process provide factory switch master slave versions remote transaction state handle limit lock remote initialization tear require transactions run master side slave factory accept store creation allow life cycle shenanigans must revisit point update pull push commit use response packer revisit need start stop switch slave restart necessary never recreations magic data present store transaction remove comment bunch usage
fix physicallogfileinformation provide timestamp info cyclic dependency present physicallogfileinformation physically file plan require reader read transactions log extract timestamp information elf need plan work logprunestrategy must break somehow probably timestamp field header log file spa satisfy plan need also add basic test thresholdprunestrategy
reinstate batch page cache batch import basically page cache version one page per store memory time move along batch importer cursor store file memory require
make log extractor auto loveable close log extractor test
add test transactionrepresentationstoreapplier remove duplicate call update generators since call neotransactionstoreapplier recovery
add test physicaltransactionappender add test physicaltransactioncursor rename recommit transactions add equal hash code simplify test
remove increment version conversion repository since redundant
add transaction terminate transaction apr allow user terminate transaction forceful mode failure mark transaction fail roll back also cause subsequent kernel operations contain within transaction throw exception functionality use user face query termination facility sign
change jetty thread calculator take account selector acceptor thread register help tip
fix string write read primitive utile remove unused methods primitive utile add sort update
better generate configuration docs generate docs settings class extract information valid value deprecate mandatory settings default value make every set easy link use new annotations add information settings clean language format settings descriptions upgrade tool include move jim base book validation better support mobile devices
add support extract store version descriptor versions earlier last legacy
add ignore migration support class store
move legacy store legacy store package
rename specific store file specific legacynodestorereader
final change migrate directly store introduce legacy store abstraction read legacy store exist implementation rename version implementation add improve interface check migration check version instantiate correct version legacy store
introduce marshland pool marshland pool use puddle local per thread pool avoid pool contention delegate global pool local pool sufficient rename flyweight pool linkedqueuepool consolidate pool pool interface remain work marshland pool store one local object per thread use instance link list
improve comprehensibility database availability log longer use counter boot strap availability instead components mark block startup mean include description database unavailable startup
merge pull request step master page cache improvements
merge branch
extract page swapper concept page responsible read write store channel page swapper tell swap
move consistency check module enterprise community
branch compiler
add store consistency check store migration test small cleanups reactors
avoid include store test source content bundle manual
work mun inn page cache currently fail test get
muninnpagecache implementation pass exist page contest still bug however new test add
page cache test fix bug standard geocache fail progress next page next page call make sure standard geocache use desire pagecachemonitor test fix pin count bug mun inn
fix inconsistent behavior diff set remove add combination previously remove add would result item add add remove would result net change fix inconsistency lead net change case resolve two bug property label change one would remove add label property multiple time transaction
add java docs forest kernel
ensure log shut upgrade
page cache throw close file map
enable transaction monitor sta removal
merge pull request merge master
improve mun inn performance remove indirection
add explain shell
enable test
enable index creationist fix test class name
enable clustermemberssnapshottest move package fix test
add detail flaky test
refactor pipeexecutionresult introduce result iterator trait remove eagerpipeexecutionresult introduce eagerness iterator move dump methods new result dumper create unneeded inner iterators pipeexecutionresult
merge branch
make page fault throw sweeper victor thread die instance underlie storage device run space want page fault thread get stick unpack loop forever check sweeper victor thread exceptions every unpack iteration
make page cache implementation configurable
clean test
initial work disk layer implement full store player apr introduce mainly set unsupported operations disk layer introduce hide fig option disable cache layer entirely operations like node exist exist implement would first step assess database performance without object cache
move muninnpagecache enterprise
introduce expand kernel apr add first primitive kernel apr use cursor register spec define signature first primitive capable expand single hop one source node filter retype direction commit contain revise cursor longer inherit cursor two perform different job register implementations need first primitive complete augment cursor overlay local state top another traverse cursor temporary implementation store expand cursor simply piggyback exist list els visit rel mechanisms cache layer next step refactor store format stand alone class separate store implement store expand cursor use format class directly bypass cache
test bug fix mun inn fix bug chanel upstream read return unsigned bytes wrap int instead return sign bytes unit end return int fix bug mun inn optimistic read lock page page evict page cursor retry method fault page instead blindly take pessimistic read lock page either free fault random file page pessimistic read would succeed exception data actually read completely random junk
respect forward redirect browser
add profile cypher
fix bug ephemeral system write beyond end file space fill zero ephemeralfilesystemabstraction insufficient synchronisation code allow thread write beyond end file another thread would write space first thread would overwrite new data zero course debug pagecachemonitor extend also observe
fix bug ephemeral system write beyond end file space fill zero ephemeralfilesystemabstraction insufficient synchronisation code allow thread write beyond end file another thread would write space first thread would overwrite new data zero course debug pagecachemonitor extend also observe page flush
introduce standard store similar one ring store rule standard store implement coordinate infrastructure store startup shutdown logic common base interface store take input store specific format specification store format describe read write record store headers store provide cursor navigate record may augment store format provide non standard operations like read record field directly oppose serialize full record commit contain two store format implementations nod reformat relationships reformat new store plug commit change live part code base mean first step pause point peer review current state code remain work propose order plug new store run side side exist store exist store remain charge startup shutdown procedures implement recordtraversallogic expand operation implement store format move code use new store make new store responsible startup shutdown similar infrastructure remove old store
terminate run transaction frame close send delete request server terminate transaction
use cancellation request replace interruption state change task interface capture notion request cancel run task involve actual check notification mechanism application dependent driver properly cancel state change remove use thread interrupt cancel task currently switch state interruption capacity cause unwanted side effect operations future attach currently run task actually wait ensure two thread step toe switch slave task check convenient point store copy cancellation request properly abort clean revisit add comment key methods adjust test work new way cancel reactors master fri make structure clear add two cancellation point switch slave add defensive check switch slave master also add catch clause around get future task switch need cancellation add test add check
move recover high update responsibility store transactions apply recover transactions store generators need notify apply commit candidate high ids track store share field assumption one transaction time could update store longer case high track move transaction application instead actual update high store recover transaction apply synchronize add check high never lower mistake also commit fix recover transactions set high highest see one error commonabstractstore sethighestpossibleidinuse long method introduce finally old code block silent upgrade new store record also remove test
add java doc page ace apis
merge pull request transaction representation separate timestamps start commit
fix fri handle backup tool
fix log failure slave store copy
introduce configuration cache new set forget configuration specify cache size ratio old generation max size memory division across internal components cache handle fix ratios old fig refer advance fig set override memory ratio configuration
ensure nod argument relationships plan correctly simplify examples assume squash match match need project match match need filter start end nod resp
merge branch
merge branch
add support read log file feature need upgrade use add test case upgrade scenarios embed server various cleanups small improvements
make page contest less flaky able reproduce flakiness locally guesswork change help
document appropriate way disable udo
merge pull request make page contest less flaky
minor code style fix test
test case race commit update cache transaction commit update nod object cache add relationships create transaction however possible node cache transaction start commit process put cache another thread read relationships node thread read relationships commit transaction write store update cache read thread would already read relationships commit transaction add cache happen commit transaction still add relationships cache twice node
create filter deal forward host forward pro much stack currently enable neon server resources include manage address via external host name fri scheme
create filter deal forward handle forward host forward pro move handler code outperform provider jetty filter much stack enable neon server resources include manage address via external host name fri scheme
drop download either son csc
suggestion expand label type row
fix make sure override upgrade
support trace rewrite check condition condition check still need test hot code path test
make fail start old store
merge pull request support read log file upgrade store file
merge remote track branch
store contain upgrade info broadcaster whole cluster slave check store ids startup
remove direct usages monitor favor individual monitor easier mock delegate make clear component expose add supplier supply instance without creation remove direct usages dependency resolver replace supplier explicit dependencies add supply dependency dependencies helper add java docs need replace custom dependency resolver instance generic dependencies helper come add byte count monitor netty level client server
support upgrade add support read log file split physicallogneocommandreaderv one parse command one command
add tree node zipper tapper helpers cypher
move parallelbatchimporttest consistency check add check
print log flaky test shouldupgradedatabase
make clear three transactions application modes internal external recovery mean longer piggy back recovery mode external transactions apply distinction expose problem evict nod unnecessarily delete relationships even internal application mode another problem patch relationship chain cache expose fix commit also remove global recover status store since longer applicable many transactions apply commit time state move transaction instead
handle exceptional condition upgrade
merge pull request delay node rel record change commit time
add cardinality estimator base query graph sign
rewrite party avoid stack build erasure issue change party instead build docs pretty print directly build flat heap representation recipes recipes abstract contain render value exactly stack build avoid doc generator render tiny part document keep sub components abstract generate flat representation outer loop continuously process flat representation try render abstract component find finally abstract components render flat representation turn doc actual pretty print via simple heap base interpreter keep things nice generator build slice flat representation use tiny stack base del however stack build problem nest level individual generator say pretty print function invocation level deep first version party work aststructuredocgen ability show scala like representation nod side side finally also use scala reflection instead use pattern match help type erasure problems say old party yet clear wether overhead worth benefit try know get way straightforward remove use scala reflect version party yet cover whole good shape get start reference condense list original commit history squash since almost individual commit green state add scala reflect dependency add reflective party bling package refactor extractors practical replace use fix point flat representation add step recipes expand evil rebuild print host move doc helpers pretty del fix salado gen fix pretty del work different type without call pretty make scaladocgenworkagain enable salado gen use fancy type magic trick enable plan doc gens enable aststructuredocgen support party update license file scala reflect
reduce data set size migration test
create interface log entry introduce wrapper store identifier old log entry version need reorder log entries use legacy log entry parsers use wrapper preserve identifier info
leftover dir upgrade
prettier exception backup target different store
add support migrate log introduce cursor base lazy reader read log entry first commit start return entries belong commit transaction cursor return log entries order art transaction since commit entries always write log file correct order
cypher operators may end plus minus resolve
move repeat rule test package also comment important area page cache need test also extract thread utilities page contest utility class
get exact count number nod graph
free rollback
change best fonts
change focus responsibility code mirror events
fix avg preserveaspectratio attribute value case sensitive browsers
fix avg preserveaspectratio attribute value case sensitive browsers
merge branch
fix break profile cypher
move adversarial file system module
add note ubuntu macros grunt browser build dependencies
deprecate direct use target directory pollute file system create unnecessary large artefacts
fix command readers
string long memory efficient index batch importer use case node ids give node relationship input actual record ids arbitrary string use type map node ids string feed memory index node import stage sort general prepare get string long later stag deal relationships also specify string start end node ids
evict cache late possible race test
disable start node favor match
batch importer input csc file initially michael hunger focus seek raw character array stream provide readable try avoid create string far possible value extraction revolve around visit character array offset length extract type value request join input argument batch importer add input implementation factory header information possible read provide node relationship data file source also add side kick thread wrap readable read chunk ahead separate thread actual thread read input wait
walk pending remark leave major refactoring either implement remove since longer valid convert regular since specific concern
add roll log file support default roll every day keep max days history refactored database factories use instead dept one one bug fix merge branch pick commit
start fix test use discontinue start clause use newer match syntax
ability persist count durably method count tracker read current count store write count store make one current intention invoke rotation count store log rotate count store keep consistent even though command log contain deltas apply count store persist durably log rotation simply restart last point rotation need perform recovery startup commit persist count wire rest database
merge pull request add note ubuntu macros grunt browser dept
merge remote track branch
optional visualization diagnostics transparent footer simple textual statistics update per second visualization run enable display diagnostics fig showbiz diagnostics true
refactoring improvements batch importer stag stag framework parallelbatchimporter change reduce time spend framework well report much accurate statistics simplify stage add step instead input add simplify streamline wait condition individual step condition first busy wait little back sleep strategy improve accuracy statistics upstream downstream idle possible since better place measure find detailedexecutionmonitor find print step current likely step bottle neck stage correctly efficiently follow contract step batch must send downstream order arrive imply total order whole step previously strict check parallel nation hinder cherry pick commit
remove necessary console output test
switch test use new planner
merge branch
backup tool exit error consistency check fail fail consistency check transport way user print return code
resolve two race condition relate lock sessions add check ensure slave commit run lock session commit explicitly opt one move lock session management class timeouts concurrent access test isolation
fix rare corruption bug page cache scenario guard want read page cache page fault fine page get load cache add translation table get evict clean also fine though inherently racy take lock wrong order lock order problem translation table may get update exactly happen scenario page unbind translation table free list fine though thread grab check inbound return false thread new page fault part eviction file age field set swapper field set null make page unbind want access page first look translation table find page page evict tell file age null swapper know translation table date page fault anyway grab free page free list place fault file page pure chance end exact page object one first things happen page fault set file age swapper field set value page evict next thing happen page fault read page content file page memory fail various relate errors scenario page correctly place translation table bind right file age swapper wrong content page fault ultimately fail next time want access page find translation table see correctly bind proceed read wrong content since eviction consider page load aka already free fix follow load already consider whether file age field set possible make page appear load purpose eviction time make discount check always fail instead assign file age swapper swain move assignment swapper field happen page successfully swap leave assignment file age field mean page fail swain appear load purpose eviction leave room confuse bind page
log progress catch master possible refactoring response unpack accept handler accept method make possible reuse single response unpack multiple handler purpose extension single master client instance multiple purpose
correctly build collision information string mapper rare case collide encode value one value encode long value collision map must build actual value able correctly find value later normally collisions detect information throw away indeed throw away eagerly favor less memory usage
fix backup service incorrectly initialize new log previous backup service receive transaction last one initialize log header minus one
fix failure back store upgrade old backup try get one transaction backup upgrade store might fail since might contain single transaction back log case store currently commit basically revert mismatch try backup single transaction robust flexible solution could look log backup reasonable amount available might good debug ability
merge pull request update docs new start rule
single thread pull update machine move communication design update get stream master individual request come slave design cause lot duplicate transactions stream master slave specifically slave issue write request master move design slave communication master stream back transactions except store copy instead master return transaction obligation say transaction must apply order continue slave notify single update puller turn notify update puller transaction apply many request poke update puller simultaneously transaction pull piggy back since one thread pull benefit include code explicitly deal prevent pull storm less network communication master less load put master possibility optimizations regard apply update slave since update pull single thread
merge remote track branch
improve selectivity calculations change longer discard label predicate use
merge remote track branch
slave switch slave process every master select event
expose way ask lucent index sample index selectivity scan sample index entries compute uniquesampledvalues sample size
revert change add count value state read indeed better delegate cache page cache use count store less value memory state also make sort much faster need merge one disk
merge pull request small fix server
remove unnecessary taxi generator abstraction
merge branch
split update puller two roles obligation fulfil update puller
fix backup service properly close log channel latest change
move fig manual tool
add additional test forward host cypher rest response slash redirect
extract record serialization outside count store count store accept generic key
make online backup timeout configurable backup client side use specify backup timeout could pass create new client instance timeout could either specify via command line backup tool backup apr online backup
merge branch
fix test rely recently change index log
add leave vertical menu cypher frame
maintain index update count index proxies onlineindexproxy ensure index count update fix bug generate latin exudate never construct overlap update cleanup code latin exudate make sure update index update count population
internal server cleanup quite far little way towards clean stray items server package structure need bigger cleanup job much complex several interfaces internal package expose public apr thus unmovable directly remove unused service class move rest service class rest package
rewrite plan apply optional expand use optional expand instead
add indexstatisticstest
reuse state record state visitor
less garbage around encode decode label nod
implement index sample initial index count compute population index sample schedule every second
temporarily disable new store test windows
pass transaction index update
move csc reader parser batch importer separate component rather separate concern whole benefit csc reader parser available accessible without need pull neon kernel well
change read flag mean transactions change commit specifically mean database change slave setup format accord new scheme
remove unused utility code
fix array value parse issue extractors empty input value would return null long case unexpectedly also add test verify behaviour corner case
small grammar fix docs
refactor pagecachemonitor interface able probe much deeper
merge remote track branch
merge remote track branch
add property settings server use build configuration make server get properties settings via fig without break previous apis remove previous configuration pattern properties get set constant value add default value properties whose default value hide previously use configuration remove unnecessary check use settings add wrap class fig configuration configuration configuration builder support legacy code add test new set type normalize relative fri add test two new wrap class
remove duplicate property check normal execution path
expose manual trigger index sample index service
support store number index update count store
speed sample unique indices add track index size refactor multi set allow increments arbitrary value consolidate indexsamplingconfig
break property encode separate step
rebuild index count start miss sample sample size sample happen sequentially work migration miss count store scenarios
merge pull request fix bug around flatten plan descriptions
use fair try lock call indexsamplingcontroller fix flaky test indexsamplingcontroller improve handle interrupt exception double latch
create alpha beta count store file creation
merge branch
filter mod fee select message display check server version check message type find urgent ones adapt new fee tag format
push lucent creation index samplers remove common interface sample unique non unique index suboptimal since glue together different sample algorithms
fix unstable networksenderreceivertest test occasionally fail race condition send message network sender stop network receiver instance test depend message send result closedchannelexception occasionally happen network receiver stop block wait listen thread exit result message would receive expect exception would happen fix add retry loop keep send message exception manifest verify actual functionality
merge pull request add
make extensive request metadata available batch request
expose node degree rest apr
fix schema command parser
remove duplicate properties store migration sign
fix potential concurrency issue project path also improve error message path mph track dec issue
add support server authentication neon browser browser expose authentication use authorization need set new server command available along documentation
add test make sure count propagate correctly
detect input relationships refer miss nod throw comprehend able exception
replace response empty map get empty properties fix make client side code slightly simpler since remove edge case entirely return empty map empty properties response undocumented break document behavior remove duplicate integration test replace simple full stack test
merge pull request merge
update server docs deployment
merge branch
revert revert merge pull request revert commit
log recover index sample startup
merge pull request tweak import tool docs
refactored test code
configurable theme neon browser normal dark outline
lock free load relationships remove node lock previously use load relationships lock would contend commit transaction produce latency issue lock prevent cache poison issue introduce race condition committer reader achieve lock free solution guard add various corner case committers aware fact parry concurrent readers load cache relationships commit committer committer put cache produce duplicate committer would add issue come fact store update cache committers use knowledge relationships store disk able tell reader load relationships write store update cache logic sit filter consult add relationships cache nod evict cache part upgrade sparse dense happen part update node instead separate step commit also guard concurrent readers simplification reduction code logic densenodechainposition individual chain position initialize eagerly filter logic mention become simpler order relationship relate record apply transaction store change relationships relationship group nod additions relationship chain see atomically concurrent readers
lock free load relationships remove node lock previously use load relationships lock would contend commit transaction produce latency issue lock prevent cache poison issue introduce race condition committer reader achieve lock free solution guard add various corner case committers aware fact parry concurrent readers load cache relationships commit committer committer put cache produce duplicate committer would add issue come fact store update cache committers use knowledge relationships store disk able tell reader load relationships write store update cache logic sit filter consult add relationships cache nod evict cache part upgrade sparse dense happen part update node instead separate step commit also guard concurrent readers simplification reduction code logic densenodechainposition individual chain position initialize eagerly filter logic mention become simpler order relationship relate record apply transaction store change relationships relationship group nod additions relationship chain see atomically concurrent readers
address number low risk review comment property reduplication
make primitive collections visitors generic exception type
arts make possible distinguish options flag make parse robust change parse flag never consume consecutive symbols list arguments symbols mean orphan arguments
let database page cache inject store migration participants create need also reduce memory consumption number test transition many test use page schedule instead standalonepagecachefactory
merge branch
ability keep ids properties nod header name mid csc input node field also value store property name header entry case mid
refactor neostoredatasource modules clear dependencies external internal introduce recovery log rotation log prune separate process recovery process work channel underlie log longer assumption recovery physical logically continue channel instead open channel move end end recovery log truncate last properly read transaction cut scramble transactions due kill process updateableschemastate implementation anything iago move nod log prune separate process use monitor callbacks trigger run
add miss entry import man page list
turn
support multiple disjoint space within mapper give mapper accompany group look value mapper require pass predicate match ids currently functionality yet use input implementations view separate concern commit enable feature
log rotation extract process
son serialization performance flush jackson uhf buffer full help stream flush fix flaky test rely map order java java
update mise version check target mise
record object reuse new store cursor
make type header import input optional relationship decorator provide relationship type instead supply import tool may look something like nod relationships type header may look something like start end type
detect opportunity count entities parallel stag avoid node relationship store twice import data decide factor whether enough memory available able populate state count entities node relationship cache still use
correctly respond inactive update puller different use case update puller case observe puller become inactive await condition others different exist already check call inside await exception throw happen commit move difference handle inactive puller await caller decide handle
existence node rel check deletion
fix foreclose refactor around close kernel statement use foreclose method nothing resources could leak add test
browser dept version bump bootstrap angular angular animate angular bootstrap angular local storage query query code mirror angular resource angular sanitize son shim
return plan expand join sub graph plan cache
fix couple warn page contest
kernel apr relationship data without roundtrip introduce kernel apr provide metadata relationships start endnote type without first get fetch meta data
fix bug last commit backup store log wrongly set result slave fail start backup bug arise perform online backup data write concurrently time span start end store copy flush store time span last commit record store become different store copy finally get log wrong headers
update batch insert docs mention use exist need care remove comment code example make translation easier future display properties file docs general word tidy
update import tool docs clean examples page section show fig options header file etc add section show use multiple csc file add section show use space
update query plan docs add operators use movies example show tune query add explanatory text around query tune
add ability specify disjoint group import tool use input headers group belong specify add parentheses contain name group like group similar likewise relationships specify start end ids individually group look ids commit also change delimiter multiple file space comma since space break disallow file space
load csc parse quote empty field empty string unquoted empty field null
add tracers framework high fidelity domain specific performance introspection tracers somewhat similar monitor configure fix database instantiate change run time also design exclusively performance introspection low overhead default implementation two implementations come build null default always available sense party implementations piggy back extend one alternative party implementation exist point implementation produce java flight recorder events
turn flush flush force page cache page file way flush also always imply force sync underlie file channel instead rather confuse inconsistency previously force channel force page file
turn flush flush force page cache page file way flush also always imply force sync underlie file channel instead rather confuse inconsistency previously force channel force page file
remove abstract sternest replace cluster rule cluster rule fluent apr methods fig
remove dead code cleanups note override fiesta trace readpastendexception remove initialise presence make class hierarchy analysis nervous incline
fix error open message box fix error root scope prog apply already progress
refactoring cleanup around transaction append collapse abstractphysicaltransactionappender hierarchy remove non batch append obsoletes configuration option rename couple methods clarity move inmemorylogchannel test source
graph layout tweak consider node radius set link distance pass one relationship per pair nod force layout implement basic collision detection prevent nod overlap
merge remote track branch
update browser auth remove token username password use interactions
handle illegal epoch slave via state switch new election
merge remote track branch
store copy master exception happen switch slave make branch exception pop exception cause fail getmasterforcommittedtx
add throughput stat input read step import tool
clustertopologychangesit make less flaky
merge branch
merge remote track branch
merge remote track branch
efficient hand threadbare readable threadbare readable che readable read ahead one buffer dedicate thread actual char readable run current buffer want read bytes already available name available hand thread ahead buffer consumer come request data make efficient virtually free nature buffer seeker main consumer char readable impose buffer always read fully request new buffer since break point come middle value read reason last character must move begin buffer new character append make trivial case double buffer harder since consumer simply hand buffer get new one back since still need data buffer pass read data commit introduce section buffer deal wrap char treat like two equally size part new data read front part whereas data part last value read data must transfer current buffer new buffer live back section java docs section buffer explain greater detail point hand data use consist several megabytes copy every time bytes copy normal case two buffer reference flip allow efficient read since thread read ahead basically never wait anything bottleneck
ensure unique constraints correctly orphan recovery commit contain test simulate kill neon creation unique constraint leave store state index create index rule command add log constraint create nod duplicate property value recovery try apply constraint fail clean index removeorphanconstraintindexesonstartup update allow simulation add monitor telegraph database control test log reason drop index make sure lucent file remove unique constraint creation fail normal database run time
backup tool choose copy transaction log use gather forensics argument backup tool enable access transaction log forensics purpose need manually copy take database server default behaviour leave arg behaviour copy transaction log full backup
merge branch
use import tool count computer rebuild miss count store main purpose commit however couple relate things also make improve performance around count rebuild convenience code parallelize aspects count computer import tool basically node label count efficiently cache relationship count process sequentially use node label cache relationship count parallelize read single count multi thread keep local count aggregate end produce step simplify less code generic easier extend convenience around execute supervise stag introduce executor supervisors local measurements show improvement scalability linear limitation size node cache give generally run larger store larger machine look ahead multi pass support part store process pass add stag framework remove problems huge store huge machine memory wise
back development version
lucent index overflow throw user friendly exception commit currently use lucent version gracefully handle document limit overflow insert block limit reach lookup fail cryptic errors commit add track limit neon important overflow result exceptions commit path validation make nestor transaction prepare actual commit overflow track insert stop work limit reach lookup continue work track logic index population batch insert every document addition simply check max doc value throw exception limit reach online index transaction reserve number document would add prepare method commit rollback reservation withdraw reservation max doc exception throw
mention import tool handle compress archive
group execution plan operators group execution plan operators high level group easier people find tidy intro text operators match prose use browser author mark need alistair
allow options request pass authorization filter
simplify apr count store headers generic metadata apr unnecessarily complex type safe header field apr sufficient need
properly close searcher manager unique index drop
accept transaction count update apr since want ensure transactions store count store sequentially consistent need know transaction particular update belong change introduce transaction ids apr make use yet
rewrite heuristics default page cache memory settings use formula default page cache memory set assume get number otherwise fall back gigs
factor leaf plantations leafplantablegenerator use without need plan table greedy solver
synchronize add chunk dynamicnumberarray support concurrent write least touch different items array cherry pick commit
synchronize add chunk dynamicnumberarray support concurrent write least touch different items array
sequentially consistent count store snapshots restructure state transition key value store back count store ensure snapshots get store rotation contain transactions include transaction rotation occur
parallelism node count import stage label decode count happen separately read even though read dwarf count comparison still perhaps gain
merge branch
change log
use command count update issue recovery recover count would need read label node exist command apply since data write log count recovery would read store could lead inconsistencies well failure recover resolve make sure count update handle explicit command never infer command simplify count update code ensure count deltas need compute transaction create
merge pull request release kerneltransactionimplementation last thing close
merge branch
merge branch
introduce input cache cache input data stream disk input implementations provide data stream multiple time something parallel batch importer require cache binary format store disk input tenable tell importer whether support multiple pass importer cache data stream first run use consecutive run
set default rel caption add test
lucent index overflow throw user friendly exception commit currently use lucent version gracefully handle document limit overflow insert block limit reach lookup fail cryptic errors commit add track limit neon important overflow result exceptions commit path validation execute write wal perform indexupdatesvalidator class overflow track insert stop work limit reach lookup continue work track logic index population batch insert every document addition simply check max doc value throw exception limit reach online index transaction reserve number document would add prepare method commit rollback reservation withdraw reservation max doc exception throw
merge pull request stop rewrite pathological case
mapper preparation execute stage execution monitor report progress enhance progress report well parallel sort thread local progress report total progress reduce overhead progress report abstract step enhance able reset stats effectively support multiple step execute sequence able report mapper preparation much detail possible
import tool use small buffer size test introduce another main method import tool integration test want expose configuration user set importer able figure also lower default size little normal import user require csc data input stream test require
add warn unwanted cartesian products commit also add minimal infrastructural change need propagate notifications add create send around record notifications add son response
less clutter spectrum execution monitor zero length step
update auth return correct content type header auth errors resolve accept empty passwords resolve return use service request auth disable resolve rename internal auth store fig option
remove unreachable code minor refactoring property loader
use outofordersequence check expect versioned update apply count store add see number meta method outofordersequence interface order check version already see
import tool ability skip duplicate nod rather nod input ids group ability control whereas skip bad relationships allow bad entities relationships duplicate nod collect control use duplicate nod detect node stage prepare mapper delete side effect node relationship stage handle use record control use use record flag oppose null record due detail batch geocache generally better leave record chance rather write use
import tool ability skip duplicate nod rather nod input ids group ability control whereas skip bad relationships allow bad entities relationships duplicate nod collect control use duplicate nod detect node stage prepare mapper delete side effect node relationship stage handle use record control use use record flag oppose null record due detail batch geocache generally better leave record chance rather write use cherry pick commit
make page cache manage background thread page cache longer runnable instead manage background thread use static cache executor speed test page cache longer directly participate database life cycle get attach via much simpler adaptor also remove indirection store page cache number test create databases page cache new large default size fix test longer run memory backup reuse page cache aggressively reduce amount memory use especially noticeable test
introduce function
bring desktop fig file date
keep track transactions thread associate lock debug feature transaction thread use specific lock see mean find heap dump transactions already track thread bind lock bind transaction chain complete shell possible info lock
update cypher dependencies
mark transactions write log commit fail write transaction log mark close order shutdown complete ensue kernel panic however mark transaction commit check shutdown prevent shut transactions open instead compare recently commit transaction recently close one compare highest issue transaction recently close semantically actually closer resemble want ensure open transactions allow additional ability check fail transactions close commit
proper name parametrized value cherry pick commit
handle large properly value manual index better moment try add manual index large property value get overflow exception value get include response header exceed value configure jetty commit make value configurable fail early look like response header size exceed configure value give bytes headers might need set value bite higher want
allow port set allow bind random port
fix problem index would properly recover due another index label property earlier recover log create drop user issue would see nod miss expect index also consistency checker errors index service create index speak scenario
upload docs use default ssh key
improvements neon harness expose graphdatabaseservice server control new rule enable assertions base gab enable gab base fixtures use function inprocessserverbuilder new rule use exist tester builder copy file method populate server graph directory content exist store
extract use neostoredatasourcerule resource test set neostoredatasource test complicate patch introduce unit purpose use test store
help response cod come client error status commit change exception hierarchies especially make class implement status status code correctly report exception representation restfulgraphdatabasetest lot assertions add confirm correct status cod return fix
connect compile plan could build side side interpret plan
less eager decrementing processors step decrement number processors become bottleneck instead possible decrement slightly ahead next slowest fix unnecessary behaviour decrement would follow immediate increment sometimes could keep flip like
merge pull request fix race condition unique constraint
neon data protocol
parallel relationship import batch importer batch relationships import individually analyse whether process parallel surround batch decide factor whether start end node previous batch stretch batch run parallel batch completely disjoint set start end nod batch start end node current stretch concurrently process batch await previous batch complete start consecutive batch continue describe theoretical worst case scenario batch least one start end node common effectively remove ability parallelize batch scenario likely still performance relationship import commit detection compare two sort long new single thread step actual sort already exist preparation step detection step since preparation parallel table become bottleneck give enough cup available course relationship import one time consume stag batch importer partly usually contain data import also partly parallelism stage commit give enough available cup ensure bottleneck raw disk
detect report use aggregation order without use aggregation precede projection
merge pull request dump store list ids
add button rerun cypher frame command rerun available safe update query
implement message chunk transport socket introduce chunk transfer protocol socket transport message send transport one chunk data terminate allow stream transfer large message time allow middle components pull individual message stream without serialize message
make pack stream plug able
introduce protocol documentation also resolve minor bug find test docs binary examples primitive value handshake chunk examples section human readable binary representations common scenarios
fail import specific message miss node input
fail better message miss
add neon log module
use neon log internal console log kernel
use neon log internal console log community
use neon log internal console log enterprise
merge pull request handle large properly value manual index better
add ability run cypher acceptance test planners
merge pull request add ability run cypher acceptance test planners
add raw data view mode cypher frame always show leave menu cypher frame add button errors store show request transaction
refactor internalabstractgraphdatabase split iago factory facade factory instantiate modules platform edition data source subclasses specify edition instantiate disable online backup store copy
send semantic table method instead field
extend printer handle multiple header style group style standardize format print multiple hex string line number always cod hex byte present two hex digits bytes separate one space however one could freely choose many digits use line number suffix prefix around line number digits many bytes line group group separator use
cleanup import
workers utility manage worker thread mapper
accept expect exception wrap importer
batch label scan store update recovery much better performance one major bottleneck recovery update lucent implementation label scan store batch easily make since read label scan store recovery implement let indextransactionapplier accept provider label writer recovery scenario special writer pass cache transactions write batch instead
merge pull request clear page memory eviction
use flat combine concurrent application update label store similar mortise transaction log sync cost transaction process thread want write change label store commit write command transaction log start add unit work concurrent wait free batch stack attempt grab lock happen inside new work sync abstraction get lock grab entire stack work one combine units work single unit single unit work apply single label writer amortise creation closure label writers costly operations compare write label writer
update exception show support index seek property value
merge branch
make compile plan default fix bug compile plan show run test force test use interpret run time use
update minor versions cypher dependencies
introduce socket transport split socket transport server protocol part add socket second protocol add integration test assert concurrent performance
remove option find path exact depth shortest path make sense find shortest path specify length exact pathfinder already provide functionality add test exact pathfinder graphic factory use exact pathfinder instead shortest path fix exact pathfinder handle neighbour node depth fix import
add basic query tagger
merge remote track branch
pause better test purpose remove backup provider longer use refactored cluster client factory facade always use local host cluster test cherry pick commit
pause better test purpose remove backup provider longer use always use local host cluster test cherry pick commit cherry pick commit
pause better test purpose remove backup provider longer use refactored cluster client factory facade always use local host cluster test
add index test indexprovidercompatibilitytestsuite refactored include seek scan unique non unique index
switch scala refactor code generation part new run time order avoid inheritance across java scala cause compilation errors
remove many unnecessary usages dependency resolver possible replace either constructor dependency supplier constructor dependency dependency interfaces back dependencies proxy ability create dependency interfaces extract kernel extensions dependencies proxy use elsewhere well format cleanup
tag version
add java compact primitive function throw variants type
restructure inheritance pattern instruction
clean queryplannerkit contain query graph
support configurable warn run time compile planner cost update
bump git commit plugin version fix error error fail execute goal git commit plugin revision generate git hash project neon kernel git directory could find please specify valid dog directory help make possible build individual modules newer version plugin find git directory recursively community kernel man clean package success one
merge pull request refactoring cleanup around transaction append
deprecate batch insert factory methods take asa
reintegrate gremlin plugin simplify build process
support configurable errors warn use index conformance
fix issue run nip doc test certain platforms
remove unnecessary clean database several test help fix test flakiness remove unused code old ignore test
remove unnecessary clean database several test help fix test flakiness remove unused code old ignore test back port
introduce system information service hook udo udo complex dependency hierarchy use reflection extract information system components introduce system information service components publish metadata udo access without reflection also minor improvements udo resilience store latest client name rule code query parameters udo ping payload
merge pull request solve annoy leak warn test code
merge pull request improve safety call close state
make batchingtransactionappender part life cycle instead physicallogicaltransactionstore inject append physicallogicaltransactionstore
merge pull request planner run time refactor
make sure multilane field enable default load csc cherry pick commit
fix null empty value
throw semantic errors use aggregation wrong place
introduce check point new strategy flush store store flush log rotation flush configurable number transactions log prune move log rotation check post order make sure never prune log contain latest check point commit point latest check point miss check point base time split check point different thread
minor cleanup code plan
remove ski relate configuration file class maven dependencies
documentation fix remove reference test utile batch insert examples java doc cleanup better update query page fix render fig attribute options make scope periodic commit clear correct max relationship type add example create multiple nod add example send multiple statements endpoint add example get query stats endpoint add regex operator operators page better word around web server address
check beta status connect neon determine whether ping udo
introduce cursors kernel apr cursors use implement disk layer operations
move check point thread check point trigger base time number transactions default value minutes tvs respectively introduce checkpoint racer order trace check point events disconnect logan pendents
add private constructors builder class
move line line commit move use line library latest version fix current issue shell delete actually delete stead backspace instance rename shell completer shell completer reflect new name line apr license line bad also update
performance enhancement dijkstra bidirectional fix ordinary dijkstra behave correctly change dijkstra problems graph use float point zero weight solve introduce tolerance level epsilon need use state therefore remove option user use state dijkstra option still available deprecate methods graphic factory dijkstra constructors although new improve execution lose use add separate test dijkstra use state dijkstra terminate soon could solve introduce dijkstra evaluator dijkstra expander state occupy therefor use user add dijkstra bidirectional expose graphic factory move mutable shortest path need dijkstra bidirectional add shortest paths functionality replace previous option find paths use find arbitrary number paths read order see weight dijkstra dijkstra bidirectional use functionality expose graphic factory exchange nest class path interest bestfirstselectorfactory use interface path interest also provide comparator options determine interest path add precision class compare double range tolerance instead depend add art dijkstra test pedagogical fix traversal star change bestfirstselectorfactory change behaviour traversal star combine dijkstra test one class options available paths find dijkstra behaviour control path interest use option available far inefficient leave break current shortest default use shortest use single call dijkstra bidirectional shortest call single call comment dijkstra work correctly case use find specify number shortest paths top shortest paths search shortest single dijkstra bidirectional use instead edit review comment remove constants mutable add link deprecate methods make dijkstra test parametrized test fetch paths increase weight separate test class add zero initialbranchstate static constant change name precision constrict match add test topfetchingweightedpathiterator add possibility create path simpler builder assert path neojalgotestcase add test bestfirstselectorfactory
merge pull request dynamic property lookup support prop cypher
add documentation warn regard use extensions
add equal methods compiledconversionutils
update windows requirement
update windows requirement
merge branch
server use single fig instance internally deprecate public exposure fig apis neon fig modify server use single fig instance internally fig load way neither file special fig conceivably specify yet another step towards consolidate fig helpful step browser access fig specify since settings available via
implement index prefix search lucent indices
cursors use transactional layer transactional state transaction store layer cursors decorate transactional cursors account add delete update state cursors longer expose transactional layer yet properly implement ted update test use store layer mock instead use cursor mock apply code format well
merge pull request merge
log fatal stack trace user log
implement record format high limit although time keep store size increase minimum record size align power two page cache cache line friendly support bite ids pointers compress small ids take less space big ones record whereas null reference take one bite one logical record may span two physical record record ids big one record enough hold data new format implement separate format plug default least test record format commit also introduce internalrecordformatselector default current one ability configure use format specify record format fully qualify name point class implement record format build set run custom format
check point log rotation stress test
refactor source compiler allow simple source code rewrite move source code templates place
swap use cypher accept remove stream module
merge pull request improve cluster failure test
merge
merge pull request improve cluster failure test
improve kernel panic apply transactions store transaction commit process charge raise kernel panic case failure transaction application since commit process different single duplicate logic several place transactionrepresentationcommitprocess transactioncommittingresponseunpacker responsibility kernel panic move transactionrepresentationstoreapplier indexupdatesvalidator moreover logic spread around multiple modules live inside kernel
merge pull request introduce check point
enable creation mandatory property constraints constraints yet validate enforce support create drop constraints well storage constraint metadata
use long compare double compare instead subtraction
release
unify name index access methods class index seek
change staleness plan calculate change plan consider stale relative difference statistics use plan change configurable threshold several problems current implementation way stale small plan require change factor thousand even worse big plan consider selectivity change range whereas cardinality change unbounded mean never consider change index selectivity check plan stale complicate take cosine distance two vectors span statistical snapshots transform number unnecessarily complicate general need plan often since plan see statistics use plan plan use index see change index selectivity without actually replant
upgrade lucent
cleanup usage rule create test directories target directory inconsistent way among test change try make sure always create test directories use rule
fix improvements check point log rotation stress test
verify mandatory property constraints constraints creation
simplify store class record store change one method get record accept record instance write record store new record add create record give clients full control instantiation record store newer precursor add allow client use one page cursor multiple record collapse abstract restore abstract restore implement get record store give consistent behaviour store store mostly implement format could even inject later
add rest endpoints list create drop
fix legacy index recovery issue recovery would see screw amount lucinda source write lock acquire compare release would future update lucent legacy index block indefinitely
change restore storeversioncheck use page cache instead filesystemabstraction
remove server startup timeout startup block server longer wrap timeout startup timeout severely water upgrade recovery happen outside disable entirely guard know block startup action remain historical reason commit remove entirely simplify code also remove preflight task one upgrade recovery ones longer need happen outside timeout fig validate one use cover new fig system usage server instead
merge pull request code protect spurious entitynotfoundexceptions
columns return order ask
create power shell module manage neon server get java also search path environment add better handle get java java find remove boilerplate comment etc pad file remove comment change statements take advantage boolean short circuit evaluation change throw statements write error refactored java execution command line generation individual function get java remove default settings logic cml file reinstate original bat file due support operate systems without power shell naively instal remove support legacy output function need bat file longer require remove neon status function longer require add edition check neon arbiter function
remove lot unused code mostly kernel
create power shell module manage neon server fresh commit force new build
kernel apr read longer expose property instead return value null minimize read
merge pull request change staleness plan calculate
merge remote track branch
switch first wait allow transactions finish cleanly
update hit fix property lookup
consistency checker test fix
update configuration builder settings class setup fallback fig map case settings class miss
rename mandatory mandatory property
docs fix break link neon website
merge pull request columns return order ask
errors report user appropriate others log
add rewrite guarantee logical plan contain referential copy plan logical plan referentially equal cause problem profile since profile map identity map example join identical label scan leave right see plan profile statistics thus count twice
update mandatory property constraints ensure necessary ops use even without kernel statement expand future operations also able work smaller dependencies testate store statement
simplify constraintverificationfailedkernelexception
add timeout log rotation update consistency check store use stillborn tracker prevent rotations consistency check align method name constant name restore
introduce notion relationship constraints commit mostly rename refactoring class hierarchies use represent index constraints follow change make mandatorypropertyconstraint rename mandatorynodepropertyconstraint together relevant methods rework hierarchy property constraint class reflect existence node relationship constraints rework hierarchy schema rule interface provide information label relationship type expect temporary state interface refactored specialize rework hierarchy constraint definition interface also access methods label relationship type expect temporary state really fix next major release
helpful startup error upgrade possible
merge pull request swap use cypher accept remove stream module
workaround able cursor node properties label time
make generator factory take filesystemabstract constructor help loosen store dependency filesystemabstraction
flush log channel one write since force log channel synchronize precede write buffer channel possible force channel end force next channel order make easier reason force channel introduce flush able object obtain say synchronization flush outside give best worlds shorter synchronize regions ability reason force note since previous apr call method flush new apr use exist flush able interface define method call flush description use two word almost interchangeably use force refer previous behaviour flush talk new behaviour implementation flush call underlie force method previous force method call bind directly object instead volatile lookup
creation removal enforcement relationship
flush log close rotation
move methods relate single nod res respective interfaces
optimize set operations allow node item instead operations lookup node rel operations facade pass kernel apr operations avoid multiple lookup make easier access relate information use cursors cursor interfaces refactored node cursor resemble traditional iterator stream pattern allow handle item node item without give code access cursor seek methods remove instead specify property label lookup acquire cursor make cursors look basic methods rewrite mandatory property constraint check efficient instead complexity
merge pull request remove restore
make constraint syntax require assert
shell support relationship
merge branch
add skeleton new nod node cursor getfromindexrangeseekbynumber kernel primitive
merge pull request remove lot unused code mostly kernel
unify comparison logic cypher kernel delegate propertyvaluecomparisons
add testate support index range seek number fix bug prefix seek would return match larger property key
optimise entity path serialisation
prevent read transactions trigger events behaviour change introduce mistake
merge branch
miss write read lock request community rock last active resource owner release lock detect wait thread reader writer remove lock element lock interrupt wait thread cause total headcount total recount sync lock element counter lock element remove soon wait thread take resource commit fix problem miss write read lock popular resource cause thread wait resource release test case miss write read case provide introduce graceful shutdown community client wait active clients complete current request close prevent race close lock acquisition
merge branch
add necessary apis support position vectored page swappers note present support fake non vectored position write also page cache yet make use new apis idea operate system able combine write page cache avoid read modify write situations otherwise see odd file page size
failure storage accept asa avoid real file creation memory
add testate support index range seek string
merge pull request index seek inequalities
resolve index bound error several exception hide issue gap job cause race thread worker thread flush flush order worker thread general behavior cover exist test race condition cover larger scale integration test quality tool careful several exception paths log exception anything else handle empty buffer input chunk
import tool skip empty file issue
parser support join hint
increase local name key space legacy index command legacy index command take advantage token system neon perhaps change transaction one legacy index command also indexdefinecommand contain string map legacy index command transaction refer ids instead string come name key previously space bits yield maximum name key within transaction turn problem scenarios commit extend space bits range name key transaction mean log format change although panic since follow commit deal
make sure new store parse non record data record data
flexible support read multiple versions log entries able read log entries different versions great since make migration roll upgrade easier sometimes even transparent currently neon support read multiple versions although quite commit clean greatly simplify way log entry versioning work whole log header specify format version format version really format version command contain log command transactions assume version log entry start commit version specify format entry data command data still control header log code full log reader factories dispatchers try dynamic select log entry reader use even though look dynamic give log could contain command log entries one version confuse class name log entry parsers name header format version something like log entry start commit version specify format entry data include command data get appropriate reader coventry version version coventry version also detail summary things work commit log contain number log entries different versions mix necessary allow basically seamless non migration one version another change format log format roll upgrade work adhere usual rule master upgrade last write master roll upgrade
change singlefilepageswapperfactory implementation name strip single might want stripe file later
implement position vectored singlefilepageswapper make methods use background flush thread eviction thread still flush page page write significantly speed store flush especially fast storage devices reason vectored speed write odd size file page file page size multiple page need read last block page data overwrite write whole block include last unchanged bytes write back device read slow make progress complete defeat many buffer synchronicity optimisations many layer device vectored methods last bytes block find next page vector eliminate one read allow stream data storage device chunk min time easily saturate write buffer system exception page cache net effect stand good chance write maximum speed underlie storage subsystem
merge remote track branch
batch insert check constraints shutdown shutdown violate constraints batch insert fail exception improve documentation around batch insertion constraint validation
fix creation schema index constraints batch insert commit make possible create uniqueness mandatory node property constraints label property pair
store factory cleanup reduce method visibility modify possible remove unused monitor arguments many constructors invocations
improve deadlock descriptions enterprise lock manager lock client optionally description set include explain deadlock cypher set lock client description execution query master mph set lock client description relatable back slave act behalf
change deadlock resolution strategy forest deadlock detection remain deadlock detect strategy less crude old strategy base number transactions deadlocked transaction queue behind run rather large risk decide abort deadlocked transactions rather one new strategy abort whoever fewest lock hold use lock client tie breaker concurrent test show lower number abort transactions test use case
split new store metadata store introduce new store concept class responsible hold reference store new store also charge initialise store lazily tool continue work incomplete store directories store charge create store file write headers trailers store factory reduce something gather configuration information create new store new store rename metadata store though file still call new store responsibility close store also migrate individual store new store
add method check range empty
merge pull request revert change client cause tyre kick test instability
add detach delete cypher
merge pull request count store fix improvements
support host name cluster payload write int instead byte message length break backwards compatibility roll upgrade work
add get properties name metal properties property container
wrap security rule forbiddingsecurityrules use within security filter
test failure flaky update lonelyprocessingstep issue panic end upstream case exception fix race next import stage schedule start panic exception update end upstream
make storepropertycursor work bug fix verify retry read cursor avoid buffer overflow read long string throw notion exception block record record use read value multiple time property item leak big byte buffer cursor usages simplify code remove never use apr write bytes directly writable channel add unit test
faster consistency checker basically reduce random access use effect cache check part record multiple pass also parallelize store check like index
fix handle large number index range seek since number convert double add index trust lucent properly handle exclusive range lucent inclusive seek result post process get correct behaviour
reuse document instance
fix vectored vectored read write methods properly handle case correspond methods store channel process fewer bytes ask fix retry loop similar position read write methods end work quite nicely java make sure update file buffer position test pain inject adversarial version file dispatcher underlie filechannelimpl put accessible dispatcher delegate dispatcher boot class path turn mean jim start special parameters custom unit test runner bootclasspathrunner implement support bootclasspathrunner run unit test separate process boot class path suitably mangle use new runner test page cache whole singlefilepageswapper use hack filechannelimpls
merge branch
load csc also detect use box file header previously introduce readable wrap input stream possibility also specify default char set box otherwise box control char set
add map builder helper simplify create figs databases
initial work make pec enterprise
remove pool neostoretransactioncontext object pool object turn unnecessary already pool together kernel transactions remove unused class director creator
remove mention old bat script documentation favor power shell add deprecation warn windows bat script
test fix add facilities test enterprise databases
merge pull request add detach delete cypher
increase timeouts use reduce probability test spuriously fail
fix race mode switcher could get stale master client since mode switchers race highavailabilitymodeswitcher charge set new master client switch slave sometimes might happen switch way get old stop client
fix location update browse
run consistency check graph false cherry pick commit dec
provide nice error message constraint failure also add test ensure community edition fail start database contain pec
add ability query index progress index take long time practical user ask database current progress
community server use community launcher
allow chain comparison operators cypher
new drawer change configuration
add metrics kernel extension
add query plan output profile explain bolt
replace usage hit devalue collector
merge pull request merge
improve assertions around backupservicestresstesting
pack stream map stream
merge pull request recover transaction propagation life cycle update
merge branch
merge branch
import tool print stack trace unknown errors stack trace still use even print stack trace know errors
merge remote track branch
remove trailers store file since redundant use determine recovery useful rebuild generators since file way check cleanly close commit remove trailers store note count store rely trailer determine latest version completely flush disk order preserve check write trailer format specifier find header well future reference trailers use migration check store close cleanly since trailers older store previous fine post store best way implement would check latest entry transaction log checkpoint
generate warn load csc eager operator load csc follow eager operator force data materialize memory warn potential problems memory consumption generate
acquire short live read lock entities traverse properties get consistent view property chain lock use inside property cursors
slave pull apply update batch fashion specifically avoid lucent index refresh batch main change make choice index anemone explicit caller rather implicit index service expose mean flush change lucent case refresh searcher two change take advantage transactioncommittingresponseunpacker defer refresh lucent index per batch default unpack also use batch label scan store legacy index update like recovery change make update pull order magnitude faster therefore make transaction gap slave master much smaller also cluster commit faster
use count store simple aggregation query
add test devalue collector
move check urls load csc inside query context allow sophisticate check implement
consider transaction state count store back aggregations node count
start haul eagerness analysis
consider transaction state count store back aggregations relationship count expand test case cover node relationship combinations test without change transaction state
import tool help usage message provide usage example update import tool help message print input parameters provide text update include usage example
rework copy browser guide
merge pull request faster consistency checker
increase semi long timeout page cache test account variable latency
support point distance function
work around unit run issue eclipse
use khan algorithm compute avg function sum function refactored khan summation method separate class use sum well avg update docs make sum avg use gradually type widen algorithms use imply match add exact fit
allow custom accept headers help utility
improve methods open new store use flag add method without flag description behaviour method name
cluster rule use class rule get handy builder methods provide per instance fig use cluster rule static class rule advantage one cluster start share among test within test class heavily reduce test time couple test modify already
merge pull request warn inefficient cypher
initial support create node cost planner
run single process without fork jim sub process fork separate process run jim make process management harder example possible send signal jim process affect process managers expect handle process directly docker system oppose expect process double fork use file syst init specifically mean neon docker containers shut cleanly rather kill require recovery neon respond correctly sig int docker send
run single process without fork jim sub process fork separate process run jim make process management harder example possible send signal jim process affect process managers expect handle process directly docker system oppose expect process double fork use file syst init specifically mean neon docker containers shut cleanly rather kill require recovery neon respond correctly sig int docker send
cleanup power mock dependencies remove power mock usages switch mock case introduce system true able verify call remove exit handle
add map projection cypher
move exception top level class make make package private
port spatial point distance function
merge branch
update use
revert extraction globalgraphoperations globalgraphoperations class bad idea change move operations back graphdatabaseservice
revert change version snapshot revert commit
merge pull request handle create cost planner
release transaction state close pool kernel transaction object clear state early possible close method rather reuse otherwise run risk unnecessarily ensure object clear away negative effect garbage collection performance
disable red default subsume metrics plugin since cause issue cluster mode
add log availability guard
support create cost planner
sync events concurrency primitive sync events concurrency primitive use quickly queue events process background thread useful build asynchronous log
print columns ignore csc import
update dynamic record label batch import update record someone forget call
update dynamic record label batch import update record someone forget call commit already git log say none change
merge pull request revert halfway work identity
revert fix break stuff build break change possibly multiple kid return
cleanup uhf char set name utilities usage switch use char set constant define remove custom helper class char set cleanup handle unsupportedencodingexception switch filesystemabstraction use char set instead encode update code much possible use
clean remove inline pipe rewrite instead rewrite pipe add stack create correct pipe add stack
pull record format record format also add randomize test current record ability easily add format test suite test relationship group format issue find fix simpler finally plug able record format
add docs around file urls security
merge pull request disable load csc file urls root server default
suspicions fail instance ignore fail instance case pause example might suspect instance alive cluster ignore suspicions fail instance avoid possibly mark alive instance fail instance send receive heartbeats mark alive longer incorrectly suspect alive instance instance fail need anything special avoid race generate heartbeats suspicions also generate heartbeat suspicions
remove cluster member versions check check use roll upgrade longer support clean relate code remove obsolete test sign
improve current cluster member role determine cluster members use highavailabilitymemberstatemachine determine role current instance since state machine able deal order message know better actual role state cluster members track observedclustermembers use cluster events figure roles uris etc guarantee information observedclustermembers fully date possible events reorder sign
support delete cost planner
reuse netty buffer backup backup bytes store file transfer use netty channel buffer buffer create chunk data send default chunk size big store amount create buffer huge commit introduce chunk channel buffer able reuse channel buffer currently use backup excessive buffer creation notice bufferreusingchunkingchannelbuffer use queue free buffer subscribe write complete notifications listener clear use buffer put queue free buffer essentially chunk channel buffer trade allocation dynamic netty buffer allocation channelfuturelisteners right thing channel buffer array base structure channelfuturelistener anonymous class capture single channel buffer change test store full backups run tight loop minute jar record show follow result without buffer reuse byte instance total size buffer reuse byte instance total size improvement object allocation would probably visible big store full backups
add enterprise neon harness enterprise test server builders enterprise unit rule basic test ensure server start add test project manual module add test try create property existence constraint enterprise database
add roll apply plan pipe roll inverse unwind operator row pass los whole res execute row produce res single column value extract insert collection use sub query return collections pattern expressions return collection paths pattern comprehension
merge pull request cleanup uhf char set name utilities usage
mean never replay comparison inclusive mean set threshold completely disable plan
call fail apply pull transactions make sure call fail append transaction log could cause issue since mark state fail hence able check point wrong state due miss apply transactions
null merge branch
check kernel health apply transactions order safe side transactioncommittingresponseunpacker check kernel health commit transactions receive master
fix life cycle issue commit process issue result master instance healthy unable commit transactions transactioncommitprocess properly switch commit process switch commitprocessswitcher register listener highavailabilitymodeswitcher latter class notify register listeners slave master switch whole cluster infrastructure start begin communication machine concurrently listener registration result race listener registration notification commit put mode switcher listeners separate life support instance start cluster naxos startup sequence ensure listeners register cluster communication start author
introduce ascend order fix push strategy fail happen date slave select one fail default push strategy fix likely instance high instance however tie instance lowest instance use tie breaker someone want high probability keep master specific data center make hard since two strategies contradict likewise likely real world low instance ids assign together data center master desire mean master run data center low instance ids push happen cross data center also contain fix include settings cluster settings create new highlyavailablegraphdatabases
remove couple unused relate class package enterprise never use thus remove contain class author
merge pull request fully remove legacy index query result cache
merge remote track branch
gather usages dependent bean currently many different place use proprietary implementations get information machine memory file descriptors work oracle able handle oracle ism commit introduce able give information memory file descriptors work job also make relevant place use
fallback ondisklasttxidgetter new store close ondisklasttxidgetter use credentials creation cluster election process mean ready handle case new store stop example copy store master case fallback base current latest commit transaction value
merge
fix code review
handle extra columns csc file use bad file either fail exception log bad file
add master available cluster metrics implement metrics report master available status cluster member change cluster metrics use dependency resolver allow community build build metrics package without cause problems since metrics actually need enterprise feature add additional test cluster metrics available reporters attempt get value previously null interception throw metrics return negative response
bump store version add migration path
adapt text suggestion
add last close commit ids metrics
merge pull request remove dependencies
improve metrics report replace usage proprietary plain garbagecollectormxbean add garbage collection count metric
neon upgrade lucent able use new lucent feature improvements cleanup legacy code write old longer support version give try migrate new latest available version change set represent part require work include change paul horn fix fail test exclude upgrade test disable change include cleanups rethink logic update compatibility code treat baseline
ensure lock clients close role switch observe issue instance switch role reason transactions respect lock transactions hold would lead transactions make change top stale data effectively overwrite change transactions cause among things new lock manager instance create role switch transaction instance pool create lock client instance keep throughout life may transactions still execute time switch role open transactions mark termination transactions pool clear transactions mark termination commit close happily return transaction pool would reuse transactions would termination flag reset point reuse would still contain lock client previous lock manager transaction instance would forever disrespect lock transactions respect would continue next role switch least would chance properly dispose although next role switch would chance introduce new rogue transactions well solution many small issue cause happen number change prevent happen belt suspenders additions although virtually cost dispose kernel transactions part switch pending previously dispose late create new ones would increase chance transactions use lock clients old lock manager use cause harm mark transactions open transactions termination switch role transactions refer previous lock manager around role switch return transaction kerneltransactionimplementation instance mark termination pool lock instance know close refuse hand new clients close top change accompany unit test add stress test quite deterministically could reproduce problem set run longer period time default main build use system property like currently stress test provoke one role switch scenario master pending master although scenarios could add later even broader net catch sort problems
add timestamp non deterministic check accept number expression cardinality calculation
collapse page file ref count last page reduce number volatile read perform pin page page cache number initially separate variables combine single volatile long field call header state header state include reference count page file bits last page file bits plus empty file marker bite page usually bytes mean loose bits reference count term keep large file byte addressable layout look like empty file marker bite file empty reference count bite bits last page error error error iii iii iii iii iii iii iii iii iii iii iii iii byte use mask shift query either reference count last page page swapper return last page initialisation check initialise header state raise bite reference count hold much smaller value could overflow check add increments decrements fine methods call infrequently
merge pull request add notifications result summary
merge pull request remove bolt
merge remote track branch
shuffle lucent index test move rule field unit hook methods top remove empty switch standard matcher instead remove separate process recovery test
unify bolt protocols onto single port move top secure top socket secure socket one single port allow informative message return instruct user encrypt connection require forbid
remove deprecate code report metrics single csc file
faster transaction constraints
add tool build transaction log part commit also introduce generic console input utility help build tool well
format
create complex shortest path test case reproduce limitation
update store migration remove schema label index part migration lucent support existent index part migration remove old index rebuild restore ignore upgrade test current path valid schema label index legacy index address separate commit
move extraction command storage engine extraction command transaction state previously inside kerneltransactionimplementation
begin move transaction application inside storage engine currently construct two store apply expose later move use storage engine well
move batch transactions commit process since transactionrepresentationstoreapplier move storage engine trick plier use anymore batch become first class concept commit process benefit transactioncommittingresponseunpacker place batch need happen simplify code around transaction commit process example transaction append interface previously two ways append transactions log one normal commit one batch commit batch first class inside transaction append could reduce one method similar things happen nearby areas
speed run test module maven command run module take second instead minutes achieve move many test verification phase instead test phase run fail safe plugin instead surefire also test execute parallel
remove unnecessary code graphdatabaseservice wrap snitch class need add complexity
add check hastxstatewithchanges create unique constraint create unused transaction state mark wrongly read transactions write transactions
introduce database migrator concept responsible whole store migration introduce database migrator holder builder store upgrade participants update progress monitor able monitor whole store migration propagate migration participant cleanup storemigrationparticipant interface external service dependencies dependency require particular participant pass constructor particular instance
metrics core edge module add work useful track append index commit index term
document transaction key rest response presence key response currently use drivers figure transaction still open undocumented somewhat accidental behavior add docs test around behavior transactions use rest apr
update core edge license upgrade configuration handle
rename timeout service renewabletimeoutservice
work sync index update allow better performance concurrent transactions make change affect index commit couple change clarify things index anemone longer conflate batch recovery online recovery online always batch since batch first class nowadays latin exudate bite complicate evaluate update lazily access time handle recovery case well change split one instance create per transaction batch feed update every transaction update collect feed index update instance since important update store state previous transaction look end batch whole batch apply end batch therefore index properly flush inside index updater end result whole perform ant less surprise code
add responses protocol message doc
add value join plan run time
set store high instead highidtransactionapplier problem high set call end application batch data apply effectively available transactions apply batch populate index create batch would miss new nod add transactions precede batch
merge pull request core edge add timeout worker group shutdowns server
faster constraints
merge remote track branch
refactor command handler interface replace messy command handler interface separate design batchtransactionapplier transaction applier command visitor
add state relationship command
core edge include last append append response useful follower way behind need tell leader start search match first item catch commit also fix miss equality test depend miss behaviour
accept raw code delimiter import tool accommodate use case delimiter specific character even quote character use
add state relationship group command
add state token command
efficient store scan data structure
remove greedy planner
remove custom boolean supplier
fix count query failures empty database query simple count expressions use optimization look count count store count nod relationships label relationship type would fail label relationship type exist database particular empty database count return
remove custom function
remove custom function
fix shortest path docs
remove kit pool currently kerneltransactionimplementations pool reuse marshland pool thread locals back pool thread execute transactions kit thread local storage reuse reuse kit instance internal state cause quite issue restore kit pristine state put back pool tricky commit remove pool kit whenever new transaction start new kit object create reason biggest reason pool kit transaction state completely reinitialized kit take pool recent storage engine apr refactoring make kit state even smaller make even less things add pool code simplification remove need reinitialize kit state test micro benchmarks via core apr show degradation tiny read transactions read couple nod without label properties degradation read write transactions reasonable size micro benchmarks via core apr show heap usage benchmarking read write cypher query show performance degradation small dec read write query show performance degradation machine hardware thread long run soak test show throughput degradation excessive heap usage activity
add check relationship command
add check relationship group command
merge pull request fix deterministic test case query validation
merge pull request accept raw code delimiter import tool
fix delete col support rule cost cost miss support sonja write rule new bug introduce eagerness refactoring effect
merge remote track branch
cleanup modules test generate neon home directories make test generate folders relative impair case update maven surefire plugin module target cleanup git ignore file
let storage engine charge provide command reader aspect break coventry version command factory interface coventry version responsible provide parser log entries command read one aspect one entries command entry neon regardless storage engine use hypothetical since currently one charge log entry layout storage engine must charge command part since coventry version public end provide command reader users log entry read concept specific log entry parser since use whatever coventry version provide coventry reader inject many place even request type end change able accept coventry reader inject many place even request type end change able accept coventry reader instance
introduce disk store allocation implement yet wire
add check new store command
make coventry reader command reader immutable one per database crucial since instance provide storage engine resolve via dependency resolver place well part command readers use odd style internal command handler assign channel back door argument visit methods command handler unnecessary pattern make command readers mutable difficult work
introduce adversarial page cache page cache implementation able wrap give page cache introduce misbehaviour exercise user code either throw return page cursor inconsistent read misbehaviour control give adversary change page schedule use adversarial geocache
simpler count store implementation count store provide methods update read snapshots request snapshot return snapshot count store transaction equal greater request transaction snapshots also provide methods serialize log
remove browser module repository neon browser move rep rep pull latest version neon browser dependency
normalize eager nation test eager nation test assert many row return move test eager specific file check eager correctness rule cost
clean around pipe sort pipe cypher two change commit first sort limit logical plan remove instead optimisation step postpone build pipe second change pipe take sort description instead sort item align sort pipe
rename plan description use capitals
make default access method private
reformatted weird look line
fix handle self sign certificate bolt ignore user settings always create new self sign certificate boot change server bolt agree settings certificate private key
remove validation index update commit preparation remove upper limit number nod exist give index remove bunch code relate probe reserve space index commit transaction otherwise throw specific indexcapacityexceededexception commit process things around index modifications simpler
merge pull request make test faster
rely netty selfsignedcertificate
introduce partition lucent index folder layout introduce index storage abstraction responsible physical representation index folders directories etc update lucent index possibly splitter several partition new index folder layout new partition create demand label scan store continue use simple folder structure include partition
improve code quality simpler count store improve code style move serialization serialization class make count snapshot data class remove test test redundant add test highest oversee method outofordersequence fix bug highest oversee outofordersequence remove write lock count store final part get snapshot reorder statements update make redundant still preserve thread safety update explicitly throw exception attempt get snapshot previous snapshot attempt underway
move deprecate generator relate class internal package
remove deprecate code kernelextensionfactory
less loader instance create create one per store database instead one per store transaction
remove dependency kernel statement compiler package know kernel statements instead pass via
update lucent index accessory use new lucent index abstraction label store break atm
introduce cap logger replacement cap operation fix problem slaveupdatepuller log every exception really make sense transaction propagator also change use cap logger fix similar weird log behaviour code
fix index sample art share index start work label store index reader responsible creation index sampler sample share non share index different depend reader start move label scan store use new lucent index infrastructure commit make things compile many fail test commit move scan store reader correct package make responsible read node label range scan store
merge branch
ignore couple test cleanups rewrite lucenesnapshottertest use new lucent infrastructure use memory lucent directory instead mock ignore fix lucenelabelscanstorewritertest test pageofrangesiteratortest remove underwriter accessory check give index writer close
merge remote track branch
license headers
license headers
merge branch null merge license headers
byte code support class methods
bolt reject nod res paths parameters encounter node relationship path parameter bolt throw exception
call default super constructor necessary explicit call super constructor make top constructor automatically generate byte code call default constructor super class
remove unused deprecate things server fig
remove code transaction ally create drop procedures keep procedure signature friends well get procedure primitive
merge pull request clean shell script
break graph database apr kernel component require things break well neon collections neon resource also take good opportunity remove bunch class interfaces deprecate long time
replace failure back image failure reset
retry replication lock session change previously would give maximum timeout suitable leader lock management strategy probably strategy either since lock session change exist safe natural abort marker use instead
merge pull request ability import billion nod import tool
turn vote store proper file recoverable state repository
integration test staterecoverymanager state persist
support try catch finally less rewrite try catch finally apr point view look behind scenes actually create entire try catch finally one
refactoring write orient channel separate log use ready general use
add test add line error message unbalance quote without multilane field
add randomise test open multiple page cursors
fix raw support quote char csc import fix
rationalise disk directory layout file name raft log cluster state
add support multi partition read schema label scan store lucent index introduce readers case index contain one partition readers available partition combine result index clients observe difference compare single partition index guarantee order client receive result different partition add possibility perform multi partition sample unit integration test new readers provide currently partition task use common fork pool change performance impact test measurements
remove accessibility new store storage engine even dependency resolution force change place hard dependency new store pull storage engine place need access whatever use kernel apr instead couple methods add still test access new store test detail still valuable test test convert time depend new store directly convert entirely test revolve around new store recordstorageengine method testaccessneostores matter
license
add contain capabilities index abstraction
support throw exceptions
support declare assign
support rewrite syntactic sugar loop correspond iterator since way byte code look anyhow
untangle collections primitive collections
merge pull request cleanups around metrics extension
switch latest unit fix affect test cleanup parametrized object couple kernel test full release note unit find
enable byte code generation bird
add cost planner
improve deadlock resolution strategy enterprise lock manager deadlock detect rather likely multiple participants deadlock realize time deadlocking want minimize abort code choose deadlocking party bail code sensitive ever code path party think abort would end real deadlock rather avert currently strategy look wait list client highest number wait clients allow continue client abort however strategy sub optimal partially data number wait clients unreliable mainly good tie breaker clients size wait list clients number clients wait abort modify hopefully make code bite clearer tie breaker clients level abort base client ensure one client abort two strategies choose feature toggle allow real world trail two prominent deadlock resolution strategies two strategies introduce base count lock hold rather count current wait list abort young assume higher throughput achieve let transactions lock hold presume older finish young transactions fewer lock abort abort old assume old monolithic transactions hold line higher throughput achieve abort transactions lock set nice precedent introduce transaction priorities could choose abort transactions lower priorities something consider future improvements
ensure auto stable close commit move bunch auto stable inside try resources block use try finally simply properly close
ability specify fig import tool array block size string block size may specify along create store
move auto index implementation core apr yet another step towards decouple legacy kernel code cleaner kernel apr past auto index handle unsurprisingly node manager god class auto index enable like facade enable track update list share reference kernel list trackers generalize system track properties never use add remove single auto index tracker node manager nothing auto index hold onto state relate auto index update whenever change chain facade set property kernel trigger tracker legacypropertytrackers facade tracker trigger data items update finally configure side effect call gds constructor commit change core apr act apr delegate auto index operations special auto index service reason like rather add kernel primitives auto index configuration set entirely run time transactional propagate cluster simply run time state auto index service share core apr kernel encapsulate auto index logic mean enable auto index look like facade enable track auto index enable property change propagate directly kernel without back core apr facade set property kernel auto index change data items update
introduce time rule make graphdatabaseshutdowntest faster
complete debase contain index
deal lead trail white space import
merge pull request improve numeric index uniqueness verification speed write performance
reduce flakiness test first change introduce slave member cluster test actually guarantee become master test previous method susceptible race condition second change introduce small sleep shutdown method test cluster reduce likelihood race point
rename delete better reflect functionality
multi thread lucent index population commit introduce batchingmultipleindexpopulator able populate multiple index time use multiple thread utilize lucent ability perform multi thread index concurrent flush documentswriterperthread update transactions happen concurrently index population queue serve certain threshold reach popular await previously submit flush task complete flush concurrent update add internal set flag enable disable multi thread index population factory create populations base set
change record format name current low limit small fix
remove legacy store favor normal store inject old format record format specify outside point duplicate legacy store code read older store versions thing need instantiate normal new store use older record format read record normally make store migrator generic less hard cod migrate specific format instead ask format may need migrate use information create correct input batch importer add concept record format capabilities record format specify capabilities store migrator tell two format differ use appropriate migration give format heavily reduce amount specific version check need migration code
introduce ignore latest trait work acceptance test series commit
make rest serialization work delete entities nod relationships delete return query get properties serialize instead get boolean field delete set true commit solve graph row serialization
replace marshal core edge encoder decoder interfaces use different name essentially work interfaces without offer benefit commit make uniform use marshal everywhere remove serialize interface use anymore remove raftcontentserializer use anymore collapse store marshal change prepare single file append raft log implementation naivedurableraftlog change use byte quite inefficient subsequent commit remove altogether long functionality remain performance regressions important
implementation physical analog work append rotatable raft log base physically file support class include raft log entry cursor also introduce pro proper record contain information commit truncation action besides already exist append iteration log happen via two layer cursor one iterate record another build state determine entries commit truncate append rename physically file haman transaction haman entry remove notional dependencies elf transactional concepts since want use elsewhere pro rotate change versions via support physically file log versions maintain scan filename suffix present disk instead dedicate file storage like log change semantics patent restore cursors may request index previously implicit assumption cursors return patent restore would position request index true current implementation instead physical analog assume cursor must iterate desire index reach also require cursor return patent record instead ratio entries possible compare index
support return delete entities serialization format able correctly return delete nod relationships
introduce script import databases path part work change way allow operators specify database run prior take arbitrary path onward take name always find path data databases need way allow exist databases pull structure elsewhere also introduce start new operational surface neon admin script provide entry point command line operational task import backup
fix read start buffer bug redhead channel
make cluster manager able find free port problem build show case port available make test fail change make cluster manager actually look open port use test cluster cluster port probe port probe free port find among assertion trigger
order rollback lead state error send order state machine end state ignore subsequent request
move cluster manager test
introduce limiter remove background page cache flusher limiter allow check pointer flush rate sympathetic urgent task need append transaction log commit limiter however yet integrate check pointer remove background flush page cache also allow change sequence lock allow read write concurrent flush also implement
add configurablecheckpointflushcontrol allow people configure enterprise edition reduce pressure check point currently still test need write check interim plus need describe manual
raft enable disable via fig disable default per production norms
merge branch
move deprecate cypher class internal package
merge branch
add antler grammar result partial implementation parser specify format tick feature result file also include generate java source antler parser
override auth manager use apache shirt
support query multiple label ids labelscanstorereader cherry pick commit feb
replace
add authorization use static group add single group per user file user repository authorize use static map group role add user access mode test add separate shirt auth manager test file
bolt use graphdatabaseservice execute cypher query
clean generate file test
simplify windows power shell script commit greatly simplify power shell script use install configure administer neon instance microsoft windows operate systems batch file simple wrappers invoke power shell add bypass power hel invocations reduce friction first time power shell users number publicly available function administration module keep absolute minimum reduce require code paths constantly check input parameters due less code paths less test require power shell invocation keep inline unix script much possible remove level version support module support power shell module add neon detection environment variable set bin path relative script use update power shell new configuration file paths add code git ignore support power shell development use visual studio code
efficient reuse statement instance kernel statement instance couple kit instance follow initialize call likewise store statement instance couple kernel statement instance start new transaction extremely rarely create new kit instance otherwise time pick one thread local instance already create wait call initialize ready use likewise start statement call kernel statement acquire turn call storage statement acquire statement state still create instance reuse new statement already kernel statement commit remove external pool storage statement instance since longer need net simplification code
make transaction handle rest apr mark tvs implicit explicit
add support canal record metadata store useful implement block device migration
fix sundry typographical errors
add test clean procedure call within query
efficient genre resize allow get record size inline commonabstractstore
cleanup transaction management rest apr
reuse record cursors store statement previously kernel apr cursors directly use store read record mean open page cursors time pin spin page cache page commit make kernel apr cursors use record cursors record cursors keep underlie page cache cursors open long possible thus avoid excessive pin units record cursors also keep open pool kit part store statements
simpler data structure index population currently multipleindexpopulator store populate index concurrent map need multi thread population mode individual populations fail remove form map different thread concurrent map add part introduce multi thread population mention concurrent map traverse node visit store scan forward update relevant populations repeat iterations turn quite expensive store many index commit make multipleindexpopulator use copyonwritearraylist store populations
fix issue relationship inconsistencies may overlook initial design flaw mismatch one part code another relationship record process expect record divide node ids record distributor relationshiprecordcheck code expectation would effect relationships would randomly check depend many thread machine run check
load auth manager service auth manager load service base configuration value reverse dependencies security depend kernel auth manager manage life cycle use repository internally separate enterprise auth manager create
add documentation examples call yield
rework parse representation feature result instead construct implementations java apr interfaces node relationship path parser listener create matcher object contain logic determine whether equal object return withing neon commit plug matcher creator add matcher class integers float
update assemblies include new lucent cod library
merge pull request fix issue relationship inconsistencies may overlook
merge pull request clean fig
merge branch
fix data race bug consistency checker multiple thread check nod correctly index would use property reader instance double check value look property store happen recent change make property reader non thread safe property reader would allocate single node record use obtain initial property pointer node record would end share thread could end read property pointer wrong node make look like read wrong property value store fix allocate new node record fly every property value lookup
add authorization rest add access mode user principal authorize request wrapper start transactions access mode user principal acquire help request context add pass authorization filter auth disable add authorize request wrapper full access mode
fix issue would process unused record process code assume use record would problem first foremost relationshipnodesqueuedistributor decision send record process might end invalid thread send
small clean
add default cluster join timeout test
increase cluster test robustness use variable port also remove obsolete cluster configuration cml file
increase cluster test robustness use variable port also remove obsolete cluster configuration cml file
cleanup brush enable iterators helpers rename iterator tip iterators move methods expect operate various iterators iterators helper move methods expect operate various enable enable helper
merge pull request store migration enterprise format
disable flaky test windows
send severity notifications
allow edition spa edition modules expose various top level functionality make integration test cleaner
clean handle raft outcome outcome handle mess important point careful compare state outcome make explicit pitfalls like compare already update state instead old state avoid
implement temporary rush check interim rush mean limiter temporarily disable flush fast possible useful recovery store copy like backup
make membership waiter block leader commit available execute catch algorithm moment unnecessarily wait round first round catch leader commit nearly always since code path raft machinery run commit introduce job block wait leader commit code membership waiter waituntilcaughtupmember rely membershipwaiterlifecycle timeout leader commit never discover
fix issue change password procedure add bolt integration test new build change password procedure fix access mode beginimplicittransaction bolt session state machine expose restrict access mode neojtransactioncontext change access mode read query plan make token lookup lazy val transactionboundquerycontext able execute query without read access
process property update particular node single update index population group update properties single node container process atomic fashion update process check population queue current node update need process single unit avoid duplicate index appear queue already contain update current node property
remove raft log entry exist unnecessary confuse
query log user name connection detail bolt
first draft make use log infrastructure currently fail number test still assume configure log back cml file actual log part less configuration part still air another thing need look help log line format try best make log framework print line look like log back pattern sure good enough yet
add process block mode run boot rappers intend use windows service wrapper pro run apache commons daemon replace short live run file base approach pro run provide good support
aggressive inconsistent read page schedule previously return zero adversarial page read cursors inconsistent read count number operations perform page cursor choose one tell reader retry return random garbage data point close operation find many many case faulty use page cursors
merge branch
report correct process time producer step include wait time send downstream
use version neon browser
fix copyright year
initial core core copy support copy store state machine snapshots core server another leader serve request log entry follower reason compaction follower send compaction info message follower follower subsequently trigger raft state machine perform complete copy state
fix election performance issue timeout exception occur disconnect member would reconnected always reset complete test network pristine state iteration also wait initial member set fully propagate start scenario members electable
align limit election performance look statistics gather new limit accurately express want feedback keep false positives minimum still flag major regressions set
adjust header size
fix flaky metricskernelextensionfactoryit give max time read metric csc file since exactly sure get
merge pull request core core copy
allow set certificate directory hard code filenames
efficient reference decode current reference decode need loop pick appropriate decoder mean quite number memory load method call commit make decode compute shift mask fly minimize memory load result code also contain less branch
revisit preserver replication make robust better express remove unused test
diverge physical raft log share kernel implementation physically file friends work well need truncate log file require raft log implementation commit duplicate class core edge module intermediary step simplify class core edge side also temporarily increase visibility kernel class make move possible commit also remove store commit index responsibility raft log implementations since honour literature treat commit index volatile state
fix compilation errors
return forbid integer minus one generator since invalid would interpret null read
enforce consistency access array non integer index value problem use non integer index access array fail semantic exception index type know advance integer use literal whilst success run time coerce value integer use parameters behaviour confuse predictable hence change make case fail first semantic check second run time
improve language texts
edition base record format selection commit remove current dynamic format selection replace edition base selection record format depend specify database edition able pass format configuration parameter override default value property use
merge pull request make sure limit respect
edge need enterprise read property existence constraints
rewrite
merge branch
add pattern comprehension cypher
exception free branch free page cursor bound check perform bound memory access page via page cursor longer throw exception reason might inconsistent read fool decode logic compute wrong offset data try read data fit page previously bound access would cause page cursor throw exception inconsiderate fault decode logic feed wrong data trick bound access instead raise boolean flag cursor experience bound access flag check decoder check read consistent decoder make decision handle fact bound access present record format decode logic anything change yet complete make something next commit
merge pull request diverge physical raft log share kernel implementation
merge remote track branch
add tag
remove explicit directory configuration test longer necessary modify kernel put directories database directory run embed test automatically clean content directories default locations
merge pull request allow use call together periodic commit
fix minor issue assert eventually align regular expect time semantics mean final sample fail case take specify timeout evaluate result reuse description failures interrupt exception throw instead blatantly ignore lead clearer semantics possibility discover errors due interrupt handle shorten arbitrary poll interval still slow poll rate computer yet might shave time test actually really user configure fix
stop test leave log directories lie around
revert move core state recovery later revert commit
add miss tag constant
clear default value
merge pull request improve documentation neon script windows
import relationships per type better scalability data set nod dense contain lot relationship type problem keep track update head relationship chain node relationship cache scenarios nod dense many relationship type scale poorly regard cache memory usage also side effect time require update cache previously relationship group would need present cache add relationships different type dense nod would create group cache link use pointer simple array back cache memory usage would steadily increase type add find group specific type would expensive due linear random access pointer chase result poor performance inability import solution approach instead multiple iterations iteration import relationships single type iteration node relationship relationship relationship stag dense nod run cache reuse hold relationship chain head next type next iteration relationships import way finally one node relationship relationship relationship stage link sparse relationship chain together
fix subtraction
fix compilation errors relate bad import
make store copy backup work custom record format configurations require members cluster backup clients configure record format however problem store copy start temporary embed database recovery copy transaction log embed database tell record format database whole ben configure thus would fail start fail recover copy database non default format configure
fix comment example address fig something reasonable
fix license filename
clean try catch code generation
merge branch
switch editions tool use community format update record format selector select community format except configuration option specify adapt test use community format
revert update netty version revert commit
mark order acceptance test port tick
simplify configuration code generator
add efficient test
add efficient null check primitives
include secondary unit ids high track apply transactions previously secondary unit ids track might lose crash master switch might result record reuse secondary unit highest one store
first draft get readable channel page file
add support readable rechannel view adversarial gentile
use label scan store index creation instead switch label scan store determine list node ids specify label index population case label use mark significant amount nod give noticeable performance boost case label scan store index exist yet full node scan use code cleanup handle concurrent update index population queue till finish nod available label scan store case use label scan store source nod possible observe follow situation update node node node node case update node come node process case sequential node scan visible next step case use label scan store since current index reader gon see update able handle case case see nod part already bypass queue update till end population replay afterwords sample index build use label scan store scan population completion use specialize sampler perform index commit reread value index since rely population data
add simple check style java first commit merely introduce check style build check style execute main test java source file maven validate phase also possible manually invoke check style command use code style provide check style sun google style would result many change reformatting whole code base custom check style rule set add define follow check one license header exist rather simple regex check tab character use new line end file exist line trail space consecutive empty line exist current rule set minimal format accordingly rule actual java code style add later
merge branch
print list cypher list previously call collections remove another trace
skip unused property record read chain able increase property read throughput read tolerant concurrent update property chain one step skip already remove properties store property cursor skip unused record read build chain use record exception record use throw anymore author
merge remote track branch
read unused dynamic record read chain without short live lock read property record correspond dynamic record atomic first property record read correspond dynamic record read might result read inconsistent property value concurrent load commit allow read unused dynamic record data reachable chain author
add package declaration check style rule rule ensure class package declaration
mark test port tick plenty small cleanups cypher style test variable name usage instead
introduce geophysical raft successor physical analog work progress wire anywhere test pending well
segregate physical segment log implementations proper package
add newline end file
name segment raft log
parametrize segment log contract test idea functional behaviour change due cache different cache size
move shiraz manager enterprise define constants fix role name string
refactor password policy create password policy interface extract password validation basic subject
fix databaserebuildtooltest break change implementation
bump open cypher version include latest tick
resolve paths fig relative neon home
make discovery build procedure callable client bolt
new tick error require relationship direct
mark createacceptancetest port tick
automatic detection record format commit remove need always explicitly configure record format something else default mean previously tool like consistency check backup always need explicit fig parameter apply high limit store detection format happen inside later often directly use tool like consistency checker
add checkandclearcursrorerror feature help simplify design around consistent record read report errors stack
fix issue map size indexdefinecommand previously byte size larger would produce negative value read value larger would trim data lose would prevent key value pair read properly read command size short proper size check make new log format introduce like coventry version enable multiple versions exist backwards compatible change database start clean non clean shutdown read write new log entries new format note additional care coordinate future log format must take forward merge
support group role repository enterprise flat group file map group users statically map roles shirt wildcard permissions
remove skiplimitacceptancetest port tick move one remain non open cypher acceptance test orderbylimitacceptancetest
remove short live read lock property read favor technique track open transactions free ids safe point time code read lock remove consistentpropertyreadtest show properties still read consistently change log read properties scale better longer need acquire read lock also remove set
extract common docs tool
respect record format copy store edge machine
remove part shortestpathacceptancetest port tick
extract backup docs
prototype finish test maybe compile run continue
change error message incorrect role file error message reflect fail hard read incorrectly format role file fix test name assertions reflect
use basic auth manager default turn shirt base enterprise auth manager default enterprise edition
allow relationship ids reuse introduce feature toggle enable relationship reuse reuse handle standard mechanism relationship mark free active transaction overlap
simplify lock client termination commit make lock clients internally know termination remove need pass info kernel transaction
merge remote track branch
make possible run consistencychecktool without system exit failure
support multiple expressions take multiple expression assume add together also add support stand alone expression
format
preparation resource ids
refactor state machine allow batch state machine get callback call result rather return optional result
batch applications notify new commit entries raft instead apply one request time try group request batch apply together possible note code make sure mix application request since could unsafe
make incomparable value type exception temporarily blacklist scenario update open cypher
start work suspend users boolean imply user
support log level set server extension loggers support log level define store internal log level set server extensions loggers
move test acceptance module remove port test remove duplicate test group test tick purpose
address problem instance partition away cluster instance acknowledge case suspect every instance effectively interpret case lose connectivity reaction mark cluster members fail lead instance detect loss quorum therefore become unavailable restoration connectivity sufficient instance make instance available give behaviour handle case current master instance partition away slave detect master become unavailable set pending state wait election new one finally test change previously assumption partition instance would maintain status longer true back port forward merge
fix load procedures enterprise
mark createacceptancetest port tick
allow type configurable edition base configuration type allow type usability configurable database edition configuration introduce enterprise edition specific configuration settings able distinct specific settings perform custom configuration allow relationship ids reusable enterprise editions
add special faster handle use cache
improve performance check commit change output order operations use hash cod hash join distinct group aggregation
suppress stack trace know backup exceptions unknown exceptions catch still print full stack trace second step backup tool verify exceptions throw currently complete snake nest different exceptions throw catch convert exceptions catch convert etc
merge pull request set turn termination aware lock
completion suspend activate user general purpose flag user class serialization clean user builder add use test immutability improve authproceduretests suspend activate user
run security integration test enterprise pass testgraphdatabasefactory parameter bolt integration test setup use enterprise factory enterprise test
refactor value join use equivalent
slave master lock session termination commit make possible terminate lock sessions slave master useful terminate write transactions slave correspond lock clients master havelock client stop end correspond lock session master stop local lock client feature guard settings default
clear buffer ids role switch buffer ids get carry test class idbufferingroleswitchit show problem would cause
fix flakiness test rely observe keep live reference internal data structure page cache shut quite unreliable additionally produce ton old gen heap pollution mechanism provoke natural old gen garbage collections
implement list roles procedure
change login method take auth token map bolt already get authentication information client map instead extract username password within bolt basic authentication pass map auth manager login cater advance authentication mechanisms
add enterprise security settings
slave see record read contaminate record reuse master master buffer ids specify time call safe zone within safe zone window record guarantee reuse slave update puller make sure transactions break safe zone boundary kill transactions fall outside pull update transactions store latest apply transaction commit time start kill transactions new transactions pull master get apply compare store commit time new latest apply transaction commit time apply batch batch span greater time fit inside safe zone transactions start slave entire batch apply safe zone configurable set secondary change add knowledge last commit timestamp metadata store store migrator
ability clone csc header data structure since contain extractor state full parallel process scenario must clone process thread
core edge commit batch edge machine include major overhaul two major class poll transaction apply
merge remote track branch
merge branch
remove conflict mark
merge branch
remove bolt address core member instead store bolt address map key core member
fix merge mistake
merge pull request add comment explain expose tip
fix relationship group type overflow command readers previously primitive short read channel convert int use implicit widen primitive conversion could lead negative relationship group type fact short value represent unsigned short commit make sure command readers interpret relationship group type unsigned short
fragment relationship group part import importer change import relationships per type mean relationship group scatter read query take hit compare previously commit introduce relationship group fragment write use normal batch importer stag step run part import relationships import
fix concurrency kit market termination kit close possible thread execute transaction termination run concurrently thread commit transaction without proper synchronization follow issue could occur termination thread stop lock client return pool commit concurrently termination thread termination thread mark wrong transaction termination commit reuse pool concurrently two termination thread race stop lock client twice commit fix problem introduce lock release market termination later method also make smarter check logical transaction version represent reuse count field
create multi realm auth manager big refactoring enterprise auth manager add new multirealmauthmanager eventually replace shiraz manager inherit basic manager add realm configurable security settings add enterprises manager interface let internal file realm implement enterprises manager still need move login logic file realm
recreate login logic internal file realm logic internal realm handle password change require rate limit move internal realm multi realm auth manager move lap integration test test class add usermanagersupplier interface support different ways auth managers provide user management change multi realm auth use firstsuccessfulstrategy note rate limit work single internal realm
remove server address raft member identity remove generic type parameters raft class return empty topology derive hazel cast
merge pull request store cleanup
rename file realm internalflatfilerealm
split core convert tool two generate cluster seed tool well take care generate cluster seed use core convert tool make sure end restore exactly state server restore core edge cluster
update depend cypher compiler
add unit test shiroauthenticationinfo merge rename shirorealmlifecycle really recycle
add default value procedures
cluster members become read disconnect cluster mean ensure safety instance get detach majority cluster revert pending state implicitly raise barrier disallow transactions start exclude way possibility read operations still possible principle albeit forfeit date data commit make cluster members longer participate quorum revert pending state without lose ability perform read write still course disallow side note test try verify behaviour instance connectivity quorum lose abruptly include behaviour test part patch fact fail bug previous change bug solve different commit test enable
abstract authproceduretestbase eventually support test different neon depth
separate test logic test depth eventually support test different neon depths
extract common base class
use graphdatabaseapi interface rather graphdatabasefacade directly
proper error handle single new line query
add logic check database date art give miss commit need track ids write order maintain version date
logout user password change
resolve authprocedurestestlogic fix several case admin try delete suspend degrade add authentication check
add support update version use transaction track
always close prevent test hang
log tunable frequency member know address
support multiple expressions
mix perform write mode procedure invalid throw exception perform write procedure mode use together
authorization lap group role map add settings configure lap search user group memberships result map internal roles static configuration set map add documentation security settings make possible restart neojwithsocket test database override settings individual test currently support lap search use configure system account
fix test expect wrong exception
support lap search user lap context lap authorization enable use system account disable search group membership authentication user lap context
tidy cluster class separate create cluster start
shutdown edge server local database empty avoid copy store override local data
merge pull request change procedure annotation
set correct commit transaction timestamp collect log startup present store also move java doc add test
add support check store edge server startup edge server startup local database empty check local store store one core server case edge server allow join cluster otherwise join shut
mover store check edgeserverstarupprocess local database
copy shell present folder
merge branch
simplify exception handle
fix flaky test rely finalise collect page cache instance longer reference always finalise object hard try promote old gen heap get away young gen collection test fix make pollute old gen heap much aggressively apparently previous old gen pollution would often never leave eden thus little effect effectiveness new heap pollution verify log inspection across hundreds test executions across major garbage collectors parallel cams flakiness test drop one false positive run less observe failure since change one garbage collectors
static cache array import better performance cache instantiate later maximum size know static array instantiate faster dynamically grow array importer faster whole creation array still fallback split heap fit either completely case still perform best case better
ensure security procedures provide status exceptions
add test defer lock
add new admin tool
clean load auth procedures fix name class test
make transaction accessible kit commit transaction assign commit kerneltransactionimplementation assign transaction roll back read currently possible obtain commit transaction kit implement auto loveable commit happen close however might sometimes valuable know commit transaction track commit make kit expose commit via close transaction method still keep kit auto loveable
move legacy merge acceptance test open cypher back product
add auth plugin realm support
introduce new parameter syntax introduce new syntax parameters cypher para
open label scan store read mode case database start read mode refuse perform write operation mode temporary disable couple non friendly lucent test
support name paths pattern comprehensions
merge branch
merge pull request always remove entries read inflight map
merge branch
merge branch
address break list transactions test
open lucent schema scan store read mode case database start read mode refuse perform write operation mode temporary disable non friendly test
add public check method return outcome outcome boolean false mean inconsistencies find true log consistent
let neointeractionlevel check auth status expose authentication result make sure rest make new request expect fix test check error message
add test lap sail authentication mechanisms
knowledge defer lock abstract away kerneltransactionimplementation introduce statementlocksmanager
restore fix previously ignore consistency checker test
introduce consensus module smaller module extract enterprisecoreeditionmodule raft instance raft log order avoid circular dependencies raft instance handle return commit index throw snapshotrequiredexception instead trigger callbacks rasta machine
core edge dump cluster state tool
add authentication exception plugin apr move really recycle plugin spa
allow plugins implement separate auth interfaces plugin implement authentication plugin authorization plugin instantiate one plugin realm instance duplicate test refactoring
extract corestatemachinesmodule
prepare standalone election performance build
fix election performance production code change modify bootstrap logic account new design raft instance notify commit may call multiple time log index
input parse data parallel take advantage able determine data row start another end multi line field disallow case chunk csc data read hand one thread parse data finally end merge back order read csc source outside difference still provide nod relationships
move defer lock separate module service new module enterprise defer lock introduce components load via service loader jar obtain module also include package
check blog use exist mechanisms extract transactions multiple log instead check individual log file reason order vital correct result less simpler code check blog well
symbolic name may longer start currency symbol since new parameter syntax use dollar sign longer allow start character variables symbolic name parse reason ease implementation consistency full class unicode currency symbols exclude set start character symbolic name
restrict type store set node relationship node relationship reuse support commit make correspond set accept list tow value
remove unneeded run plugin
merge pull request replication module
take lock entities create transaction need take lock new entities yet commit yet visible transaction contention lock change significant impact except cost acquire lock high example acquire lock slave cluster lock acquisition require network call
rename server member integration test
attempt fix updatepullerswitchit flaky test assumption test fail thread name detection method pick update puller thread leave behind test instance configurable cluster builder choose unusual instance allow detection work properly short term measure detect assumption correct investigate test clean properly fix
repackaging
rename raft package core consensus also rename raft instance raft machine
update cypher compatibility mode dependencies
fix reference enterprise format variable length encode reference decode encode record enterprise format take additional time minimize damage common case small record possibility fix record introduce case record encode fix reference format criteria base reference use record use instead variable length format case record encode fix reference format default variable length format use
bolt server refactoring split state machine harden security
null merge branch
introduce constants various bite mask small refactoring
merge branch
merge branch
port consistency checker neon admin
print constant line instead
clean acceptance module convert test tick scenarios move leave test small class larger ones rename test class accurately reflect content improve test structure
remove test expect pessimistic schema lock schema lock optimistic use defer lock commit remove test expect lock pessimistic
merge pull request acquire lock defer commit time
core edge move file creation recovery state storage
make core state download snapshot private non synchronize particular method public use coretocorecopysnapshotit also reason declare synchronize nevertheless usage still cause exceptions throw race condition besides test test something valuable test rewrite test behaviour cluster member snapshot copy store delete also remove non private usage method make private synchronization longer need guarantee queue front core state handle
graceful shutdown edge servers edge servers shutdown gracefully remove cluster topology
introduce new high limit format generation high limit fix reference introduce generation high limit format add test backward compatibility newly introduce format fix reference old format verify read record store base high limit format
fix bug neon admin set password add
support create initial user set password
ensure create false behave correctly
add informative output set password
conflate exist users password
reap unavailable edge servers cluster overview edge server disconnect remove map servers cluster overview procedure consume edge server become available add back map
merge pull request access transaction commit time commit
merge remote track branch
resolve paths fig relative neon home previously commit bash script neon share modify set common environment variables prior run java tool particular admin tool require neon conf environment variable commit modify common function populate directories process level environment variables per bash script commit also remove lot trail white space leave test file
merge branch
add bookmark facility bolt server bookmarks encode transaction use support causal consistency supply bookmark generate one server subsequent transaction second server cluster second server ensure subsequent transaction see state least date state see first server throw exception case timeout
update docs procedure call word default argument example
fix correctly return mutable map result value
core edge various cleanup remove duplicate code raft log
rebuild index fail open index online fail open startup would able apply update would thus become inconsistent database index possible open restart database would end inconsistent index situation describe handle treat index permanently fail take action correct first possibly important action log failure something recognise thing user could restore index would either drop recreate stop database delete index store file disk restart database automate second option avoid need restart since already startup phase happen simply treat index incompletely populate instead force database rebuild index without intervention
ensure index proxy return correct fig perform recovery constraint index index proxy would contain index configuration object say normal index rather constraint index want index tentative phase instead online state immediately issue solve separate configuration index whether flip tentative state nothing code depend index configuration object correct recovery possible code could write future
ensure set password respect default user behaviour server
test show configure cluster start
fix grammar error message make specific
aggressive multi thread test work sync
introduce file acceptance test implementation
expand set password user management neon admin command line set password command replace users command sub command list users create users optional change password requirement delete users set password original capability
move user management community edition
pass clock parameter kernel components introduce way override clock custom implementation whole datasourcemodule introduce transaction guard integration test apr call cypher query
store server read page file map exist perform store copy story server try get byte channel map page file map exist otherwise behave get byte channel file system make possible support store copy device external normal file system
support return point type paras later query
implementation build schema procedure
cross platform line end
log edge server startup retry failure
store client write provide page cache file store file perform store copy file store file story client map target file page cache write file open byte channel page file file store file behavior make possible support store copy device external normal file system
reduce unnecessarily liberal access level
make query log include username query log include name access mode username part log message solve make implementers use provide transactional context acquire username put already print query log
add procedure creation roles
remove custom tick clock
revamp parallelism part batch importer main story compose two things new forkedprocessorstep parallel nation inside batch execute one one avoid difficulties parallelize step costly section parallel table new step items batch strip fork processor know part process better mechanical sympathy stag optimize work batch size match page page cache store mainly work fork processor simplify couple stag artificial additional step split otherwise modify batch better parallel table also whole stage scale better add processors old way parallelize stag often involve step single thread act divider work step would often become bottleneck end anyway mechanical sympathy main problem previously reader writer stag read write store actually contend give smaller batch size multiple batch read record give page later stage store update would often update page reader still read page would need much retry read slow whole stage align batch size reader contend writers page cache additionally main store update step split step update entities properties separately entity update able even faster net result change whole often disk main bottleneck test machine development laptops performance improvement importer observe
enable test comment years ago good time
create dump load facility
use cluster rule log always delete use cluster rule due limitation test directory rule problem latter use static context see single test failures hence effectively delete file disk problematic failures need log understand happen debug purpose commit fix problems
wrap transaction try catch
increase relationship type take bits high limit enterprise record format update relationship record relationship group format
create self static binder neon log provider
add procedure delete roles
add require shortchange default true procedures enable access user
remove unused class file remove unused variables
get rid bias winner strategy node demote kick normal election rather ensure win deal scenario master away return time vote request send commit reject vote request make sub optimal choice new master
add log creation deletion users
add name space function call
support point create geometry type
move query registration statements
add acceptance scenario security log
add support secure lap start lap add boolean set use opportunistic tvs upgrade initially insecure connection tvs change set string support specify protocol
merge pull request change act act
merge remote track branch
create store copy directory even write page cache
core edge fix deadlock share discovery service listener previously raftdiscoveryserviceconnector would access discovery service invoke topology change callback within synchronize block time access service discovery service might busy try invoke callback trigger lead deadlock fix discovery client never explicitly ask topology rather notify change keep value also fix non synchronize iteration listeners shareddiscoverycoreclient
change execute reentry use null pattern avoid null check kernel statement
rename
extract channel pool catch client also fix leak pool could store one channel per address
make list users query unless admins
move security log set
cache friendly traversal iterators change two things eager relationship cursor initialization previously cursorrelationshipiterator always one step ahead construct first item read first item second item read traversal scenario would mean many eagerly read relationships would read vain paths would never even explore eager expansion traversal branch previously traversal branch would expand initialize simply discover decision actually traverse would make branchorderingpolicy immediately expand discover path would beneficial branch would select immediate next branch otherwise would potentially unnecessary read one node also first relationship give previously eager relationship cursor explain remove benefit physically locate relationships depend branch order would remove benefit scenarios change result less node relationship record read opportunity read relationship chain consecutively without interleave record traversal effect optimizations depend data set traversal worst case slightly better best case much better example breadth first outgo traversal outgo relationships physically locate import performance increase
give load command ability overwrite exist database
base framework specify realms auth token
move functionality query session transaction context add connection detail execute query longer need keep query session around instead query log main user query session get data transaction context include execute query
reorganize procedure interaction level base test class
move log user manager procedures
add annotation parser function
refactor user role name validation clean login log test support new log format
move plan cache concurrentlinkedhashmap caffeine add caffeine dependency dependent modules remove concurrentlinkedhashmap everywhere due cypher compatibility mode
optimise memory manager huge allocations memory manager would previously throw away entire current slab ask perform allocation service allocation greater grab size memory manager perform allocation dedicate slab huge allocation without throw away current slab way memory current slab waste
merge
change transaction connection management procedures build
add procedure terminate query
add security log core edge modules
fix fail test
allow optional lenient read break transaction log entries disable default enable dump logically time useful come across transaction log break entries bad section file fail read entry revert back start previous read one byte forward try continue next successful read log entry happen get successful read bad section perform additional check data read log entry make sense check make transaction time stamp similar data field
tweak query plan rename confuse variable name make sure compare stats add test tweak default plan less often
reload auth roles file change
add test build procedure support core edge edition modules
simplify recovery code read transactions essentially use already exist mean read transactions multiple file seamless bridge instead invent new different ways read log file per log file change couple benefit less code recovery algorithm see one place recovery class ability read transactions even would somehow cross log file boundaries issue log rotation may happen middle write transaction recovery would report weird log entries read transactions log file one one isolation fail start database issue corrupt log file start database fix recovery able read log file correctly
add debug log cleanup test code
fix break test
fix bolt test base require new method
add file rename method page cache interface need since page cache aware custom subsystem configurations might rename file operation use fair number place
fix lookup group settings apply scoping rule non group settings look fig
add command neon admin tool add support sub command refactor share test code command
test driver interaction
core edge automatic bootstrapping previously special tool require bootstrap cluster seed longer require long term intention able put store seed backup stand alone import initial member cluster work
use invalidargumentsexception builtin procedures invalidargumentsexception generic exception longer tie security write utility code tunnel check exceptions stream pipelines
implement sett metadata proc metadata write query log metadata include list query
log helpful message user log unable bind port currently errors bind address result stack trace internal log still also reasonable message say port set one bind issue help debug error set
simplifications recovery code comment typos fix
implement truncation last log recovery sit previous change recovery code
implement truncation last log recovery sit previous change recovery code
implement truncation last log recovery sit previous change recovery code
disable write completely non leader
convert haber nit unit test
merge branch
add core edge stress test backup store copy interaction
add procedure clear auth cache clear authentication cache realms applicable clear authorization cache realms applicable
add assertions extract reusable code
expose procedure guard check termination guard within long run procedures
remove auth token support check bolt since one auth manager attempt login get error login method auth manager instead
add lap test example plugin plugin demonstrate different method resolve lap group neon role map
add connection detail list query
faster batch hottest fix bug batch insert speedup come use global batch insert test insert live whole test class bug change node label dynamic label record delete would write store queue write next flush write would add ids store free list later allocation would mess record overwrite exist record
add aggressive log rotation settings trigger store copy
add cache able authentication info support hash give credentials random salt add secure asher class remove credentials base authentication info class add subclass cacheableauthenticationinfo add custom credentials matcher
hide deprecate transaction connection management procedures hide procedures
add feedback include lazy remote host lookup
faster metadata shortest use race overfill atomic test new code race could reproduce something like accuracy yet run time
add exceptionmonitorinhandler netty pipelines
faster nest resit also fix actually test write test previously race suppose test couple things wrong test run reader writer parallel rather sequentially set thread run lot iteration wait complete maximum sec would make test run control thread release executor leave run shut race decent number iterations use thread run parallel
collapse two discovery procedures one
refine cache able authentication info type add customcacheableauthenticationinfo add documentation add test
use byte unit possible
fix fail test
add synchronization might also contention tread perform write flush come separate thread may lead whenever flush set buffer write thread try write buffer
hopefully fix flaky test
refactor adaptable store view move new methods store scan update test
add cap exponential back log send machine perhaps die log get flood helpful message change back log message double amount time log message give host drop start second cap
ensure metadata shortest race test run least operations even really slow machine also correct confuse test access methods
update license file
add function test harness way test function test harness add method let load class contain function
add lap integration test
refactor allow output handle better way
change format return data run call pull success field tel servers record role write address role read address role route address
update complete phase handle add test adapt test new disable default toggle switch
declare database empty file
update node detach delete code properly acquire node lock case node relationships update test case cover case
refactored test
expose connector address
first draft stream recursive file list page cache
fix review comment add integration test update state use lookup clarify lookup test add test expect exception
fix bug remove user assign role set password delete user also remove role assign fix require password change ignore community true default case procedure
update label scan store index population allow update perform index reader update time observe update come non visit yet range node ids remove introduce complete method store interface
specify options get document
rename docs test product server modules server docs test fork would like move dedicate manual module modules server docs test become rely upon functional test product fork docs generation bits remove later rename ensure test run appropriate point build new status normal test
ignore test nonuniqueindexaccessorcompatibility
add test procedures allow annotation
remove unused static documentation source
refactored use service change password use auth subject
make recursively remove empty parent directories
extract server docs module
also use expect exception rule page pretest
move server docs class specific package avoid clash identically name often identical class product server modules since class fork
create security security module
correct location import tool use mechanisms figure neon otherwise
default csc mode
add test new file list apis pageswapperfactory
introduce lock acquisition timeout introduce property define timeout share exclusive lock acquisition lock clients case user configure timeout acquisitions take configure time interval terminate lockacquisitiontimeoutexception raise add support new property community forest lock managers unify clock usage database construction creation components use exactly instance clock provide platform module
unbind instance cluster current implementation merely check database exist lock active neon instance good delete cluster state directory revert store neon standalone format use seed another core edge cluster
feedback code review
move log settings security module move separate sub package enterprise security module
remove user management neon admin except set password
fix page pretest failure windows
merge branch
snapshot access mode transaction start snapshot access mode take begin transaction keep authorization state point active life time transaction fix issue authorization expire long run transactions lap authorization plugin authorization use simplify interface
test check request get rout around cluster
improve log test
add rewrite remove unnecessary optional match
introduce security context replace access mode
add summary method command provide short summaries
fix test plugin authorization expire move assertion test session kill interaction level use eventually disconnect bolt
move security context end new anonymous context class
descriptive elsa free call message simplifications
make sure handle optional match nod
properly close resources test leave thread hang around
bump java driver version
new test leader switch
contain auth subject security context auth subject longer inherit security context could admin interface check admin enterprise
remove index load benchmark main rep appropriate benchmark add benchmark suite
move server docs manual module need retain original docs test server module although use docs generation also rely upon test server fork allow diverge accord use implementation similar change impossible merge cleanly redo scratch
minor feedback fix
remove unused test code server module
fix print stout diagnostic output std err rest
rename docs test server module
better error message procedures provide wrong number arguments procedure print entire signature together description
remove debug til dump thread favor thread study gumballs backtrack
move enterprise server docs manual module
introduce leafplanfromexpression use
support degrees importer without additional memory overhead via indirection integer count field also contain flag though count surpass array bigger slot indirection extremely rare kick nod number relationships single import
fix life cycle bug stop neat source check point step fail neat source stop never call life shutdown hence never map store file page cache later try close page cache fail due still map file change make sure always shutdown life cycle instance internal life neat source
move tool manual project
remove remain docs relate stuff server test
make auth plugins log security log
add log level security log
return servers shuffle order get servers proc
minor cleanups
fix filter leader read end point reserve procedure also remove control flow exception replace use optional
simplify improve readability getserversproceduretest
merge branch
merge pull request better timeout core startup
merge pull request close transaction separate thread
merge pull request private type handle list map
resolve dependencies neojtransactioncontext factory early
fix windows would throw power shell exception windows actually need conditional check cause problems completely remove
make settings final
print security context description uhf call deny exhaust result iterator add explicit test procedure permission deny message
use blocker locator instead list blockers
refactor dependency injection neojtransactionalcontext factory separate dependencies class
make ephemeralfilesystemabstraction auto loveable make ephemeral implement auto loveable move resource cleanup close instead rely finalization make usage pattern explicit avoid case yet open resources get clean file system get garbage collect
list allow roles per procedure enterprise procedure contain additional column list roles allow execute enterprise column populate execute user administrator otherwise empty
add common arguments parse logic neon admin add logic parse common arguments primarily deal format usage description string consistent way across command
replace subtract subtract double subtract long subtract type longer need one method per type
remove map listener hazelcastcoretopologyservice remove callback update read replica topology map call whenever hazel cast notice change judge unnecessary already update fix interval rely hazel cast internal class
reintroduce membership waiter change code base
make filesystemabstraction auto loveable add file system database life shut life shutdown adapt exist community module test
merge pull request location consistency check report specify
fix fail test
address review comment
fail miss configure auth plugin plugin enable respective auth plugin find service load server fail start appropriate error message
update default file system usage casual cluster tool backup modules
close default file system test
merge pull request back port fix
merge branch
file systems close test
make test databases impermanent embed alike use min page cache memory default databases create testgraphdatabasefactory use min page cache memory default unless explicitly configure otherwise set previously apply impermanent databases apply embed databases well
clean compatibility
make page swapper use long instead page object read write data page memory section file
remove usages graphdatabaseservice compiler module
update tick dependency preparation update new tick milestone usual number new scenarios update handle one scenario blacklist configurations yet implement comparability
merge pull request neon backup install wrapper debian
remove rule planner first step
merge branch
make error message test safe run windows loss
introduce gumtree initial step native index first step build generation aware tree tree implementation directly atop page cache cache additionally internal leaf nod level link leave right sibling pointers provide correct read concurrently modify tree initial prototyping show great performance improvement label scan store write compare lucent tree could potentially use lot different type index path index example detail implementation non block tree modify single writer multiple concurrent readers allow read write non block garbage implementation aim make read write garbage free build order index module build directly kernel module see community package pom generation every node child sibling pointer generation indicate first evolve create recovery pointers nod flush disk lose memory determine pointer node trust stable disk global stable generation tree generation every generation check point flush disk therefore trust even crash generation currently evolution consider unstable data belong point unstable generation trust crash must overwrite recovery note implement yet checkpoint stable generation set unstable generation unstable generation incremented unsafe pointer gap guard pointer field generation address checksum determine pointer break wrong checksum pointer break page flush write pointer crash page flush pointer generation checksum call unsafe pointer gap gensafepointerpair sep always want keep stable version every pointer therefore pointers fact two gap sep read write child pointer example look pair pointers whole determine one read write look gensafepointerpair class label store implementation label scan store build top introduce separate note minimal feature set among things miss pipeline implement recovery implement free list rebalanced merge remove tree
initial version nativelabelscanstore build use tree storage storage structure wise similar current lucent label scan store nod group small bite set unit storage initial benchmarks show big write performance improvements within order magnitude even heavily concurrent write load read performance equal better lucent label scan store disk space wise occupy bite lucent less within memory wise much less cache index page cache cost open native less small constant compare lucent less rather lucent general cost open index function size index example could take minute open lucent less store billions label nod sub second native less additionally background process file merge native less currently less implementation disable default implementation get complete time default less neon build
clean return clause rewrite normalizereturnclauses add field columns internal use remove later rewrite make difficult write test since parse query would never produce value internal return clause field change restore rewrite test easy write
add step stop distance stress test
delete read replica store catch stress test
fix recovery issue code find latest check point case log file versions greater zero checkpoints mistakenly report recovery need
add additional request test
refactor facade factory platform use fig map
add test log pass fig
improve test verify connection close unrecoverable security failures
copy stable node write write key content node new version node create generation equal unstable generation node already generation unstable generation case change directly node update sibling new gen child pointers new version create generation pointers already handle sep split result structure propagation pass single underwriter instead return method call update information new generation nod create various java doc cleanup
enable run check style without break build
checkpoint algorithm implement gumtree algorithm flush page file block writer flush page file write since last flush increment generation flush page file generation change unblock writer introduce short window time write block
change allow recovery work properly together high low level recovery test gumtree surface expose prepare recovery interaction point recovery documentation method relate checkpoint close recovery generation also add
add connector valid tors new connector utility methods
see cursor get clearer responsibility also know traverse internal nod get leaf node start scan also merge one variable able update atomically readers see consistent coherent state two
pointer generation test see cursor add test check see cursor behave correctly read new gen sibling child pointers even checkpoint happen concurrently cause see cursors stable gen unstable gen date change unify pointer check one method merge test precursor pageawarebytearraycursor refactor seekers test
fix compilation issue update fig use enterprise
restore public apr class add deprecation
introduce free list page reuse add free list like link list page even free stag add free list become empty free list manage realist provider new index state field freelistwritepageid freelistreadpageid realist writers realist readers
use kernel extensions figure less
clear leader step
rename reflect upstream database rather core member
add java docs removal unnecessary code
add compiler aggregation function add necessary part compile user define aggregation function java class
new way handle transaction state transition around wait already commit transaction finish shutdown
support unwind compile run time
make lock result message independent lock status
gbptreerecoverytest use ephemeral rule test directory rule
remove unused constructor conf loader
fix bug advance page cursor unmapped file leave currently pin page lock
remove comment
monitor store file deletions external applications use file system monitor possibilities provide notification case store file deletion third party
log make easier see happen membership land
add test shouldreadcorrectlywhenconcurrentlyremovingoutoforder
fix bad error message
remove element list change list
outline trace lock wait time execute query status
implement wait trace behaviour lock managers
internal logic split internal without use top byte
procedure list fig
initial support block device store migration support migrate nod relationships achieve make store migrator partly use page cache migration also add support batch store use external page cache
work eviction via page list
add new non deprecate factory method database creator default implementation external implementers suffer implement everywhere internally however
full stack refactor index descriptor usage
fix check style
abstract labelscanstoretest implement lucent separate lucent specific part lucenelabelscanstoretest create abstract labelscanstoretest use label store implementations
add assertions start insert remove verify cursor leave previously also minor fix around internal logic
make bookmark await timeout configurable previously set second without possibility change value commit make configurable via set locate community bookmark expose single instance causal cluster single instance bookmark basically
add swapper set manage page swappers page list
introduce backwards seek see cursor together concurrency test insert improve java doc see cursor field code pretty messy everything document miss lot isolate test
merge branch
remove unused methods interfaces remove unused nodecursorgetall
update license headers
complete first draft implementation
remove unused iterator cursor testate
fix seed new member idle cluster backup problem use backup idle cluster require pull last transaction contain use try pull next transaction exist yet since write instead pull start one additional transaction back store bootstrapped causal cluster always null transaction add really configure system prune aggressive prune everything could situation exist transaction available pull even happen would harmful member would fail join case system fix configuration conclusion strategy always work
test backwards seek remove street test seek range start outside range actual data fix error seeker would try previous sibling seek range start outside data range thus previous sibling
keep connection detail individual field
time file mill
split page cache tracer page cache tracer page cursor tracer cleanup interfaces test best case comparable
rename query source clientsessioninfo
gumtree test recovery replay transactions last checkpoint make sure nothing break transactions necessary replay
include planner run time
street extract reader runnable reader redaction
better support block device store migration achieve also use page cache relevant part migration process order reach file reachable page cache
use thread pool readers checkpoint street
merge pull request fix bug apr internal conversion cache able auth token
flatten node cursors
provide information index query use work cypher version support older versions would require change versions new release
list lock hold transaction add procedure call dam listactivelocks query list lock hold transaction execute query give
crash recovery test test scenarios transaction log leave garbage partial stuff end
merge branch
remove superfluous package
adapt rebuild page cache test use record tracers infrastructure make current test pass new combination page cache page cursor tracers
disable neon desktop make target
apr change around label relationship type
remove index
rename
fix invert return value visitor compute count
gumtree rebalanced support insert multiple empty slot tree node
first draft block device support causal cluster store copy store file read write page cache file operations copy move delete page cache store file test change rely file system copy store directories around also allow test configure block device storage block device repository test change primarily involve coretocorecopysnapshotit readreplicareplicationit send alignment requirement message protocol change preliminary approach invitation discuss design best way solve problem check mutually exclude causal cluster custom block device remove things still leave make sure temporarystoredirectory clean via file system also via page cache closer look local database catch code make sure latent bug possibly extract duplication discover
make label return primitive inset instead cursor
reintroduce cypher test comparisons rule planner rule planner still exist cypher run cypher test assertions result latest old rule planner
build label scan store part import necessarily import mean may different page size even different less configure import performance node import impact build less concurrently since random share node store less label scan store build first startup correct fig use correct less build
remove unused argument
preserve type empty primitive array empty array store string array surprise users would send empty long array parameter retrieve value find fact string array address
add permission token creation add check know token need create currently hard cod permission publisher need configurable
start servers add
gumtree perform checkpoint close since otherwise tree likely inconsistent next time open change make since last checkpoint since open tree new checkpoint make previously automatic checkpoint make close try align database checkpoint tree checkpoint although tree fine potentially apply change already see check point close safe much convenient especially use gumtree outside full neon database stack
merge pull request revert kernel transaction state handle update
gumtree rebalanced support small cleanup internal logic
fix store file check stream disk also clean various causal cluster test code also make sure cluster cluster rule make sure cluster wide instance configurations properly pass late come cluster member additions
remove kernel dependency indexer monitor
prepare support order compile run time introduce instructions build sortable sort instruction resort result add optional suffix trace events
properly use correct less whole main test also faster fullcheckintegrationtest due start stop full every give transaction apply
restore revert new transaction handle
new schema model application schema store
test store file bug fix ephemeralfilesystemabstraction
add information environment variables neon admin help new output compare old output
street refactor introduce gumtree concurrency
remove big part limitations username
fix new test rebate
refactor spa interface sort relate methods add concept tuple descriptor wrap previously call value structure use generate specialize class orderabletupledescriptor tuple descriptor also contain sequence sort items
simplify creation index descriptor
simpler method call record check
add token mode procedures
introduce page cursor counter interface split cursor counter tracers isolate code access counter actually cursor events trace
merge pull request make test runnable windows machine even build loss
include stack trace unexpected checker dispatch error previously exception message log consistency report addition exception swallow create second failures hard find root cause
wait index come online test
trace count eviction exception happen page eviction operate page specific page cursor
prepare context able contain value type know
support list primitive float boolean compile run time generate code use double stream list float stream list boolean conversion code primitive boolean need false true
start stop store watcher replace database store store often replace cluster environment store get copy another machine original database store get replace gon stop watcher get useless notifications store file delete
add type specific comparators compiledorderabilityutils add comparators follow type string character boolean list array add license header compiledorderabilityutils
probably make read replica catch read replica
fix bug list comparator compiledorderabilityutils
move query horizon module also move implement class
refactored count store use index independent index definition
create composite index core apr
merge remote track branch
add test demonstrate revert random core prefer read replicas available
add simple test connecttorandomcoreserver strategy
add configuration grant full access procedures
make relationship type return primitive inset instead cursor
merge remote track branch
fix handle null value type parameters node relationship parameters unbowed primitives need handle nulls properly assign dedicate null value
merge pull request kernel apr change label relationship type
allow procedures create transaction new thread
gumtree rebalanced test unit test seekers test
fix bug relate node seek unnecessarily try convert primitive long primitive long
merge pull request cleanup around get servers make room
push index descriptor boundary read operations scheme operations
move set refactored
move degrees relationship type apr node item move logic entire operations storage layer
move relationships cursor apr node item move logic entire operations storage layer
small fix cleanups
cleanup test bolt factory commit remove empty life rename also add test assert reference refresh factory restart
import tool progress print delta well
merge pull request fix count issue rel group fragment
merge pull request change graphite connection host name instead resolve
fix issue lonely check point log file recovery latestcheckpointfindertest test claim test issue slip crack whole test class simplify use mock heavily reduce issue give older log file transaction newer log file check point target entry older log file latestcheckpointfinder would report transactions last check point fact would result transactions recover startup commit also add detail log find last checkpoint startup better able reason recovery issue read
fix index descriptor support composite index cypher
better error message able fulfill hint
new index population node change manifest node update object contain full set properties label node change node update find change relevant particular index use index return indecent update indecent update contain information interest one particular index solution solution likely cause performance degradation look properties cause hit try alleviate later look properties know interest index
adapt lucent new index population basic composite index support
add security headers return static assets
merge pull request handle case responses timeout loop
refactored index seek plan preparation composite index
compute sleep time restructure code capture snapshot state execute query purpose ensure different time field single query compute base point time avoid case sum put wait time could greater elapse time due fact capture different point time
remove index configuration cover rewind descriptor
fix compile errors rebate
simplify store player
add white list procedures
create uniqueness constraint longer hold schema lock populate index nov create uniqueness constraint transaction still block potentially fail constraint validate exist data concurrent update big difference schema write lock hold populate constraint index allow transactions modify properties label progress complete normally
fix bug scheme factory get acceptance test work
parse load balance filter configuration filter configure load balance strategy call server policy use strategy specific syntax syntax allow specify list rule consist chain filter commit parse syntax enable several different policies different rule set define parse test infrastructure add make test functionality easy various valid well invalid configurations test produce expect result three filter exist today return servers min return valid result minimum count meet tag return servers match tag
change index key represent property position index
move property cursor apis node cursors operations facade
fix removal kernel extensions graph factory state
support seek composite index
support plan composite index arbitrary number properties
small page cursor tracer cleanups
merge pull request graphdatabasefactory share thread
extract providers separate file
add entry point
fix test pass side effect planner order cost
switch heap page list page contest pass pagecacheslowit yet
push constraint boundary around testate
walk skeleton index query method accept array index query predicate one index property order apr able describe index operations operations facade though seek scan support point long term idea replace methods apr keep query context maintain compatibility cypher planner versions
distinguish load balance plugin processor new narrower interface extract plugin accommodate server shuffle interface cleanly
add support numeric range query
string range support
support compositequeryexpression test composite index plan
fix code style
add support string prefix suffix contain
make unused remove
add initial support composite index memory index population seek support
remove unused compositing query
make unused remove
flat single node cursors one cursor handle testate read record disk
make unused remove
refactored constraint exceptions use new descriptors
make unused remove
make unused remove
make unused remove
throw illegals exception call get fetch item
flat single relationship cursors one cursor handle testate read record disk
constraint descriptor subclasses increase type safety push final boundary constrain semantics fix trail
handle rotation failure better way previously would silent failure really open new file log rotation fall back std err user least chance detect problem always valid output stream log also fix test assumptions longer hold output stream wrap never change view user
flat relationships node relationships cursors one cursor handle testate read record disk
log log file open rotation
fix bug introduce rebate
fix problems around query plan miss tokens plan query use label relationship type unknown database need little extra work load tokens run time correctly query would behave weird ways situations
introduce file temple parent defaultfilesystemrule ephemeralfilesystemrule file temple also implement filesystemabstraction delegate longer need rule get everywhere convenience
merge pull request server policies load balance
fix compiler errors merge
sketch index population load relevant properties new node update object initially get label node information property value add remove change index method analyse index descriptors find properties need load determine index need update use property loader load properties return sequence indecent update online index update glue give node update real property loader still miss
update throw exception type
additional consistency checker test composite index
make sure cache query use debug flag
extend procedure san box involve user define function
remove unused class
add test
simplify store property cursors push storepropertypayloadcursor filter correct property eye specify delete useless storesinglepropertycursor improve test coverage cleanup storepropertypayloadcursor
add user function white list
postpone log log rotation progress release login block fix deadlock problem flush log rotate log problem order flush rotate grab lock flush first grab print writer lock log file guard lock rotate first grab log file guard lock print writer lock solution log rotation progress hold log file guard lock instead buffer log message lock release
flat property cursors one cursor handle testate read record disk
fix mistake stumpage cursor port byte buffer
page cache test update helpful debug
fix fail test
fix read cursor retry bug link cursors check lock validity use stamp top page cursor instead stamp give cursor obviously often result check fail way get retry look retry check currently use lock stamp give cursor chain also make sure refresh lock state cursors chain restart necessary
add data center local upstream strategy sensible box plugin allow read replicas catch name others within locality log load strategies order precedence catch self
fix test failure create composite index
fix serialisation schema record spill multiple dynamic record
add checker tune command line arguments
expose new parameters backup command
track print catch progress startup
log member attribute change expect prudent log
support name rule schema store add optional name field end schema rule schema store schema rule object get generate name none otherwise provide generate name freeze observe change afterwards schema rule name thus effectively immutable legacy schema rule record fit new name anywhere thus always get generate name new schema rule record name get generate one well empty string valid name somehow find empty string store use generate name instead allow add field future without impose hard requirement future schema rule record must name name store null terminate string different string schema store reason null terminate string slightly straight forward handle name field miss compatibility test add new case also obviously set explicit schema rule name require empty string contain null byte character name field string encode uhf terminate null byte null byte string
ability set unlimited bad tolerance import tool use bad tolerance
update query merit query log file check
add code gen support depth array inner class
add flag verify generate byte code flag enable default test inspect assertion status generate restructure class assertions enable byte code verification enable otherwise enable run test assertions enable
new helper class match schema descriptors nod
update component injection validation rule context field type categorize three ways support legal procedure function log termination guard graphdatabaseservice security context procedure transaction restrict use procedure function declare set type graphdatabaseapi kernel transaction dependency resolver use manager enterprise manager security log unsupported illegal type basically processor know whether procedure function unrestricted time compilation default emit warn type encounter exist processor option use mute type unsupported compilation error raise
test query log
remove unnecessary code
add way remove password query
update scheduler configuration
remove old also
merge pull request remove job demand job scheduler default
fix equal assume consider type
consistency check composite index
merge pull request schema store fix
add test switch label index provider backup
simplify code single execution
add randomize crash cleaner test
add test crash cleaner
change use labelschemadescriptor
support composite uniqueness verification
support composite uniqueness verification
cluster formation decision depend initial host content change make instance list initial host consider purpose form cluster allow mismatch initial host content manipulate make harder instance start cluster example slave instance depend presence master master allow form cluster regardless presence instance functionality achieve introduction backwards compatible discovery header configuration request message keep track instance contact initial discovery round since send message depend initial host content effectively allow filter configuration request base initial host content
improve future friendliness cryptic method
cleanup stupidity longer wait timeout test time update format
acquire single cursor storage layer
fix compilation errors rebate
fix safe zone reuse properties make sure termination transactions check lazy property evaluation push statement open assertion cursor level
standardise shell script
improve way remove password query log
acquire singlerelationshicursor storage layer
acquire index reader storage layer
introduce switch initial host check default strict enforcement initial host slight departure way things happen far cause unexpected behaviour certain scenarios unintentional mismatch initial host settings change introduce feature toggle default allow know behaviour continue
log change read replica topology whole thing
support node key cypher parser initial work node key constraint testate schema store remove support node key testate support node key add remove syntactic sugar unique existence fix kernel test node key support first round support node key full stack constraint
add test make regex clearer
measure heap allocate bytes active query
add nodegetallcursor node store scan
fix bug native label scan store miss entry search allnodelabelranges native label scan store would miss entry label node entry calculate highest label correctly
add possibility register monitor native label scan store underlie gumtree monitor
use directly page cursor node cursor
use page cursors read properties dynamic store
use page cursor property cursors
merge perform write check procedure processor
format
merge branch
make exit cod constants
speed bound check non offset ted page access possible ignore underflow case use imply offset
bound check uphold assumptions westbound pointer method expect offset field least never underflow
fix check style switch statement
improve java doc procedure function
overwrite property value longer generate write command seem obvious set node relationship property value already require change node relationship even case previously command would generate property record would update apply index change would apply nothing
remove map lookup make indecent update generic index
fix import
remove unused next record mode apr record cursor
fix compile errors rebate
update page cache code comment
revert add procedures
page list page lock initialise exclusive lock hold useful page free page cache exclusive lock take speed initial allocation page cache
delete long apr
use page cursors directly remove record cursors
explicitly set auto index properties value establish ways rebuild legacy auto index later versions commit revert favor tool rebuild auto index instead
ability call gumtree close multiple time gracefully
cluster ability recover half apply constraint create constraint involve two transactions one create back constraint index index population start commit apply one create activate constraint successful index population problem distribute environments could happen constraint would begin create cluster instance first transaction create constraint index another cluster instance would pull apply transaction would crash would complete constraint creation commit second transaction activate constraint would start recovery would treat half bake constraint unsuccessful constraint creation mark fail single mode differ constraint index would even delete would continue pull transactions eventually get transaction activate constraint would able apply back index mark fail recovery fix propose try helpful delete orphan constraint index startup even happen single mode instance may switch back forth cluster single make hard look consistent user part fix remove optimization wait immediately mark constraint index fail recovery delete additionally instead clean orphan constraint index index reuse another constraint retry transaction crash would work would change ability reuse orphan constraint index multiple concurrent transactions want reuse fight one win others fail concurrently safe schema write lock create second transaction activate constraint
cleanup
fix use give mode load record instead hard cod check
add test functionality connecttospecificservergroupstrategy
add assert exception without message check
first step add enterprise version storage statement
test demonstrate node key behave uniqueness specifically cypher planner support
introduce indexingupdateservice interface
assert list query deprecate field
improve test error handle constraint index creation orphan index
add parallel scan node progression parallel scan cursors available enterprise
remove unused apis testate
merge
merge index list methods hot paths need index regardless whether general unique therefor better one method return type filter slow paths concatenate hot paths currently
merge
use custom code count dense node degrees use visitors cause regressions
use interface assert open instead runnable assert transaction open make assert open explicit avoid indirection runnable
allow skip bad entries log import introduce new import tool option allow skip log bad entries
fix bug primitivesortedarrayset union miss los tail
ability configure import input data buffer size use read buffer size
make sure progression never return non empty batch return empty one could happen high increase meantime need enforce consistency never restart stream new batch declare progression
make name lowercase
node progression handle transaction state
comment address
shuffle recovery test load order better model fact order transactions different recovery compare first apply long dependencies lock
remove blacklist pass test
add test parallelallnodeprogression fix bug expose test
split query logger source file
introduce empty readable transaction state simplify code avoid many null check
merge remote track branch
replication benchmark procedure
update version snapshot
overwrite dirty state writer use correct lock gumtree leave state dirty close clean keep track lock use unlock correct one test lock recovery cleanup
revert merge pull request revert commit reverse change make
move kernelstatisticprovider transactional context allow neojtransactionalcontext provide correct statistic simple transactional case transaction restart upload csc
consistency check duplicate node key
add methods read operations create parallel scan first step expose parallel scan stack eventually cypher run time
number array back page cache
fix page cache test warn remove use streamline recursive iterator pattern
integration test recovery cleanup block checkpoint
file map delete close longer flush dirty page close
correct query type procedures query use procedures present correct assume always correct decide correspond annotation
update cypher compatibility compiler
una curse
merge pull request update cypher compatibility compiler
move store file package store type
fix different compatibility behaviour node key legacy cypher compilers
add factory method socket address
add global cursor cache previously one cursor per type cache transaction mean often new cursors create discard change make sure cache one cursor per kind local global pool similar kernel transactions minimize creation discard cursors
update dependency plugin
new page lock transition write flush possible atomically undo write lock attempt grab flush lock page page list useful add flag instruct write page cursors flush page turn useful certain stag phase parallel batch importer group reader thread read page ahead group writer thread modify page currently read field page fault thus also end flush read end read write
page contest cleanup
refactor core state relate name roles responsibilities interactions class less optimal time simply grow organically point refactored commit try clear things bite things clearer top level class previously call core state say split two top level class deal part top level entry point functionality class previously functionality raftmessagehandler coresnapshotservice respectively responsibilities somewhat clear name access core state leave core state class expose things like flush command application process messy setup synchronization externally internally simplify external users expose two call pause resume instead previously single sync call rely operation perform critical section monitor least concurrent conflict operations block less ideal design pause resume system reference count last outstanding call resume applier actually resume snapshot service use pause resume functionality state store download lot code move around lot code meat change easier reason correctness interactions design refactoring take occurrence rare deadlock applier thread wrap class commandapplicationprocess two class still exist applier state synchronization wrap internal class call applier state allow extra flexibility need avoid deadlock
add test retry parent close link cursors
fix bug retry close link cursor discover via retry cursor need retry retry cascade link cursors cursor previously link cursor link cursor close parent cursor notify still traverse close link cursor start retry would cause start retry throw null interception close cursor drop reference muninnpagedfile bug fix check pin page ref still valid standard way tell whether cursor close issue discover gumtree concurrency deterministically fail page contest add different want instead
add white around check style rule add new white around check style rule fix current violations
load csc headers empty file call empty file fail handle gracefully
fix art update check style rule
cleanup cycle configuration page swappers build page cache factory page cache actually create move configure page swapper remove configurablepageswapperfactory
merge remote track branch
match code style
merge
small cleanup
better checkpoint test
leak node relationship cursors core apr make sure inner cursor close user call close public resource iterator
gumtree internally handle clean crash pointers check last close clean change since last checkpoint gumtree know clean necessary tree dirty clean perform part construction add clean part tree state mean bump format hence new current gumtree longer need tell outside prepare finish recovery remove read mode gumtree let handle fully outside even nativelabelscanstore start read still need able create complete new instance underlie tree populate scan node store
cleanup weird implementation assert open
better transaction state handle property cursors also nullify state close property cursors
bite simpler inject custom components testgraphdatabasefactory
fix race start transaction shutdown design work already slight gap arm database availability among last components register database life cycle therefore one first stop stop database availability raise availability guard await active transactions finish configurable timeout start transactions also check availability guard state register active problem active state register availability guard check little window call race window database availability potentially allow transaction start without aware database shut shutdown process unaware active transaction run concurrently could result unspecified exceptions throw due transaction run inside components shut even shut commit tighten gap let transaction start register active check availability guard way transactions start concurrently shutdown deterministically succeed fail depend whether make availability guard raise shutdown still leave max timeout database availability wait ahead shut anyway default timeout reasonable setups configurable
convenient test utilities around page schedule neostoredatasourcerule
merge pull request move test feature file
minor fix style
avoid duplicate work transaction state index update
merge pull request avoid ape system diagnostics null class loader urls
list query display star time etc
fix connection refuse message throw proper error connection refuse also fix flaky test highlight problem change test name properly reflect test
rewrite data input get write record instead stag queue pass object import fully execute import thread parallel data structure access pattern make allow concurrent access garbage big concern previously new import create object entities instead allow visitors observe different field directly underlie buffer read input source
remove explicit calculatedensenodestage importer instead import relationships relationship input link one pass link relationships forward link backwards case faster previous approach
fix review comment
allow concurrent index drop force currently index drop operation perform concurrently checkpoint fail index force operation change behaviour add additional check force index state allow operations succeed case index force reason drop still fail index force
merge pull request make sessions edit less flaky
close test allocate resources file clean windows without warn
merge pull request refactor node cursor
fix bug reuse link page cursors previously link cursor close return cursor pool could reuse another call still consider link parent cursor thus parent cursor close would also close previously link reuse cursor bug fix never return link cursors pool stick around forever link parent reuse necessary parent cursor
update store lock checker optimistic assumption log file test
remove temporary benchmark test
merge pull request use page cursors directly property cursors
add test case halfappliedconstraintrecoveryit
merge pull request refactor degree apis
allow concurrent index drop index force operation currently index drop operation perform concurrently checkpoint fail index force operation change behaviour add additional check force index state allow operations succeed case index force reason drop still fail index force increase default failure tolerance introduce specific feature toggle since small non critical error index cause database health update require end restart
gumtree support exact match lookup
remove private constructors public leak class accord click
remove test call remove call marshland contest remove use
enable multiplevariabledeclarations check style rule disallow multiple variable definition one statement fix current violations
merge pull request refuse leader control multi license
merge pull request parallel node scan
rename progression batch progression
merge pull request expose parallel node scan read operations
fix neon user require password change test
add test
add test
test
merge pull request pare pad check style rule
check style
move asa
count store support cartesian products query need full cartesian product use count store directly instead
support log camacho unnamed
allow white space around transaction statements give transaction statements flexibility art white space regular cypher statements
update poms file
merge pull request try figure service urls
merge pull request fix bug reuse link page cursors
merge pull request fix safe zone reuse properties
small performance improvements noderelationshipcursor
add test page file close flush clear eviction exception test probabilistic often fail code sabotage however best presently
merge remote track branch
check style
share state gumtree cleanup job cleanup job take care state gumtree ask need
close block need clean fine close gumtree even still need clean clean job fail page file close fine start next time tree start
define kernel apr part around edge still outline central cursors pretty well shape
recoverycleanupworkcollector life cycle recoverycleanupworkcollector extend life cycle important detail register collector life index register init clear eventual state case restart register cleanup job would lose responsibility schedule cleanup job transfer outside trigger previously create part build recovery neostoredatasource collector
add hit ratio tracers
merge remote track branch
add delimiters array delimiters
outline kernel apr integration test
fix racy test countstrackertest
merge try block
assert kernel statement still open read properties
clearer error message incorrect usage use index hint
initial value system
close statement acquire getrelationshiptypebyid call standardrelationshipactions close statement leak call
value comparison part work yet
make cut logical plan level result come compiler module logical plan instead executable plan
index popular native schema number index implement use gumtree time index popular implement online index accessory scheme provider come later unique non unique layouts support type number small differences unique non unique layouts entity key non unique value unique make key smaller unique layout something make overall index size smaller due internal tree nod contain value layout contain comparison value coerce value type number convert comparison also original value mean need additional entity property lookup filter result higher stack
value group interfaces need separate capabilities logical value implementation value group class contain logical capabilities give lazy direct implementations without crash class hierarchies also move static hash compare methods text value number value class lazy direct equality still break array
fix value comparison
checkpoint correctly assert successful clean clean would fail checkpoint call checkpoint would continue without failure effectively validate crash pointers clean fail cleanup job assertion cleanup job succeed acquire cleaner lock ergo cleanup job finish
print environment variables usage part help
check style empty iterator update revert
revert merge pull request revert commit reverse change make
revert merge pull request revert commit reverse change make
revert merge pull request revert commit reverse change make
introduce value property write type
merge remote track branch
record use fix reference format record transaction log neon introduce fix reference variant high limit format fix reference faster read write much lower limit ids use never less since reference know fix length omit meta data reference width variable reference format thus sometimes possible fix reference format store record single record unit variable reference width format would use two record units turn store transaction log whether record would apply store use variable width fix width reference format absence information get interpret always use variable length reference format could cause problems recovery cluster store copy record fit record unit use fix reference format would require two record units use variable width format would end overwrite part adjacent record would bound page solve problem record log whether record use fix width variable width record format fortunately record headers transaction log plenty spare bits purpose previously unused bite take purpose always zero exist transaction log mirror bug exactly use fix reference format default thus argue take bite use format change reason introduce new log version fix bug log format
apply code style star import
introduce value property read type
make index query instead
hide native memory allocation scheme behind interface
monster commit sorry rip property class replace value equivalents completely optimize everywhere might give decent performance particular work cursors touch separate work
clean find intel
unify direct lazy class tree big change lazy direct implementation share super class remove need value group interfaces get rid lot boiler plate equal code
merge pull request fix skip cypher profile
replace anonymous inner class lambdas change also almost mechanical manual fix fix check style compilation issue
fix cypher compiler
make raft message log settings internal
extract file handle reusable max separate class update generator use adapt current test
extract test utilities native number index test
improve bol support test code previous attempt bol suffer two problems one operations legitimately throw exceptions ignore test expect retry accordingly remove occasional failures bolt properly enable happen work bolt settings across instance use different identifier group compare set instance set subsequent branch would fail bolt server active test cluster code properly expect explicit activation bolt override default
introduce idreusabilitycondition keep track ids reuse safe reuse leader free transaction create
reduce probability get false positive deadlocks forest note false positives inherent risk dreadlocks algorithm change still use dreadlocks initial deadlock test one find follow thorough search waiter lock holder dependency graph unfortunately search also probabilistic may find false positives however act upon deadlock result make least attempt grab lock two different deadlock test combine require consecutive positive deadlock result mean probability false positive make way considerably lower
use transaction counter wait transactions completion shutdown use transaction statistics counter wait transaction complete neostoredatasource try acquire transactional log file lock prevent deadlock shutdown
fail null property value key core apr
optional lookup filter number query index number query result need double check store compare actual value due way lucent schema index index number native schema index need would unnecessary filter use native schema index index reader new method hasfullnumberprecision decide whether number index query result must filter outside index
split global schema lock split global schema lock independent label relationship type lock use depend type index constraint etc completely remove schema resource type resources lock slave take label rel type lock master exactly like nod relationship lock commit perform split kernel code cypher code update part commit
memory allocators say much memory available
allow construction index descriptor non valid label property relationship type
first structure virtual value list value map value
reintroduce node value node relationship make unnecessarily hard implement writers
rename test use share system resources test match fail safe plugin expectations disable fork execution modules test rely specific port
rename property type value methods
prototype implementation kernel apr cursors implementation base direct access memory intend show ultimate goal apr prototype limit read neon community format
address comment
dump output
dump output
let bolt depend value module
make update new store part migrate step use part move file step
remove lazy value
delegate schema number index order value module way native index use order cypher add possibility compare number value without materialize number value object rather interpret raw bytes base type information introduce primitivenumbertype unify type byte map get number value rabbit convert byte representation back primitivenumbertype mostly useful debug
remove unnecessary assignment check leaders test discard unpredictable leader switch
merge branch
fix outdated java doc graphdatabaseservice update java doc use new signature newembeddeddatabase graphdatabasefactory take file instead string path
unbind alignment memory allocator make possible specify require memory alignment allocation time instead give constructor argument memory allocator
remove trait use
fix throw remove non existent property batch insert mimic behavior graphdatabaseservice seem behaviour change accident previous version throw exception instead ignore
avoid flush index change take place updater
merge pull request memory improvements around mapper
add several list implementations order facilitate cypher implementation add multiple list variants
add support inv socket address discovery
add inv support test cluster
test combinedschemaindexprovider
introduce loadable settings apr reflect fact reload run time refactor settings use builder instead cope method overload
merge remote track branch
refactor fig use builder instead
remove lucent label scan index delete class relate lucent implementation label scan store collapse label scan store test previously one implementation lucent one native remove lucent label index end settings fix compilation errors
remove label scan store selection strategies since one label scan store provider leave need select remove namedlabelscanstoreselectionstrategy der
introduce resolution resolver
rework preliminary syntax return graph modify return clause instead new return graph clause introduce new graph reference type allow specify zero columns tabular projection
initial spike insight index write read index almost work
log original failure channel close bolt drivers close socket connections ongoing transactions result transaction termination database errors report back client connection terminate previously bolt server log inability write close channel lose original failure message case commit make always log root cause also change use coal instead synchronize list allow concurrent iteration modification
improve bookmark wait bookmark wait previous base poll instead use wait notify primitives implement los support wait close transaction highestgapfreenumber also volatile visibility ensure necessary new bookmark wait potentially use test transactions tracker also improve remove clutter boilerplate make unit test rather mock messy gray box integration
use poll available bolt server
bolt message log
adapt test new label base lock instead schema lock always take
merge remote track branch
allow mun inn page cache configure memory allocator instead max page count
remove remnants specify page size test
open legacy index writable mode non single instance read environments open legacy index writable mode read environments except single instance need allow index writable since need update catch update
fix test
member address resolution perform earlier address resolution cluster members perform earlier topology service remove many class use future backup client retry mechanism introduce handle fact possible request address member table member address refresh
merge
nativeschemaindexprovider step get popular getonlineaccessor depopulation failure note new read header functionality gumtree able read store header without open tree write
refactor bolt module remove unused stuff make pack unpack symmetric type
heavily reduce contention generate ids main idea batch generators local transaction instance pool batch sit store typical creators record commit time hand ids grab batch ids store clean shutdown excess ids remain unused free back store close scenarios many concurrent transactions commit data operatively force log generator contention single biggest one change contention basically remove entirely default batch size reduce contention dramatically good value scenarios value however controllable database set
add create node empty result enterprise interpret
merge
update bolt integration test
update security test infrastructure
correct implementation fusionschemaindexprovider retinitis state
merge pull request importer allocate cache heap default
add eagerregisterpipe
make kill query verbose
add possibility track close kernel statements add possibility track close kernel statements open close transaction life cycle case statement track enable transaction unclosed statement gon able commit
merge pull request empty stream instead exception non exist directory
load scheme providers consistency checker use kernel extensions
reverse dependency backup commit dependant backup apply commit shuffle dependencies around sensible
remove duplicate import
fix rebate errors
handle result standalone procedure call
properly close bloom index resources
backup client work transaction protocol backup tool work transaction protocol core backup protocol disable permanently switch option change anything backup protocol still support
fix flaky test
fix bad name black list
insight index add support removal nod
insight index support multiple properties per node
make test wait index stable way
support property change insight index
attempt address flakiness election test test expect exactly two message type however raft machine scheduler inject outside wake spuriously send empty request especially test take change make test demand least one request send strictly one
bloom index order result lucent score
rename latestcheckpointfinder logan scanner start generic
extract bloom index separate module
move string value production one step
start work semi play
close stream return procedure call result exhaust
retry periodic commit test multiple time server transaction
remove test blacklist
proper index recovery commit change way recovery work main drive force index update replay normal transaction application crash otherwise unclean shutdown previously index recovery special work record nod change recover transaction follow complete index nod exist index besides downside require special recovery code also put index requirement able efficiently delete index entries certain node able efficiently lookup node work lucent case work native number index key property value index recovery work way act produce index update transaction many case require read data store would incorrect often impossible read store recover change index participate see normal index update recovery enabler first reverse recovery versions transactions since last checkpoint apply reverse order onto new store take store back time look checkpoint consistent state forward recovery perform index participate would normal transaction application interest note change additional change make recovery faster due previous index end rather slow lock service use apply recover transactions benefit less memory consume due lower recovery transaction queue size observe performance benefit queue large amount memory require hold large transactions could gigabytes memory efficient implementation reverse transaction cursor recovery straight forward faster memory efficient work nicely native schema index
merge pull request slot cartesian product
merge pull request add possibility track close kernel statements
turn native schema index default
efficient parameter handle compile run time big value refactoring compile run time lot unnecessary work parameters object value back object also introspect object change longer need work
revert reformatting
fix bug cause docs build failure
full text add cleanup
simplify updater full text add
full text add cleanup
make free keeper work stack aggressive mode free keeper use append end eat begin lead growth file behaviour stay regular mode mitigate regular mode compact gap close aggressive mode however keeper append end aggressively eat well truncate end batch get write read disk
corrupt log resilient recovery allow recovery process restore store corrupt transaction log transaction log corrupt various scenarios frequently happen disk space error occur introduce additional resilience log read recovery allow restore much transactions database read log first non readable transaction ignore non readable well unreadable transactions log truncate end recovery avoid case recovery remove transactions log downgrade happen mistake additional force option introduce gon allow remove log unknown version default
test full text analyser configuration
faster code implementations
strengthen error handle byte unit parse make use
full text add fuzzy query support
reduce surface full text add
additional test full text add
cleanup full text add rebate
move value tip kernel
better parameter handle bolt read data wire bolt full knowledge type thus create map value directly without cypher need translation
unlike nonuniqueindextest
add additional rendezvous point test query avoid errors shutdown
outline implement kernel apr use record
disable parameter extraction graph urls
remove usages replace logical land
various polish full text add
add log errors close full text index
new cypher module
update databases estate back map use plain chm instead map back guard fair reentrantreadwritelock update apr bite provide expect atomicity
extract log read tool reusable class much easier write quick transaction log stream analyser dump logically also use analyser internally also actually test pretty important functionality
full text index delete exist index file prior start database order avoid configuration change create persistent stale index entries
introduce transaction log pruner use recovery truncate log specify position recovery threats corrupt non readable transaction log file specify provide log position truncate provide length subsequent file remove remove modify log content store separate corruption log archive analysis additional safety option possibility fully restore original log faulty case
use availability guard wait database start populate full text index since populate transaction otherwise likely time
handle null return value user define function also add non fail test use null input different form
escape lucent special character full text index query
drop rebuild full text indices need
move test cypher comparison support
create front end module
create compiler module
full text add population separate document fix bug population one property would work due way eager reuse document
fix compilation rebate
pass test case record base cursors
document purpose method
automatically reduce cypher query implement str str cypher query substantial nod include commit
make easier read assertions lucenefulltextupdatertest
extract common grind full text analyser updater test
start add pretty print expressions
fix license notice file
report recovery progress allow recovery report ongoing progress users indication much work already much leave recovery restore database make available new transactions cherry pick commit
procedure access bloom index properties
avoid stack overflow ism case panic import since ism check circular reference exception current panic mechanic import tool cause stack overflow print exception stack trace current change panic handle wrap original source panic new exception avoid set panic exception suppress panic exception
update latest version jetty
cleanup
increase election timeout reuse perfect solution test probably need rewrite deep reacher stack assumptions assertion trust
make sure database fail start reason full text index add prevent shut
explicitly load bloom procedures cause crash startup start plugin jar procedures pick separately explicitly load well lead conflict also mean need load procedures manually integration test
allow modules compile java compilations possible far procedure compiler modules dependencies rely scala modules modules comparable introduce java profile disable cypher bind cobra dependency switch update mock test see mock issue detail
rebuild index last commit transaction change since index last shut happen index disable new data commit time
add options query bloom add
code drop beginnings parallel run time
migrate mock latest upgrade mock latest version among nice feature support java report unnecessary mock possibility mock final class full release note find
test different traversals simple test modes initialize relationship cursors
fix memory allocation test allocate memory
reclassify test
management bloom index key procedure
update full text add rebate
ignore full text index add test windows due file permissions work
sslpolicyfactory provide dependency modules sslpolicyfactory must provide modules regardless whether make direct use least bolter extension expect dependencies
add wasp check dependencies
update bloomfulltextindexbenchmarks also minor cleanup additional test new procedure set property key
merge remote track branch
procedure list index provider also list label property separate field
introduce default value bloom procedures fuzziness match
encapsulate full factory bloom add
new cache flight raft entries highly efficient cache keep consecutive range raft log entries cache allow simple efficient circular buffer use cache also allow put maximum bind amount entries well total combine size cache also expose metrics cache hit miss total data observe
raft message log line rewrite aid machine readability include date members type message rather class message arrange space separate field message quote
input verify space start import fail fast relationship headers specify space node header fail explain instead treat relationships bad
support vote raft vote add robustness leadership elections break change must explicitly enable follower initiate election receive quorum positive vote servers positive vote return server server ask vote therefore election trigger one server time majority servers time commit introduce visitor pattern raft message use raftmessagehandlers raftmessageencoder
test multiple index iterators open kernel apr level
ability provide import arguments argument
add java docs another chunk logical plan operators
understandable import execution monitor monitor take classic approach provide mean progress start end rely provide estimate approximate end lot detail typically unimportant users hide print type command console run import monitor also print estimate memory usage disk space usage time give progress print roughly infer though
input provide estimate import part work make individual file accessible input require couple refactoring multi readable data factory also introduce propertyvaluerecordsizecalculator calculate disk space usage value instance dry run encode quite precisely
merge
push towards surface also make constructor store factory redundant readonlyidgeneratorfactory able read meta data exist file use certain part migration
merge pull request add unionslottedpipe
merge pull request improve documentation gumtree
merge pull request pontus else clarify usage object procedures
introduce end modes store channel open use asa replace string constants newly introduce end
merge pull request fix close issue badcollectortest
accurate link progress multi ass
transactional log file abstraction group transaction log operations functionality newly introduce log file interface hide previously leak abstraction log file modules nothing transaction log introduce login builder simplify configuration access log file external modules
merge pull request bump timeouts pooledconcurrentmergeschedulertest
move trim trim text value
allow transaction log locate separate folder previously transaction log always locate directory store allow change specify logical log location relative path folder transaction log store allow place transaction log separate dedicate drive atm folders relative neon home allow part change backups update always remove transaction log successful backups integration test always put transaction log separate directories able copy store another instance custom transactional log directory place correct directory specific instance
add procedure clear query cache
update page cache test rely specify page size
remove lowlevelpropertycursortestbase
grammar spell java doc
fix deadlock issue forkedprocessorstep change processor count frequently back forth could potentially result processor thread stay alive longer expect could affect result process units turn could result deadlock completedbatchsender could forever observe batch incomplete whereas actually
add java doc argument validation test transaction template
fix count progress issue restart link state store node count distribution file
allocate two relationship record units next number estimate relationships exceed magic threshold
implement ternary equal value
remove compaction support double
reduce big tracker cache bytes since point time unreasonable import trillion nod one import also tighten test around number array actually fix issue value implementations
introduce index order capability schema index query schema index report order ascend descend capable provide give combination value group specific order result request request order must support give index reference moment single property number index capable result order order ascend provide nativeschemaindexprovider fusionschemaindexprovider
kernel inward kernel kernel interface describe kernel face towards world use like change name make implement
check dynamic processor assignment often
introduce wait get leader raft replicator without wait new timeout exception noleaderfoundexception would generate constantly leader elect
move simplenodevalueclient
transform case class case object
avoid create file query log actually enable also make settings dynamic update run time
renew election timeout thread instead process thread avoid timeouts refresh quickly elections trigger process thread slow block snapshot download leaderavailabilitytimers extract encapsulate timers elections heartbeats well timeouts last refresh time
add integration test confirm verbose tracers load
use file key monitor verify seed store switch compare file key compare final store file initial add file copy monitor pull transaction monitor test pull transaction monitor call
port indextxstateupdater new apr
use new apr node creation deletion core apr
return resource iterator provide possibility close underlie label index iterator without exhaust
handle auto index operations
add fig index creation test
clean
add support property read
add new utilities state mean keep track change property reference minor utility method find change properties
add new utilities state mean keep track change property reference minor utility method find change properties
allow point point array properties creation case underlie record format support otherwise throw exception ask user upgrade store format able use desire feature
property read state aware read property also check change state
update indextxstateupdater property change
support auto index operations order move exceptions kernel also move entity type
rebate fix
clean code style
use new apr core apr zip
simplify backup code add page cache parameter neon admin backup collapse inheritance implementation hierarchies collapse factory provider builder chain remove unused code shorten name class hide class accidentally add public apr make package private avoid use service load get default instance things alternatives service load collapse family helper class around configure online backup admin command single class
java docs explicit rewrite
default sequential flush high
use new apr property read
merge branch
recycle reuse batch object way less garbage
proper close statement get properties
fix typo
refactor leaderavailabilityhandler visitor pattern
add transaction log file header information dump
move labelnotfoundexception apr module
restore order shutdown cluster test
merge branch
merge branch
tree node consider node type key
support slot run time add foreachslottedpipe allocate inner variable los res allocation pass semantic table slot allocation use long slot variables list entities add slottedpipebuilderutils helpers make specialize getter setter function slot minor optimization empty projections fix arguments abstractletsemiapply update succeed acceptance test
core state download retry indefinitely raft message handler need new snapshot schedule download service pause application process download successful
merge tree node operations key value
update cluster edit use monitor due test move change get branch
add useful string cursors also properly close label cursor node cursor
fix multi readable issue avoid test
monitor delay raft message process performance delay duration marshal message start process time duration process raft message collectively group message type
support geometry new property cursor
improve timer service replace custom poll timer service simple abstraction work top job scheduler
break apart treen detest generic abstract test base cleanups private fix size tree node take value
respond feedback comment application process always resume make corestatedownloaderservice life reapplication add stop state persistentsnapshotdownloader call lifecycleadaptor stop state check run persistentsnapshotdownloader run one time logic
expand fusion index support include spatial index point
depend entitynotfoundexception compiler module binary dependency make impossible move exception need fix binary dependency versions least new release finally update dependencies
merge remote track branch
longer static initialize leaf internal longer static fix type crashgenerationcleanertest read value take value size dynamic size value treenodefixedsixetest treenodefixedsizetest cleanup treen detestable
refactor read monomorphic probably bottleneck make sense code style perspective well
change state behaviour persistent download move stop state separate volatile variable keep run make state variable volatile remove run method since use test synchronize method move state initial run make sure one run possible complete trust
add debug utilities turn useful
make cluster rule assign dedicate thread group member test cluster make easier debug problems cluster test case debugger show cluster member thread belong
data snapshot query execution introduce possibility execute query base data snapshot data modification mark correspond page version equal transaction particular change introduce also allow count store track transactions change introduce able guarantee query result base data present query execution start modify run engine verify page access query execution version less equal last close moment query start support snapshot query execution snapshot query execution enable set number retry engine try get stable snapshot control retry
data snapshot query execution introduce possibility execute query base data snapshot data modification mark correspond page version equal transaction particular change introduce also allow count store track transactions change introduce able guarantee query result base data present query execution start modify run engine verify page access query execution version less equal last close moment query start support snapshot query execution snapshot query execution enable set number retry engine try get stable snapshot control retry
remove scala warn warn annoy let fewer
use transaction get statement avoid unnecessary double lookup kernel transaction
merge pull request duplicate blacklist
merge remote track branch
merge branch
cleanup internaltreelogictest rely raw long value instead use long value seed indicate sort order use special assert method compare key value step make possible make test generic key value later also add miss assertion remove value
remove backup implementation public view put imply package
make internaltreelogictest generic key value
refactoring cache query plan usability instead staleness binary state say plan need replant immediately use plan little longer asynchronously schedule replant
integrate new tick support procedures exceptions
add alias apache license
move schema interfaces new apr
merge pull request stop varlengthexpandpipes override node null node
dynamic handle different spatial index handle index point different coordinate reference system create file actually use index
support check existence constraint
support get constraints
check constraints add label node
merge pull request fix regressions core apr
check constraints add property node
treenodedynamicsize imply part split leaf add possibility fragment leaf remove key mark dead avoid split leaf insert remove dead key fragment leaf instead fragment fix size implementation explicit change new method take responsibility find middle return overflow yes need defray instead boolean pageawarebytearraycursor throw write zero bytes new method primitive attack peek
merge remote track branch
fix support parse relationship group inconsistencies
add debug printer help debug query
less cursor allocations node proxy
treenodedynamicsize imply part split internal merge leaf also rightmost chain throw instead set cursor exception rely read
respect state index operations
merge pull request merge executioners wrappers test production
merge pull request stringent shutdown
merge remote track branch
small fix add java doc
page cursor put bytes int bytes byte value make possible fill part page byte without create array similar zap page
treenodedynamicsize imply part overwrite value overwrite value already exist guarantee old new value equal size equal size need remove old key value pair insert new lead underflow overflow also treenodedynamicsize fill reclaim space zero fragment tree node balance return split nothing rebalanced internal logic merge propagation structure change remove insert internaltreelogictestbase add randomize test conflict key
fix label index deletion issue deduce nod since label index build end need include delete duplicate nod
merge remote track branch
port space fill curve neon spatial separate module use future versions neon spatial library derive maintain two copy include envelope envelop test trim neon spatial versions might want refactor later either include neon spatial extend one
seekers test seekcursorstestbase generic
log index state null index
clear context statement close
clear context statement close
make part fusion index available spatial dynamic fusion
street generic
disable channel auto read bolt message queue
remove minor inefficiencies
define automatic module name java modules define reverse style module name use manifest file entry till maven modules gon convert real jigsaw modules see detail introduce separate property scala version since current version support target jim export miss package unnamed modules separate warm hug lovers remove jersey multiparty use artefacts extract bump jersey version
rely begin execute rollback concurrently transaction instead rely detect ongoing statement execution inspect active ongoing transactions
cleanup usage deprecate
improve cluster digit cover scenarios split cluster digit two parametrized test cluster digit seedingnewmemberit test seed type backup store empty backup backupcontainingsomedata log add monitor able track assert store copy
extract common functionality native number spatial index share lot functionality
refactor native index separate generic part prepare string spatial index
simplify property access new kernel apr especially regard transaction state read interface methods initialize node relationship property cursors previously methods entity reference argument limitation interaction property cursor make complicate encode different behaviour regard transaction state property reference top testate use additional helper pass information state property cursor result memory usage testate well via map simplify let read methods accept node reference node properties call relationship reference relationship properties call testate leave interaction properties map remove also result simpler cursor code
importer correctly delete everything duplicate nod even dynamic label record property record
introduce specialise primitive long version diff set
extract interface new pack make easier plug different version example support new type like point geometry date
dynamic settings
fix bug render inequality expressions improve readability
make sure min max range base cars
update neon admin usage text
print tree open writer gumtree
fix relationship count issue data statistics
use cursor directly instead intermediate iterator direct access cursor get significant speedup instead delegate via iterator label scan
support multiple label state add ability query transaction state change multiple label
move feature toggle call constructor
unify prune var implementations
allow track version context transaction execute multiple thread transactions rest end point check version context cursor reposition current page check version context state eager result visit serialization since bolt rest writers try load properties nod relationships database part result send client well since execute outside query need expand version check verify stream result still base valid snapshot dirty context notice exception throw since restart query late client already get partial result
guarantee release cleaner lock gumtree cleanup job process job release cleaner lock separate run close recoverycleanupworkcollector close cleanup job thus release cleaner lock without actually run cleanup job make possible open dirty gumtree write new header without start cleanup job risk deadlock checkpoint need write header cleanup job
merge pull request use primitive long diff set index state diffs
introduce value type date time
better java doc dynamics email
change lock implementation usage across test
accept spatial newark
try fix fault test flakiness strengthen test isolation
fix case static initialise reference subclass situations lead class loader deadlocks super class sub class end load concurrently two different thread case fix lock place public apr another leave due unpredictable consequences forward merge
callable function work value introduce value mapper type value mapper translate value type systems case java class embed apr
use new apr index operations core apr
merge remote track branch
use correct limit
fix value spatial test
add state awareness relationships cursor implementation duplicate code node cursor logic hard share non complicate way requirement inherit respective record class
prefix cursor implementations
testate aware relationship traversal non dense node
bolt point type support introduce extension bolt one additional type point new protocol version exactly previous one able point arbitrary dimensional point support serialization format generic allow array point coordinate make protocol test utilities able work different protocol versions
add spatial fusion test
halt connection write throttle hold configure duration
page cursor shift bytes efficient way shift bytes within one page
use new apr create node
make iterator lazily initialize turn need initialize iterator lazily otherwise mess semantics around removals label initialization iterator create open iterator label scan remove label node already fetch node step
extract common code range seek
fix exception message spell error muninnpagecache
introduce builders temporal value
update new field access use unsafe test newly introduce helper methods
update new field access use unsafe test newly introduce helper methods
fix performance bug filter tie early
make test configurations easier understand update
monitor search cover area hook bug fix getnormalizedcoord
migrate core apr imply kernel apr
support value writer temporal value
add
back port fix planner bug join
simplify grab allocator exception handle
merge
fix compilation errors
introduce remain temporal function also slight simplify refactoring structure builder
raft elections compatible refuse leader
initial version page version track page bytes version track test work
allow check style fail build command line
add random function cypher
merge pull request fix issue switch chunk stringcollisionvalues
semi automatic code cleanup explicit collapse identical catch block prefer try resource prefer lambdas method reference unnecessary cast
perform execution query also parameters pass map value
fix assumption see cursor node leaf two read node node could delete reuse internal node would make read key assumption leaf read garbage data potentially cause bound
change relationship selection helper cursors iterators better fit current usage pattern core apr cypher run time
make swapper short update map use bytes map swapper
let execute also run base scenario transaction
basic implementation native schema string index layer much change make test class utilities generic value type well copy type specific index code number schema index class also basic non optimize implementation string schema index access string layout friends focus get functionality place first foremost
order ability temporal value
add test property level access
add test property level access
fix comparator handle larger durations also fix review comment
force native allocations reallocation track amount request free bytes
split security context login context security context login context hold authentication information need begin transaction hold authorization information however acquire transaction begin store security context
split security context login context security context login context hold authentication information need begin transaction hold authorization information however acquire transaction begin store security context
merge remote track branch
merge branch
add method give page file figure file map
add support scalar temporal value property store commit support scalar value except date time zone ids ignore check whether underlie store actually support temporal value add array support yet
extract interface store file providers
introduce bolt scheduler simple bolt server thread management
native index recovery cleanup try recover native label scan store allow native scan store shutdown even init fail cleanup recoverrequiredchecker
review comment
fix bug byte code generation multiple affect generate equal methods use group key distinct aggregation first two key compile time determine accidental order compare
break one method per direction instead send direction switch direction separate methods leave caller choose cursor iterator
optimize
fix cluster seed
procedure show instal protocols raft connections
store array temporal value limit precision zone offset minutes compatible drivers
fix possible arrayindexoutofboundsexceptions
minor tweak memory allocation trackers
rename neon cypher front end open cypher front end add lengthier description
negotiate install modifiers protocols handshake installedprotocolsprocedure include modifier protocols split modifier protocols nettypipelinebuilder server client
add byte buffer method use method choose quickly copy memory page cursors interpretation simplify case inconsistent read robust record decode difficult
identify bloom index status
use cursor directly anodes cooperator
merge remote track branch
merge remote track branch
plan pattern comprehension inside unwind correctly
increase test coverage spatial index one fail test ignore debug
make read limiter test compatible bolt connection
actually remove apply update queue multi thread population
zip sons expand discovery service database name base filter database name specify distinct raft group produce different cluster discovery take small step towards use filter list reserve procedure modify cluster overview role procedures reflect database name fact may multiple leaders cluster add cluster cluster process runner class manual test refactored common code process cluster runners builder add unit integration test server side component request rout feature also overhaul share discovery service behave like hazel cast discovery service simpler reason
merge pull request check access mode token read
read time zone resource file extend test map test assert support name java support support one delete name new time zone add ian package java yet
merge pull request plan pattern comprehension inside unwind correctly
read spacefillingcurveconfiguration neon settings
netty final
elector identification happen reliably instance join cluster assume members receive configuration response alive mean newly join instance lowest number alive one others lower number fail choose trigger elections update liken state afterwards suspicion gossip alter since mark member fail result elections member hold roles patch address issue make liken information part configuration response consult list first election request get alive instance remove cluster say currently fail end reliable list alive members check see elector
allow consistency checker warn index dirty return wrong result dirty native index index require recovery next non read startup potentially data index moment index dirty fully trust able commit allow notify index check report
ensure cache profile copy online backup
add eclipse collections library
dynamic port configurations connectors server test
replace primitive stack eclipse collections
close procedure stream failures make sure call close handlers attach procedure stream exceptions exceptions occur close collect resourceclosefailureexception attach suppress introduce kernel statement keep track active resources non exhaust procedure stream always close transaction close query execution without close query result first resource manager implementation separate class closeableresourcemanager easily move keep kernel statement future also improve error message
support set property relationships
support relationshipremoveproperty
port relationship property operations kernel apr
style guide fix
move entitynotfoundexception hold move entitynotfoundexception since binary dependency legacy cypher version however fix free move
add clean logic handle transactions thread
outgo count check state
inject active read operators merge plan convert
use kernel apr node proxy get degree
merge remote track branch
code review fix
merge branch
let value implement comparable
improve description settings
create feature toggle twolayertransactionstate insert eagerness plan code later
temporal creation part selection map refactor builder pattern share code create select less code duplication
replace primitiveintlongmap eclipse collections
make job scheduler delegate global pool actually execute schedule task instead use schedule pool exclusively trigger say task
change check exist spatial index move check retinitis state ensure index descriptor available creation also rename spatial windex spatialcrssschemaindex
replace primitively bitmap eclipse collections
implement count node count store kernel apr
add area volume check space fill curve
feedback code review
login context authorize take lambda instead circular dependency need security context property level security
remove availability use token store outside transaction ability use token store outside transaction make hard property level security currently really use case longer allow
selection local anytime date time
port explicit index procedures kernel apr
less aggressive test page eviction use test page eviction friendly ongoing background eviction previous aggressive possible eviction stick cooperative exception encounter
string functionality temporal duration
fix bug unsupported default value procedures
fix case select time timezone
native index consider limit flush checkpoint limit impose flush store file disruptive normal operations limit respect index live top page cache flush without limit longer case
support remove graph property
make graphpropertiesproxy use kernel apr
temporal truncation
new temporal index base gumtree index support temporal subtypes index subtypes lazily create first write
hook temporal index add test
make timebasedtasksschedulertest flaky
use method handle invoke arguments uhf
name
enable online update temporal value
start implement prefix query
add support local time temporal index
better handle degree compile run time point calculate degree non dense nod since amount loop relationship chain might well start expand right away compute degrees nod dense one dense start non dense one otherwise stick get
add support local date time temporal index
address review comment
public static field final
remove graphite unite remove remove disable multiple graph test
simplify fusion class lot use unify access part array make add change list part easy conflict change
merge
address review comment
define apr function kernel apr commit big since include move stuff kernel apr mean lot import affect
implement methods function kernel apr
stop thread transportwritethrottletest test method use separate thread acquire throttle lock channel writable thread stop spin background generate garbage invoke mock tight loop every mock invocation record create stack trace cause test sometimes make fork crash room commit make test stop thread sleep bite every invocation create less mock invocations
correct spell close sign
remove unnecessary box boolean
fix test assumption index sample
apr get call procedures
configurable raft compression implementations allowable handshake support snappy zip
add ability switch heap state allocation
parse return graph author
merge pull request elector identification happen reliably
dummy open close resource
handle equality comparison correctly
add support temporal type batch importer date time date time local time local anytime duration default time zone derive database set
merge remote track branch
use kernel node getrelationshiptypes
use kernel apr initialize relationship proxy cursor instead visitor
make timebasedtaskscheduler use priority queue schedule instead sort link list simplify code bite also better performance characteristics large number schedule task
refactor range predicate share base class
merge pull request add support spatial point value batch importer
use simplify layout key model
fix test corrupt crash surefire fork use system
support byte user define function aggregate function
address multi cluster review general cleanup
flaky test fix
merge remote track branch
update mock store
change schema mph use kernel apr read
fix issue temporal spatial exist query
add operator
add option specify cars csc header point might need test especially load relationships point properties
port spatial follow pattern temporal index
remove unused class
fix test assumption index result order
add index test array length
backup separate sol policy
merge pull request update java driver dependency
configurable spatial index move spatial index settings separate file make extents configurable save read index settings
test schema read write
implement schema write
merge pull request fix presumable copy flaky
merge
cleanup constraint index creator monitor
fix bug index suffix contain query modify nod
redesign store stream want avoid use append write file since file retry would get situation file would append begin half finish file store stream would previously use kind mix design page file would store map normal file would open new output stream append introduce storefilestreamprovider catch client store stream need close append disable always start retry download file
remove almost instance statementinnewtransaction
implement composite find nod core apr
create super sub rout procedures multi cluster feature super procedure simply return list router capable host cluster split database name sub procedure similar though take database name parameter return router capable host contain database
retry resilient string make compare well reduplication common native schema key initialization code rest flag entity
use upstream strategy store copy move upstream strategies separate package accessible core read replicas read replicas bind use upstream strategies store copy core use leader primary address upstream strategy secondary address store copy client use secondary individual file index request check active connection send catch client
fix equal zone date time add min max
expose schema state storage engine
remove unneeded factory methods
move half open range computation space fill curve
make time value time require zone offset
replace primitive inset
merge remote track branch
cleanups around time value
index provider lucent implement fusion index
support value compile run time introduce track value type subtype representation type code genotype let parameters stay type value let property value stay type value let literal list map value handle type internally bunch place
exit loop early test say behaviour
catch client protocol negotiation
accessory epoch second offset minutes also support epoch second creation rename epoch epoch mill
break catch server handler
replace primitive longest
remove warn allow spatial plugin extend class tree
support spatial temporal index provider lucent
add support spatial temporal index provider fusion
manage resource iterators explicitly knowledge iterators inherent resources must reflect apr contract hide hood implicit instance check
support timezone csc header refactored header parse point
separate index provider fusion fusion
make sure page cache profile file delete online backup store copy
improvements review misc java doc comment clarifications refactoring composite find nod
small commons code poms cleanup remove duplicate dependency redundant scope
define index capabilities spatial temporal spatial value capability order capability none temporal value capability yes order capability ascend
unify behaviour arithmetic exception across run time match function value module throw arithmetic java exceptions neon exceptions lead different behaviour across run time compile run time let alter message long overflow come java make sure wrap public neon exception float point division throw zero division zero well define representations free float point standard would rude abort query unless user opt trap float point exceptional condition currently jim support trap
wait futures complete instead timeouts delete stress test
make extract eager
port test use kernel apr
merge pull request solve join hint variable join variables possible
port explicate proxy use kernel apr
close auto commit transaction execution stream fail
move internal transactionfailureexception kernel apr
extend match helper test value
handle thread safety part creation
remove unused bootstrapped class relate obsolete test
obfuscate lap system password string
obfuscate lap system password string
raft synchronous snapshot download block raft download snapshot
fix test work java urls seem relax java things fail slightly later different valid exception
csc parser treat white space character white space
remove primitive
make temporal geocache use concurrent map
create new value exception split test different cause exception wrap java methods throw date exception change exception type
merge pull request add file separators name part construct correct windows file name
remove old binary file
remove external access statement atari operations
backup longer show errors success test add prove errors display successful backup resolve
address review comment report errors type unpack
add valid value backup pro flag add example value online backup client protocol flag
rename profile count descriptive profile sequence
fix page cache profile sort order
add docs fig around backups
obfuscate secret figs place logger pass figs call update result even though admin action read obfuscate case reason
replace primitivelongobjectmap
lock test
add mark functionality page cursor mark allow page cursor mark current offset page cursor offset later reset mark use setoffsettomark functionality useful retry read example add benefit setoffsettomark force new bound check
improve scan speed avoid division modulus
add test constraints tall constraintgetbylabel
add test index tall indexesgetbylabel
bump reva versions reva maven plugin reva java reva basic feature
enforce ratio short side long side search envelope max avoid bad performance thin rectangles spacial index range query ensure rectangle least ratio shorter longer side rectangle cube get false positives handle post filter avoid many small search range native index
move rectangle pad max depth instead actual search space
change nodeuniqueindexseek use fresh index reader
first draft make version index entry hash work well value type
zip
make backup name onlinebackuphait unique backup name may collide test make backup name unique
wait process thread finish lonelyprocessingsteptest
remove duplicate apr mix test
migrate assertion
fix bug compile aggregation key code equal need handle primitive type generate method aggregation key one element
fix small test test add remove new label instead remove wrong label mean stay
reduce boilerplate nodewritetestbase
merge pull request support access time date time
spatial temporal assume file existence remove assumption spatial temporal index least file startup start store neon without migration legacy schema index would report initial state populate spatial temporal index assume file exist startup case open store first time cause index rebuild exactly even need recovery file existence assumption spatial temporal mean guard file delete create subindex file lazily anyway guard cover many case also improve index migration test verify recovery old index startup
access signature members need
call methods inside loop
use eclipse collections primitive int iterators
allow drop break constraint index case constraint index normally drop directly instead constraint drop instead however index back constraint create index constraint create separately historically bug allow constraint index create link constraint record constraint record never create orphan index still accept function index index service really usable without constraint previously index would get stick state without constraint drop one case fix back allow constraint index drop one particular case however number case miss fix remain case constraint index link constraint drop case still maintain behaviour constraint index directly drop check index actually link valid constraint
coordinate instantiate close spatial temporal index one one native index like number string update interactions call close prohibit coordinate inside gumtree spatial temporal index structure lazy instantiation sub index coordination mean call close could race instantiation one sub index turn would result open sub index gumtree instance would never get close contractually good tighten behave practically find population scenario index population cancel run
merge pull request use normal conditional instead bite wise
remove map type parameters
transaction state support specify provider create index able override default particular index creation
kernel apr ability specify provider index creation
merge pull request unlike use separate test directories different stress test
replace chain switch
fix typo
remove unused code
better name token creator method
builtin procedures index creation builtin procedures enterprisebuiltinprocedure procedures allow user specify index provider upon index constraint creation otherwise control change need restart like procedures interact schema index take schema pattern label prop prop argument well index provider name allow index provider name correspond allow value set label property tokens miss create need need way mitigate limitations native string index length limit support contain end create index constraint cypher default index provider always use default provider control set change set user restart sad procedures allow user specify index provider per index creation without restart give user two different ways create index bad optimal way would support cypher language release feasible fall back procedures way
license
add test verify hold lock hole time
make new query cache generic improve concurrent plan
merge pull request neon admin rec calculate size
use inline mock see mock issue
fix break test
make compatibility cache concurrency safe
cleanup review
remove old query cache reduce cache
document rename lookup method indexprovidermap make much sense
merge pull request remove duplicate parameter parametrized propertyconstraintsstressit
add nextalphastringmethod
add nextalphanumericstringmethod
add nextstringmethod
extract failure handle
aka base discovery service new server select discovery service back end fig introduce ssldiscoveryservicefactory interface cluster test class type parameter distinguish sol discovery service factory
bump neon browser version
merge pull request bump neon browser version
make throw eviction exception really need assert page cache close strictly necessary method assert page cache healthy furthermore use implement check eviction exception outright harmful method one ways clear eviction exception background eviction thread also longer spin forever evict page throw exceptions make test easier
use primitive long diff set nod label
remove dead code
merge pull request test property level security
merge storage statement store player split storage engine store player getter singleton instance could create statement contain accessory require sort state reader weird ways store player pass storage statement methods bite schizophrenic practical use store player also require statement always hand hand anyway storage engine store player instantiate new store player keep kit would previously except kit additionally create new statement
use primitive long diff set relationships
allow different map value implementations
make scheme descriptor index reference change index create
make schema rule interface
rename scheme descriptor pendingindexdescriptor index rule index descriptor schemaindexdescriptorfactory indexdescriptorfactor
test create index procedures cypher
use real index descriptors index
add dependency random value
test create index procedures cluster
remove traversal endpoints drop rhino dependency
avoid generate consecutive failure message
move capableindexdescriptor
better assumption message internaltreelogictestbase
update page list docs restructure constants
rework store descriptor constructors
merge branch
remove constructor
remove front end move front end neon open cypher name space repository
merge pull request run time interface
fix review comment
add filter function map value
add update map value
move combine update
break store cursors default cursors
tentatively use mutable map eclipse collections
raft protocol version serialize replicate content raft log entries handle netty see fit channel marshal interface still exist write read raft log use encode decode netty
move drop value list value
index create test failure different index type
back port implement page cache feature need experimental parallel flush rudimentary page cache warmer back port
fix ape forest client lock count newly introduce eclipse collections fail size evaluation due racy nature lock count forest prs update use map implementation avoid ape also part duplicate lock count code forest client remove test class rewrite unit clean
prevent concurrent access process batch rejection
merge remote track branch
merge pull request fix bug direct project endpoints end point scope
flush force parallel configuration allow add way determine limiter currently limit
merge pull request clean plan context
make buffer size use load csc configurable csc file contain huge field currently fail error really way configure around problem
clean around index descriptor constructors
aggregation sum avg durations
add primitive hash map implementation use node join
remove unused parameter toilet transaction
make state aware
make state aware
code review provide error valid context
license copyright update
merge pull request introduce enterprisedbstructuretool
remove old replicate content marshal
update license headers rebate
change node update entity update mean support relationship update handle multi token schema order test multi token schema also introduce
extract interface store cursor move physical node read detail
extract interface relationship group store cursors simplify implementations avoid lot complexity introduce relationshipreferenceencoding
morsel top operator top implement preston reduce valid row assure first entries morsel sort morse size sort whole morsel merger operator modify able merge sort give limit use top
move store cursors record storage package
removal old storage cursors replace remain usages new storage cursors
merge pull request abort replication miss leader leader switch
index population relationship index
full add support
rename class
separate expressions multiple class
license copyright change change copyright new neon entity name add commons clause license components
merge pull request small cleanup around bolt state machine
generic lucent index
update module test unit introduce common extensions rewrite except parametrized test unit introduce common test extensions introduce inject annotation inject test resources custom extensions
log unexpected failures
fix wrong use server set fig
merge remote track branch
merge remote track branch
try set end vars start number allow
count raft replication events precisely count new replication attempt successful fail also log number attempt
use better collections possible use primitive map let also common use node join
lock rel multi token index
fix log format
unlink local memory tracker global one
implement heap longest testate
inv support backup client add support parse command line input include inv address
backup temporary directory rotation fix file reactions non page cache file copy evident backups make temporary directory rename successful change fix file move action always move copy rename file reaction helpers
backup temporary directory rotation fix file reactions non page cache file copy evident backups make temporary directory rename successful change fix file move action always move copy
load property key label index many many label add many nod label index load property key unnecessary drastically slow query property key already page cache case turn query take minutes one take hour close sign
rename onlinebackupcontextbuilder factory
move couple class relate record storage correct place instead arbitrary state package also remove unused class methods
move edition creation kernel separate module edition platform creation community edition move away kernel integration test helper class integration test move modules
start work add new schema procedure add method get common type name value make label set able use key map
change factory entity builder
update log message around index constraints population attempt update log message around index constraints population avoid confusion population completion index creation completion
simplify token management two major track commit unify token instance use new name token everywhere old token remove well custom subclasses specific type token instance use generics lot place throughout whole stack sole purpose keep relationship token instance also implement relationship type could hand via embed apr create additional instance label bow worth consider overhead specialization many place break default token creator dependency generator factory instead make storage reader able reserve token ids reserve node relationship ids currently good tokens generic database aspect whereas generator factory quite tie current storage implementation relationship token older storage engine storage engine load tokens open store otherwise provide new ids create new tokens kernel otherwise use populate token holders implement
change mislead comment
refactoring
client side host name verification san host name verification work server public certificate include extension subject alternative name list match client obtain servers public certificate negotiate tvs handshake check host name use connect common name subject alternative name declare servers public certificate address use match server sans connection terminate note server side host name verification though subject name identification enable protocol may possible far need change introduce onconnectsslhandlerinjectorhandler replace netty handler connection establish handler engine really need host name use connection init create correct handler onconnectsslhandlerinjectorhandler create trustmanagerfactoryprovider move implementation sol policyholder though necessary host name verification legacy policies host name verification
plan pattern comprehension projection use recursive logic pattern comprehensions inside pattern comprehensions plan properly
neostoredatasource dependencies life cycle simplify possible possible parent child relationships dependency resolver possible setup parent dependency resolver supplier use platform dependency resolver parent new store data source resolver
index provider layer
bump version support java fix flaky test
refactor bolt state machine extensible bolt state machine responsible keep track correspond bolt connection process incoming bolt message extensible clear set state machine interfaces define state represent end bolt connection abstraction suppose independent bolt state machine always use version state machine commit introduce attempt protocol version independent instead expose methods protocol message single method take generic message object argument state state machine represent class process generic incoming message return new state also extract set potentially common interfaces class reuse different versions state machine
remove unused collections factory methods
merge branch
add test
merge remote track branch
refactoring remove need push around object cast
make sure properly plan expressions use expressions need pass patternexpressionsolver add logical plan
test online exudate
update compiler dependencies
merge remote track branch
make date
extract common part token debase lot duplicate code along whole token stack clear
quick import start job scheduler properly
work groundwork composite key
extend test include array string
add ability get null ability
granular composite index test index access test different type except spatial array leave include test combinations different query type exactly change exactwithprefixrange exact atheists range atheists prefixrangewithexists
addition message online backup extensions add additional trace message able get useful log failures also fix test break new dependency model
wait index online builtin procedures
large refactor execution result plan descriptions plan descriptions generate directly logical plan instead base physical operators make plan descriptions run time part add arguments enable profile run time produce plan execute profile turn query profile hand plan description builder enrich plan description internal execution result internalexecutionresult clean test code functionality live rewindableexecutionresult also things change standardinternadexecutionresult class responsible execution meta data policies around materialize result early closingexecutionresult responsible close execution result due end row exceptions run time implement much slimmer result instead internalexecutionresult hold primary functionality relate get result profile information notably run time longer custom close result materialization value conversion
merge branch
transactional safe file basically new implementation generator crash safe lock free never lose ids base gumtree use much like label index bite set build support buffer delay reuse act safety mechanism neon prevent transactions read two versions create delete create record use unused state change commit execution path members cluster agree exact set free ids recovery also update generators much like update index new index generator replace generator imply require user settings whatsoever behave regardless edition whole settings also remove implementation assume causal cluster generation change hand range cluster members instead work like lock work give moment one member special role able allocate ids state single instance work
adapt periodic commit rest transactional endpoint
single thread scheduler replace dispatcher
fix java doc
await database startup try restart slave service mode switcher define module place life database components possible vote even switch new state happen components platform life gon finish start sure stop service slave switch already start race anywhere gon wait till database available
add closingexecutionresulttest
test boolean indexprovidercompatibilitytestsuite
zip debug array support
default database zip
implement heap map store properties state
add hello message replace old init message new hello message follow follow format message format hello metadata request metadata key user agent key use auth token response metadata key success server rout table connection close conn failure
update next set test pass default database change test folder layout
move test kernel
port property schema procedure
fix file access windows
generic estate zone time array byte array work correctly
improvements cleanup onconnectsslhandlerinjectorhandler change way engine modifications apply remove excessive log add omit functionality address radar werner son comment
return list property value type instead infer common type
convert exception unchecked exception index relate class simplify lambda usages
return list property value type instead infer common type
procedures list kill network connections add three new procedures allow list termination help tip bolt connections list expose connection name connector username authenticate connect time client server address procedures help users track system activity investigate connectivity problems
add new state machine state state machine add decoder read message add test verify state machine
make sure nod res without properties mark null able add test ensure creation order empty entities influence result
make sure nod res without properties mark null able add test ensure creation order empty entities influence result
check style
bump neon browser version
test pass cleanup
backup
rename methods expose database directory store dir represent clean relate test
rename test directory databases rule methods better represent provide introduce database directory helper methods
reduce memory usage replicate transaction transaction representation serialize netty previously would serialize replicatedtransactionfactory send raft replicator operation would write entire transaction heap buffer copy buffer array would use time size transaction representation handle representation marshal write one storage command time directly netty direct buffer hence extra heap use time size instead time previous implementation would also write entire transaction netty direct buffer command stream miserable write one command time send chunk mean memory allocate netty large larges store command transaction would size entire transaction avoid allocate direct buffer larger netty pool chunk boundedness rechannel use write chunk buffer queue buffer ever larger provide max size
add instrumentation disable compile expressions mostly test benchmarking case bug good able disable compile expressions without completely disable slot run time
comment use graphdatabasesettings schema index source truth index provider name
update keypad capsize treenodedynamicsize test insert limit
store copy catch avoid self case store catch would pick target catch even though would retry case change prevent core pick target catch
use input stream bytearraychunkencoder write input stream buffer would extra array copy instead keep track position improve performance
provide order capability value capability scala index descriptor enhance index descriptor lambda function ask order capability value capability certain type commit also remove except one apply method index descriptor overload like crazy
implementation minimal splitter generic estate text minimal splitter subpar right key byte array first position leave right key differ way native string index implement minimal splitter array work way instead compare byte byte compare one whole position time array text opportunity also compare individual string level position two key first differ leave
remove duplicate bridgingindexprogressor keep one support multiple thread add sub progress support case overhead concurrent queue negligible grander scheme things consult per sub provider fusion scenario
add search test nodevalueindexcursortestbase
remove unnecessary word
improve handle malformed begin run metadata make metadata parse errors result failure message previously force bolt server close connection errors happen bookmark format invalid transaction timeout metadata parse illegal type
simplify facade method test extend transaction check facade methods
testate new methods return diff set property value retrieve actual property value index index query need also get actual property value state instead ids add nod add new methods index operations get diff set include property value
remove bolt message log use
cheaper sample native index population one pass raw index key end instead keep map unique value map well materialize value expensive
first insertion space fill curve settings layout key
thorough test index definition operations state
deprecate explicit auto manual legacy index apis removal
set conditionally node precursor would always possible set true serialize value even caller index operation need property value caller codeine seeker decide whether value need add parametrized test hit code paths value need
extra test verify need post eager
introduce database store layout use kind store file access create file database store internal tool code need use database layout abstraction instead direct file manipulations
fix fail test
revert license text
let authorize take database name parameter
add additional information core availability endpoints core display additional information useful roll upgrade status
remove class name base service keyword shorthand instead always explicit service keywords use
clearer method name call methods setupsecuritymodule split createsecuritymodule setupsecuritymodule clarity
use unchecked exception instead assert testate readers
refactor index update methods testate class
update cypher compiler dependency
implement test systemgraphrealm test usermanagementprocedures work way internalflatfilerealm handle common query construct separate class systemgraphexecutor
fix backup default catch port backup default catch port change transaction address backup address
propagate database name generator open call
switch use factory methods
fix bug spatial inequalities include point
remove unused rewrite
add unit test testate get exudate getsortedindexupdates
remove timestamp function need separate function since equivalent
fix miss name change file
fix spatial inequalities non index testate case
fix spatial inequalities non index testate case
ability compute cypher type properties index seek able expos
test validation index key size single value index fix bug biggest reasonable array small
set cursor exception inside generic estate instead composite rickey get detail error
propagate file store class database layout
fix spatial within work improver ternary compare
fix spatial within work improver ternary compare
remove input cache importer turn use anymore since importer instead read input one never need back input afterwards fix
merge remote track branch
remove unused code
modify threadsafedatawritertest make inflate easier
indexstatisticstest shape deterministic flip online expect update sample always know need within margin error perform consistency check index population test refactoring use person name tokens everywhere make population concurrent update actually happen concurrently due update thread await population thread start
split rename extract exist availability infrastructure code
cleanup
move cheap availability guard edition data source
remove cursor pool page cache level
index population apply concurrent update main issue regardless population scan currently previously index population scan would digress normal scan apply update trickle concurrent transactions population run update would ignore entity scan already visit would visit later apply instead merely performance optimization flaw one consider label scan work drive index population scan label scan reader read bite set size loop bits one per entity move read next problem arise concurrent creation happen right front scan inside bite set range label scan currently time time population would decide apply external update would result particular update skip label scan miss result would index inconsistent store even successfully population online index consistency checker run would also point fix err safe side always apply external update even front scan simpler better side index population work concurrent transactions affect index compare previously statistically twice many external update apply index population another relate issue another problem apply update right end population executor would shut able apply final update would also miss also fix
merge remote track branch
use transaction provide availability guard check database availability instead use global availability guard threadtostatementcontextbridge
fix break prefix index seek testate contain non string update
generickeystatetest copy assertion retype compare value minimal splitter fix issue minimal splitter properly handle array string size fix issue assertion retype check spatial array
compilation errors new class
move bridge edition module since dependency global guard use global guard bridge since change atm change observable exceptions user get erroneous case
add spatial test compositeindexaccessorcompatibility
use correct version unit assertions code base use correct assertions able get descriptive message case failure
deprecate internal file
merge remote track branch
merge remote track branch
let join hint planner understand leaf additional variables
remove outdated comment test
remove newly succeed test blacklist
remove database name generator interface
use instead cars header geometry value
randomize test utfstringvalue compare test string value utfstringvalue always return compare result actually work string contain code point greater bits show disable test utfstringvaluerandomtest
split generic estate separate class still work share state generic estate though much readable maintainable less repetition also seem performance benefit invoke methods type compare switch type place read write compare etc
fail public apr check new add class new public apr class trigger explicit error default prevent accidental leak public apr case intend change new class add correspond justification
merge remote track branch
change return type testate interchange allow fix order add
let testate interchange perform index scan order
let testate interchange perform descend prefix range seek
provide result order index range prefix scan incl state
merge branch
merge branch
fix minor geometry issue generic estate also test geometry value longer invalid
use job scheduler page cache thread almost introduce simple thread pool base scheduler implementation test cleanup test schedulers implementation bite
bump maven plugin versions introduce minimal maven version requirement set currently use version
handle together limit documentation state accept expression evaluate positive integer however expression refer nod relationships currently however lead situation also make worse recent rewrite since temporal function hood also get ape extremely useful
add
fix issue generic estate minimal splitter geometry array miss break statement
add support import migration systemgraphrealm redefine first time initialization system graph auth provider also take account import command migration internalflatfilerealm support import file copy important command allow migration exist auth roles file default user predefined roles work include support admin command set initial password set default admin move legacy credential kernel security module
merge remote track branch
label index reader keep update concurrent update important index population see create entities right front scan pause apply external update internally time batch update apply label index reader restart current range see ids within range skip allow populations guarantee update come scan index therefore index efficiently possible
indexprovidercompatibilitytestsuite consistency check tree test
add randomize test composite property index
cache query without enough parameters
merge remote track branch
move rewrite phase test neon front end
add index upgrade test
descend order single property number string boolean temporal
make full text schema index refuse work kernel context community edition
shutdown custom backup service page cache scheduler case backupprotocolservice create without externally provide page cache another separate independent instance create need close addition leak page cache memory scheduler independent page cache use also never close source leak thread able avoid memory thread leak new backupprotocolservicefactory introduce allow constructions various variants backupprotocolservice also service class update auto loveable result backupprotocolservice clients ability release resources close service require operations
include review feedback
efficient generic estate compare value
descend order composite include array
propagate require order across query graph
private field add remove
randomize range query test simple composite index
reserve system database editions reserve name system database editions even editions simplify edition upgrade move default database name system database name common settings
deprecate high availability high availability edition database deprecate favour causal cluster high availability relate public public code remove next major release existent tool usages update use causal cluster instead
allow disable help neon server change help connector enable order start database tip bolt connectors optional commit allow disable help connector via set also possible disable help tip make database accessible via bolt configuration make neon start embed jetty server neon browser rest endpoints thus accessible usual address disable help useful operators need enforce secure connections help connector mandatory server boot rappers able instantiate neon server create database life cycle core database manage entirely server commit make boot rappers able create core database separately server component base connector configuration boot rappers decide server component need dummy instantiate help tip turn base server implementations able start either help tip enable
multi database single raft group
short string decode encode byte utfstringvalue instead less efficient char string string value
correct slot allocation cache node properties join make sure propagate cache node properties children join require particular care add res ref slot interleave cache node properties since share ref array
add index reader distinct value main purpose access distinct value count value regardless index provider procedures float around index reader provider back lucent work native index two point ugliness commit cast layout schema layout nativeschemaindexreader prevent bigger refactoring already hash index throw unsupportedoperationexception distinct value functionality really need test index hash index memory index whole remove
add index reader distinct value main purpose access distinct value count value regardless index provider procedures float around index reader provider back lucent work native index two point ugliness commit cast layout schema layout nativeschemaindexreader prevent bigger refactoring already hash index throw unsupportedoperationexception distinct value functionality really need test index hash index memory index whole remove
point index coordinate tree index allow index recreate actual point value instance avoid round trip property store
use composite simulator message accumulator seem give great performance boost large see degradation smaller size possible reset old simulator feature toggle
randomize index order test non composite
add fig parameters necessary configure user log stout rotate file
fix typo expressions expressions
use security settings constants instead hard cod value
constraintindexcreationit assert lucent specific things lucent index use index provider include lucent sub provider
inject node value ask genetic native index provider index query target index back generic native index provider ability serve property value except point commit introduce value injector fill remain capability perform property store lookup mean index seem capable return property value kernel apr users
let set initial password command overwrite default neon user let command overwrite default neon user yet modify password still default neon
store passwords array clear use store passwords memory string object since content internal array survive garbage collect change credentials field auth token map uhf encode byte clear credentials immediately use overwrite zero change use manager interface methods take password byte convert char plugin auth token
fix bug okapi schema
consistent failure check tree consistency checker
fix bug relationships refactored test procedure
add inactivity timeout catch client although unusual could end scenario server crash connection still open
make sure stream transactions far require fail rare race occur transaction log prune come iteration transactions span several file progress pruner delete file ahead kernel transaction cursor notice previously would lead fall short safety check add work regardless cursor behaviour
gather non unique native index popular test umbrella unique except spatial expect need special treatment later
efficient property read index population use new internal kernel apr keep one cursor open instead open new cursors every read make change storageentitycursor convenient use entity level case cursor could either node relationship cursor
expose plan description query snapshot lazily avoid performance regressions plan description creation quite costly note laziness safe plan change plan complete
update default index provider determination flow since already settings use specify default schema index provider actually make use default value instead null use value determine default index provider initialisation result also need index provider optional parameter since always one provide user fig use priorities trick determine default provider use exist system property also remove restrictions providers define property since dynamically load value extensions class path also introduce helper method get dependencies type dependency resolver couple default constructors common parameters
include index procedure output include index simplify identification index database store case index investigation require
merge remote track branch
detach database recovery separate database recovery database server life cycle allow particular database recovery without start full database service introduce new facade entity use recovery check database require recovery recovery perform completely new separate database need recover life cycle new separate instance kernel extensions start participate recovery extensions mark instantiate purpose end recovery new checkpoint gon perform recovery still guarantee index fully rebuild case database require recovery perform recovery top gon anything
use commons lang test reflection til
contribute full text schema index community edition
panic service panic service handle events case panic service thread try execute register event handlers order case panic exception print panic event handlers preferably minimalist possible consider resources may limit case panic currently panic instance execute follow events case panic raise availability guard panic kernel panic command application process panic raft machine disable catch server backup server shutdown life core
merge remote track branch
cypher plan index seek full text schema index
index service log deprecate index providers use log warn index back deprecate index provider load deprecate index providers lucent lucent native lucent native also improve assertablelogprovider able verify multiple match order single log call
merge branch
use user log index provider deprecation warn index service deprecation warn show
graph entity type
support return array geometrical temporal type server
aka strategy restart quarantine shutdown unreachable members cluster membership stable majority reachable detect member quarantine reconnect restart actor system rejoin cluster detect cluster shut reconnect restart improve resilience case multiple members fail strict subset attempt rejoin
split relationship properties also change result structure procedures importantly basically inverse label output string
check database require recovery dump command call add additional check verify database properly shutdown produce database dump
add throughput status endpoint response status endpoint responses core include throughput raft index message per second
fail dump consistency check command case recovery check failure
remove static superfluous record store get record methods
remove storage reader relationship visit context less nature data read cursors well think life cycle
small cleanup
bump unit version
break nodepropertyaccessor index review use storage reader instead record store
bump mock version
storage cursor close close page cursor time reset method introduce usage allocate every use initialize close release allocate every use initialize reset close make natural use storage cursor try resource block
release file resources test respect flag clean test directories green test several place diligent hold descriptors open cause test failures windows fix
increase test coverage also make easier reason coverage
solve bug semantic check list comprehension
update cypher compiler dependencies
review comment always enough space
query full text node schema index via kernel apr instead via bypass also able produce score result transaction state move index tell clients via index take care transaction state behalf client auxiliary transaction state framework remove give query schema index full text schema index use build transaction state hierarchy full text index read collapse single new query predicate unusual use transaction state filter query relationship full text schema index transaction state break relationship counterpart relationships
back port change new schema procedures
add pull bolt
fix shortest path node predicate injection support per expand step evaluation node predicate cypher shortest path enable
try make faster
add test suggest change
add unit test demonstrate deadlock concurrent relationships creation
new simpler faster consistency checker complete rewrite checker code keep many algorithms current checker new checker none unnecessary complicate abstractions current checker check exploit cache less record read general check try take advantage many cup possible try keep sequential performance test indicate end end improvement vicinity current checker new checker also find inconsistencies current checker run memory constrain environments general structure newsimpleconsistencychecker construct single check method invoke individual checker run like node checker index checker relationship checker relationshipgroupchecker relationshipchainchecker individual checker run mostly isolation one thing connect cache access basically node centric heap chunk memory take bytes per node checker use cache either write something another checker read read later store scan checker run one checker also build count state verify count store end memory constrain enough memory hold node high bytes memory consistency check run multiple time time separate part node range new checker exist time side side current checker enable use set prove stable replace current checker set remove also internal consistency check tool add easily run consistency check another set quickly abort check find inconsistencies introduce
enrich negative test schema write
clean ternary compare fix lot issue add test clean
add count count store procedure
fix review comment
back port new schema procedures
clean
add support sample profile unit rule page cache test harness enable test flaky time recently
add support sample profile unit extension page cache test harness enable test flaky time recently
plan index scan relevant existence constraint
add integration test existence constraint also add constraints logicalplanningconfiguration fix test failures plan test
test index distinct value kernel apr level
test index distinct value kernel apr level
additional warn setups without define xxx ems settings add warn miss xxx ems settings warn neon users miss heuristic define heap settings
support nest statements bolt transactions success response run contain stat metadata field numeric execute statement pull message allow contain stat metadata field specify statement result pull recent statement result use pull provide stat handle run pull combo arrive time transaction state machine keep map open statement result statement ids key map result stream retrieve statement result base give stat pull use stat bolt state machine single transaction state handle run pull need support request like run run pull pull discard yet support supply stat minor fix allow pull minor fix make discard actually discard record instead stream back
consult property store distinguish distinct spatial value
consult property store distinguish distinct spatial value
improve documentation layout nodevalueindexcursortestbase
improve documentation layout nodevalueindexcursortestbase
remove morsel hack create new per thread
filter unique composite constraints
update author
change default behaviour throw default file find read
move kernel cursors life span init shutdown instead start stop
make test data local test
remove open seekers set nativeindexreader introduce time index reader query method return enclose able primitively iterator nowadays everything return initialize index read result closable caller responsible close
fix test errors
fix mock break test
rename folders include version name enough poms package name include version name need file structure well confuse git rename detection less future
ensure store value delete instance create modify statefullfieldextension store value remove context create
database level page cache wrapper wrap page cache separate database level page cache two restrict control access page cache database level flush page cache database level flush file relate database lookup exist mappings restrict file belong database etc change life cycle page cache flush close database etc separate
index procedures include cause failure throw fail index
shutdown databases recovery test
fix compilation errors extensive debase
new transaction log layout zip
add newline comment review
register use index physical compilation interpret slot
merge remote track branch
introduce ability perform parallel batch scan nod implement ability scan nod concurrently guarantee reader see different exclusive regions data far handle commit data transaction state handle later
better name multipleindexpopulator
turn redundant code lie around
allow batch parallel scan nod state basic idea materialize state array batch get iterator exclusive range array
avoid materialize state array hopefully slightly efficient memory handle create range iterator
merge remote track branch
merge branch
record storage engine module skeleton
remove unused storage engine methods clearbufferedids use role switch load headache use test one remain recordstorageengine test rely heavily upon anyway
solve bug star relationship pattern care largest block size candidate rather largest one loop finish
cleanup diagnostic loggers align case message pad message
collect store migration code one package
stop copy paste plugin configuration
update udo collector use new database manager
use constants instead instantiate empty class implementations
minor clean
handle state parallel label scan
split causal cluster group server client group
super simple concurrent store index statistics count index update size unique sample keep count store however nothing common node rel count except number index value update non transaction ally precise index service job trigger sample etc separate index relate things storage allow clarification dependency index storage store step direction store introduce new store name next new store file tree underneath start old store miss index stats file simply trigger sample startup good old index stats entries count store ignore remove next rotation explicit store migration may implement later need
move scala style configuration plugin management
add test discoverable uris
support continue inner loop code gen
rewrite interest order add test new part
fail state different bolt
remove build directory front end
bump neon browser
remove unneeded comment
add test nest loop continuations
merge branch
kernel instantiate index part proper force storage index label store storage engine force operation interface introduce check interim
code review range iterator take start size instead start stop remove make sure executor service shutdown finally block
rebate fix change range iterator work clean
merge remote track branch
kernel instantiate index part introduce indexupdatelistener register storage engine receive index update transactional change get apply
merge
move index descriptor subclasses since consider index reference implementations kernel land
clearer separation store descriptor storageindexreference assumptions regard index descriptors storageindexreference always store descriptor could waste anywhere stack assumptions remove instead separate storage kernel bite let storage provide storageindexreferences enter kernel land upon initial load online creation get convert kernel way decorate storageindexreference index capability sort instance turn use kernel index service index proxy etc
kernel instantiate index part move instantiation index service label store kernel longer responsibility storage engine previously dependency weird storage engine responsible instantiate service immediately kernel would rip storage engine use dependency resolver use core part kernel
kernel instantiate index part introduce nodelabelupdatelistener register storage engine receive node label update transactional change get apply
remove possibility interrupt generic job handle remove flag allow interrupt job handle case task cancellation require notification mechanics use instead since interrupt use control kind job process
include index information throw index population failure
plan sort
replace checkpoint service direct use check pointer service use backup store copy exclusively causal cluster component check pointer support non block trigger change make backup store copy less dependent reuse commercial single instance database
support parallel relationship scan
merge remote track branch
extract build label index index service methods
update neon scala commit base earlier commit max update front end scala
index reference longer extend storage index descriptor vein separate storage kernel even map index reference index descriptor add kernel state revolve around storage index descriptor may change later
precondition
rename collector procedures datacollectorprocedures
flush page file database drop move database drop database level allow page file mark delete close map
merge branch
merge remote track branch
netty final
merge branch
make procedures work index name addition index pattern
enforce dependency uniqueness check enable dependency convergence enforcer rule cleanup exclude duplicate version dependencies
avoid change behaviours instead add new procedure await index name reason fear express change procedure incompatible change
also make sure presence full text index schema match normal schema index prevent drop normal schema index
remove unused class
merge branch
merge branch
distinguish run time compile time failures cyphercomparisonsupport detect run time failures test mark expect fail certain configuration distinguish compile time failures compile time failures production handle fallback user friendly error run time failures indicate real bug add separate status code runtimeunsupportederror public exception runtimeunsupportedexception
finish removal old format update test use store test upgrade
update neon dump restore use correct database log database directories update dump restore command place data log correct directories multi database layout also update file transfer use buffer stream update test use database layout object test directory helpers much possible
correct node count return recordstoragereader nod account use value count store instead node store file
dynamic debug log level settings settings control log level internal log dynamic change run time default log level internal log specific log level per sub package
change empty tracers null tracers introduce constant name
never use core apr variable length path compile run time
use know target node variable length path expression
token holders change preparation schema store refactoring
merge branch
extract test utilities neon kernel apr separate module also move kernel apr test kernel since actual unit test anyway
back basic context map basic context back map mean user define function invocation spend significant amount time populate hash map see reason need case since key use statically know
avoid usage node record test
initial move record storage module
move apply record storage
move index update friends record storage
test fix move part
clean
fix spell mistake java doc comment author
mark new record format alpha suffix keep nice name release
merge remote track branch
sign
test harness rule include test harness rule user expose interfaces java doc cover reva enhance rule cover abilities previously leak testgraphdatabasefactory update name expose class
move relationshipcreatortest record storage
use scope run time neon record storage engine least components use dependency limit leakage detail rest product make restriction highlight abstraction problems store migration split storage migration database migration live kernel storage respectively hide command also highlight need expose token ids token command create access enid use least causal cluster
move store test neon record storage engine
rename platform global module create independent external dependencies interface move couple components platform module creation facade factory migrate field platform private letter change components name indicate global variants components database local variants
address review feedback
add privilege roles system graph modify predefined roles allow currently
remove old transaction log command readers lock leftovers explicit index
clean
change procedures use value
merge branch
migration store version fix also introduce storageenginefactory instantiate readable instantiate readablestorageengine read data
plug phase tracker index population extract phase tracker interface implement loggingphasetracker store give phase tracker instance scan start stop phase tracker indexpopulationjob finally clause make sure always log
initial draft new morsel architecture
save copy schema store code store migration code need able read legacy schema store store migrator implement ted new property base schema store
add license headers still struggle jar license
split ratio internal logic initialization internal logic split ratio set define large part key range keep leave node split useful sequential insert every leaf completely full sequential insert space right node split thus need split soon move key right node additional overhead split tree node implementations longer calculate middle pos split instead calculate split pos base ratiotokeepinleftonsplit include change consistency checker also verify meta header data node dynamic size nod mean verify regions add offset array cross offset internal logic initialize custom ratiotokeepinleftonsplit treenodedynamicsize overflow calculation pessimistic could end overflow even though enough space rename middle pos split pos rename function calculate middle node handle edge case possible split middle see update java doc split leaf edge case calculate split pos leaf break loop split pos keycountafterinsert instead current pos keycountafterinsert exit loop early ratiotokeepinleft keep much possible leave node insert pos new key last among key range break loop accumulate space total space mean accumulate many key able fit leave node thus come closer target space even current delta prev delta tell still move closer optimal split pos force continue loop possible case ratiotokeepinleft keep little possible leave node want stop move split pos immediately give best delta towards target space leave many key move right node however since neither leave right node hold total space thus force loop continue find split pos give divide leave right fit respective share edge case calculate split pos internal leaf decrement split pos previous position possible split want move backwards loop loop far move past point optimal position current delta prev delta move past end range split pos keycountafterinsert accumulate much data fit leave node accumulate space total space force continue loop current position possible divide possible move backwards loop previous position possible definition therefore move backwards loop previous possible
make internal logic split ratio test randomize
compilation fix long period base
schema store rewrite new schema store use property store represent schema rule map properties allow let index providers store nearly arbitrary configurations index simply add non conflict properties schema rule yet far lay grind work provide infrastructure key aspect complete schema rule map also serialise transaction log mean index configurations end journey also replicate cluster environment
remove close handler nettypipelinebuilder work reason pipeline builder install error handlers lead point close handler original nettypipelinebuilder usually one use handshake reason seem work catch channel actually use logic channel close events since use catch client catch channel already handle close channel event commit remove logic entirely instead try fix
test multiple block work
support pics jas keystones
start cleanup test explicitly extend astconstructiontestsupport also remove duplicate methods astconstructiontestsupport
add support compile procedures add basic skeleton allow procedures call without use reflection
merge database service database manager create clustereddatabasemanager unify cluster standalone editions manage databases add composite health service serve similar function composite database availability guard overhaul database manager interface extensible reorder edition module database manager construction sympathetic cluster initialisation order primarily make sure cluster modules depend database manager construct database manager rather take suppliers merge register databases list databases make database manager handle life cycle cluster specific components databasecorestatecomponents rewrite cluster bind bootstrapping initially apply clusteredmultidatabasemanager creatine database handle bootstrapping new database independently run time overhaul clusteredmultidatabasemanagertest write cluster versions multidatabasemanager stress test
finish class inherit constructionist directly
clean double assertions
add support call aggregate function without reflection
hook code generations remove unused stuff
let constrain creator notice transaction terminate sooner index fully populate wait smaller portion check termination status wait call reminder constraint transactions time longer happen due manual termination
update version part release
defer index service initialisation reverse recovery index service load schema cache need read store allow store bring consistent state reason defer load schema cache initialisation index service reverse recovery load schema cache initialise index service create index proxies forward recovery apply recover transactions store index
null merge
input instantiate mapper instead specify type
move partial sort partial top test run time spec suite
test failures
remove deprecate annotation
add test new schema store transactionrecordstatetest
add randomise test transaction log read write schema rule command arbitrary schema rule
merge branch
give name test parent artefact
removal endpoints restful database access
type var expand temporary variables variables
minimal fail test
implement run time expression variables
removal server plugins
slot nest expression
removal help endpoint
move count interfaces neon common
duplicate label relationship type constants ones read kernel apr use
generate amer per query never create variable name twice solve problems adduniquenesspredicates multiple var expand pattern want ensure cypher morph ism
multi database database selection support bolt multi database bolt server need select correct database start transaction base database name pass begin transaction via either bolt server perform database selection create correct towards correct database single database bolt connection initialize init hello message hold whole life time connection multi database bolt need decouple connection move creation point database name available state receive message message keep inside connection state message arrive clear reference current implementation rely message release resources towards database
preserve internal flag token record turn name token object allow token registry tell difference public internal tokens
use composite availability guard editions individual databases independent guard work umbrella global guard editions
acceptance test see cursor trip counter
review fix
see cursor throw stick infinite root catch loop catch root happen see cursor tripcountingrootcatchup keep track many time row retry node throw treeinconsistencyexception number exceed finger air number
obfuscate passwords create user
record internal flag tokens transaction log also make replicate penholder implement batch internal token create method
java docs
optimize assert allow check generalize assert allow method lambda parameter show significant overhead hot path profile use specialize methods instead
avoid new store file verify format instead open new store first verify format
